# DAG Schema

Canonical schema definition for task dependency graphs. Both the **Reviewer Agent** (generator) and **PM Agent** (consumer) reference this document.

---

## File Location

```
.karimo/prds/{NNN}_{slug}/dag.json
```

---

## Schema

```json
{
  "nodes": [
    { "id": "1a", "depends_on": [], "depth": 0 },
    { "id": "1b", "depends_on": ["1a"], "depth": 1 },
    { "id": "1c", "depends_on": ["1a"], "depth": 1 },
    { "id": "2a", "depends_on": ["1b", "1c"], "depth": 2 }
  ],
  "edges": [
    { "from": "1a", "to": "1b" },
    { "from": "1a", "to": "1c" },
    { "from": "1b", "to": "2a" },
    { "from": "1c", "to": "2a" }
  ],
  "critical_path": ["1a", "1b", "2a"],
  "parallel_groups": [
    ["1a"],
    ["1b", "1c"],
    ["2a"]
  ]
}
```

---

## Field Definitions

| Field | Type | Description |
|-------|------|-------------|
| `nodes` | `array<Node>` | All tasks with dependency and depth info |
| `edges` | `array<Edge>` | Directed edges representing dependencies |
| `critical_path` | `array<string>` | Task IDs forming the longest chain |
| `parallel_groups` | `array<array<string>>` | Groups of tasks that can execute concurrently |

### Node Object

| Field | Type | Description |
|-------|------|-------------|
| `id` | `string` | Task identifier (matches `tasks.yaml`) |
| `depends_on` | `array<string>` | Task IDs this task depends on |
| `depth` | `number` | Topological level (0 = no dependencies) |

### Edge Object

| Field | Type | Description |
|-------|------|-------------|
| `from` | `string` | Upstream task ID (dependency) |
| `to` | `string` | Downstream task ID (dependent) |

---

## Algorithms

### Depth Calculation (Topological Level via BFS)

Depth represents the "execution wave" — tasks at the same depth can theoretically run in parallel.

```
ALGORITHM: Calculate Depth

INPUT: nodes with depends_on arrays
OUTPUT: nodes with depth values

1. Initialize:
   - Set depth = 0 for all nodes with empty depends_on (roots)
   - Add roots to processing queue

2. BFS traversal:
   FOR each node in queue:
     FOR each downstream node that depends on this node:
       candidate_depth = current_node.depth + 1
       downstream.depth = MAX(downstream.depth, candidate_depth)
       IF all of downstream's dependencies have depth assigned:
         Add downstream to queue

3. Result:
   - depth 0: tasks with no dependencies
   - depth N: tasks whose longest dependency path has N edges
```

**Example:**
- Task A (deps: []) → depth 0
- Task B (deps: [A]) → depth 1
- Task C (deps: [A]) → depth 1
- Task D (deps: [B, C]) → depth 2

### Parallel Groups

Tasks are grouped by their depth value. All tasks at the same depth can execute concurrently (subject to file overlap adjustments at runtime).

```
ALGORITHM: Build Parallel Groups

INPUT: nodes with depth values
OUTPUT: array of task ID arrays

1. Group nodes by depth value
2. Sort groups by depth (ascending)
3. Extract task IDs for each group

RESULT: [[depth-0 tasks], [depth-1 tasks], [depth-2 tasks], ...]
```

**Note:** PM Agent may further split groups at runtime when tasks share `files_affected`. These runtime adjustments are tracked in `status.json`, not in `dag.json`.

### Critical Path

The critical path is the longest chain of dependent tasks (by count, not complexity). This represents the minimum number of sequential execution steps.

```
ALGORITHM: Find Critical Path

INPUT: nodes, edges
OUTPUT: array of task IDs (longest chain)

1. Find all root nodes (depth = 0)

2. DFS from each root:
   FOR each root:
     Run DFS, tracking the current path
     At each node, recurse to all dependents
     When a node has no dependents, record path length

3. Return the path with the most tasks

TIE-BREAKING: If multiple paths have equal length, prefer:
   - Lower task IDs (lexicographic)
   - Earlier in topological order
```

**Note:** This algorithm counts tasks, not complexity points. A path of 5 simple tasks is "longer" than a path of 2 complex tasks.

---

## Immutability

**dag.json is a planning artifact, not a runtime state file.**

| Aspect | Behavior |
|--------|----------|
| Generated by | Reviewer Agent (once, at PRD approval) |
| Modified during execution | **Never** |
| Runtime adjustments tracked in | `status.json` |
| Adjustment examples | File overlap splits, dependency resequencing |

The PM Agent reads `dag.json` for initial scheduling but tracks all runtime modifications in `status.json`. This preserves the original plan for auditing while allowing adaptive execution.

---

## Validation Rules

The Reviewer Agent validates:

1. **Referential integrity:** All `depends_on` IDs exist as node IDs
2. **No cycles:** The graph is acyclic (dependencies are satisfiable)
3. **Connectivity:** No orphaned tasks (all tasks reachable or are roots)
4. **Consistency:** Edges match depends_on relationships bidirectionally

---

## Example Walkthrough

Given tasks:
- **1a**: Setup auth (deps: none)
- **1b**: Create profile API (deps: 1a)
- **1c**: Create settings API (deps: 1a)
- **2a**: Profile UI (deps: 1b, 1c)

**Step 1: Calculate depths**
- 1a: depth 0 (no deps)
- 1b: depth 1 (depends on 1a at depth 0)
- 1c: depth 1 (depends on 1a at depth 0)
- 2a: depth 2 (max(1b.depth, 1c.depth) + 1)

**Step 2: Build parallel groups**
- Group 0: [1a]
- Group 1: [1b, 1c]
- Group 2: [2a]

**Step 3: Find critical path**
- Path A: 1a → 1b → 2a (length 3)
- Path B: 1a → 1c → 2a (length 3)
- Tie-break: [1a, 1b, 2a] (1b < 1c lexicographically)

**Result:**
```json
{
  "nodes": [
    { "id": "1a", "depends_on": [], "depth": 0 },
    { "id": "1b", "depends_on": ["1a"], "depth": 1 },
    { "id": "1c", "depends_on": ["1a"], "depth": 1 },
    { "id": "2a", "depends_on": ["1b", "1c"], "depth": 2 }
  ],
  "edges": [
    { "from": "1a", "to": "1b" },
    { "from": "1a", "to": "1c" },
    { "from": "1b", "to": "2a" },
    { "from": "1c", "to": "2a" }
  ],
  "critical_path": ["1a", "1b", "2a"],
  "parallel_groups": [["1a"], ["1b", "1c"], ["2a"]]
}
```

/**
 * KARIMO GitHub PR Operations
 *
 * High-level PR operations using either Octokit client or gh CLI fallback.
 * Includes KARIMO-styled PR body generation.
 */

import { PrCreateError } from './errors'
import { ghExec, ghExecJson } from './exec'
import { createGitHubClient, hasGitHubToken } from './client'
import type {
  CreatePrOptions,
  GitHubClient,
  PrBodyContext,
  PrResult,
  PrStatusResult,
} from './types'

/**
 * Build KARIMO-styled PR body from context.
 *
 * @param context - Context for building PR body
 * @returns Formatted PR body markdown
 *
 * @example
 * ```typescript
 * const body = buildPrBody({
 *   taskId: '1a',
 *   phaseId: 'phase-1',
 *   complexity: 5,
 *   costCeiling: 15,
 *   description: 'Implement user authentication',
 *   files: ['src/auth.ts', 'src/middleware.ts'],
 *   cautionFiles: ['src/auth.ts'],
 * })
 * ```
 */
export function buildPrBody(context: PrBodyContext): string {
  const {
    taskId,
    phaseId,
    complexity,
    costCeiling,
    description,
    files,
    cautionFiles = [],
    successCriteria = [],
  } = context

  const sections: string[] = []

  // Header
  sections.push('## :robot: KARIMO Automated PR')
  sections.push('')
  sections.push(`**Task:** ${taskId}`)
  sections.push(`**Phase:** ${phaseId}`)
  sections.push(`**Complexity:** ${complexity}/10`)
  sections.push(`**Cost Ceiling:** $${costCeiling}`)
  sections.push('')

  // Changes
  sections.push('### Changes')
  sections.push(description)
  sections.push('')

  // Files Affected
  sections.push('### Files Affected')
  if (files.length > 0) {
    for (const file of files) {
      sections.push(`- \`${file}\``)
    }
  } else {
    sections.push('_No files affected_')
  }
  sections.push('')

  // Caution Files (only if present)
  if (cautionFiles.length > 0) {
    sections.push('### Caution Files :warning:')
    sections.push('The following files require careful review:')
    for (const file of cautionFiles) {
      sections.push(`- \`${file}\``)
    }
    sections.push('')
  }

  // Success Criteria (if present)
  if (successCriteria.length > 0) {
    sections.push('### Success Criteria')
    for (const criterion of successCriteria) {
      sections.push(`- [ ] ${criterion}`)
    }
    sections.push('')
  }

  // Validation checklist
  sections.push('### Validation')
  sections.push('- [ ] `bun run build` passes')
  sections.push('- [ ] `bun run typecheck` passes')
  sections.push('- [ ] `bun run lint` passes')
  sections.push('')

  // Footer
  sections.push('---')
  sections.push('*Generated by [KARIMO](https://github.com/opensesh/KARIMO)*')

  return sections.join('\n')
}

/**
 * Create a pull request using Octokit or gh CLI fallback.
 *
 * @param options - PR creation options
 * @param client - Optional pre-configured GitHubClient
 * @returns Created PR result
 * @throws {PrCreateError} If PR creation fails
 *
 * @example
 * ```typescript
 * const pr = await createPullRequest({
 *   owner: 'opensesh',
 *   repo: 'KARIMO',
 *   head: 'feature/phase-1/task-a',
 *   base: 'main',
 *   title: 'feat: implement task A',
 *   body: buildPrBody(context),
 *   draft: true,
 * })
 * console.log(`Created PR #${pr.number}: ${pr.url}`)
 * ```
 */
export async function createPullRequest(
  options: CreatePrOptions,
  client?: GitHubClient
): Promise<PrResult> {
  // Try Octokit first
  if (client || (await hasGitHubToken())) {
    try {
      const ghClient = client ?? (await createGitHubClient())
      return await ghClient.createPullRequest(options)
    } catch (error) {
      // Fall through to gh CLI
      console.debug('Octokit PR creation failed, trying gh CLI:', error)
    }
  }

  // Fallback to gh CLI
  try {
    const args = [
      'pr', 'create',
      '--repo', `${options.owner}/${options.repo}`,
      '--head', options.head,
      '--base', options.base,
      '--title', options.title,
      '--body', options.body,
    ]

    if (options.draft) {
      args.push('--draft')
    }

    if (options.labels && options.labels.length > 0) {
      args.push('--label', options.labels.join(','))
    }

    if (options.reviewers && options.reviewers.length > 0) {
      args.push('--reviewer', options.reviewers.join(','))
    }

    const result = await ghExec(args)

    // Parse the PR URL from output
    const url = result.stdout.trim()
    const prNumberMatch = url.match(/\/pull\/(\d+)$/)
    const prNumber = prNumberMatch ? Number.parseInt(prNumberMatch[1], 10) : 0

    return {
      number: prNumber,
      url,
      nodeId: '', // Not available from CLI
      state: 'open',
      draft: options.draft ?? false,
      head: options.head,
      base: options.base,
    }
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error)
    throw new PrCreateError(options.head, options.base, message)
  }
}

/**
 * Get PR status using Octokit or gh CLI fallback.
 *
 * @param owner - Repository owner
 * @param repo - Repository name
 * @param number - PR number
 * @param client - Optional pre-configured GitHubClient
 * @returns PR status
 */
export async function getPrStatus(
  owner: string,
  repo: string,
  number: number,
  client?: GitHubClient
): Promise<PrStatusResult> {
  // Try Octokit first
  if (client || (await hasGitHubToken())) {
    try {
      const ghClient = client ?? (await createGitHubClient())
      return await ghClient.getPullRequest(owner, repo, number)
    } catch (error) {
      // Fall through to gh CLI
      console.debug('Octokit getPullRequest failed, trying gh CLI:', error)
    }
  }

  // Fallback to gh CLI
  const jsonFields = [
    'number', 'state', 'isDraft', 'mergeable',
    'comments', 'commits', 'changedFiles', 'additions', 'deletions',
  ].join(',')

  const pr = await ghExecJson<{
    number: number
    state: string
    isDraft: boolean
    mergeable: string
    comments: { totalCount: number }
    commits: { totalCount: number }
    changedFiles: number
    additions: number
    deletions: number
  }>([
    'pr', 'view', String(number),
    '--repo', `${owner}/${repo}`,
    '--json', jsonFields,
  ])

  return {
    number: pr.number,
    state: pr.state as 'open' | 'closed',
    merged: pr.state === 'merged',
    draft: pr.isDraft,
    mergeable: pr.mergeable === 'MERGEABLE',
    mergeableState: mapMergeableFromCli(pr.mergeable),
    reviewDecision: null,
    statusCheckRollup: null,
    comments: pr.comments?.totalCount ?? 0,
    commits: pr.commits?.totalCount ?? 0,
    changedFiles: pr.changedFiles,
    additions: pr.additions,
    deletions: pr.deletions,
  }
}

/**
 * Add labels to a PR.
 *
 * @param owner - Repository owner
 * @param repo - Repository name
 * @param number - PR number
 * @param labels - Labels to add
 * @param client - Optional pre-configured GitHubClient
 */
export async function addLabels(
  owner: string,
  repo: string,
  number: number,
  labels: string[],
  client?: GitHubClient
): Promise<void> {
  if (labels.length === 0) return

  // Try Octokit first
  if (client || (await hasGitHubToken())) {
    try {
      const ghClient = client ?? (await createGitHubClient())
      await ghClient.addLabels(owner, repo, number, labels)
      return
    } catch {
      // Fall through to gh CLI
    }
  }

  // Fallback to gh CLI
  await ghExec([
    'pr', 'edit', String(number),
    '--repo', `${owner}/${repo}`,
    '--add-label', labels.join(','),
  ])
}

/**
 * Remove labels from a PR.
 *
 * @param owner - Repository owner
 * @param repo - Repository name
 * @param number - PR number
 * @param labels - Labels to remove
 * @param client - Optional pre-configured GitHubClient
 */
export async function removeLabels(
  owner: string,
  repo: string,
  number: number,
  labels: string[],
  client?: GitHubClient
): Promise<void> {
  if (labels.length === 0) return

  // Try Octokit first
  if (client || (await hasGitHubToken())) {
    try {
      const ghClient = client ?? (await createGitHubClient())
      await ghClient.removeLabels(owner, repo, number, labels)
      return
    } catch {
      // Fall through to gh CLI
    }
  }

  // Fallback to gh CLI
  await ghExec([
    'pr', 'edit', String(number),
    '--repo', `${owner}/${repo}`,
    '--remove-label', labels.join(','),
  ])
}

/**
 * Close a PR.
 *
 * @param owner - Repository owner
 * @param repo - Repository name
 * @param number - PR number
 */
export async function closePr(
  owner: string,
  repo: string,
  number: number
): Promise<void> {
  await ghExec([
    'pr', 'close', String(number),
    '--repo', `${owner}/${repo}`,
  ])
}

/**
 * Reopen a closed PR.
 *
 * @param owner - Repository owner
 * @param repo - Repository name
 * @param number - PR number
 */
export async function reopenPr(
  owner: string,
  repo: string,
  number: number
): Promise<void> {
  await ghExec([
    'pr', 'reopen', String(number),
    '--repo', `${owner}/${repo}`,
  ])
}

/**
 * Mark a draft PR as ready for review.
 *
 * @param owner - Repository owner
 * @param repo - Repository name
 * @param number - PR number
 */
export async function markReadyForReview(
  owner: string,
  repo: string,
  number: number
): Promise<void> {
  await ghExec([
    'pr', 'ready', String(number),
    '--repo', `${owner}/${repo}`,
  ])
}

/**
 * Map gh CLI mergeable state to our enum.
 */
function mapMergeableFromCli(
  state: string
): 'clean' | 'dirty' | 'blocked' | 'behind' | 'unknown' {
  switch (state?.toUpperCase()) {
    case 'MERGEABLE':
      return 'clean'
    case 'CONFLICTING':
      return 'dirty'
    case 'BLOCKED':
      return 'blocked'
    default:
      return 'unknown'
  }
}

// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = import.meta.require;

// src/orchestrator/errors.ts
var KarimoOrchestratorError, TaskNotFoundError, PhaseNotFoundError, PrePRCheckError, NeverTouchViolationError, RebaseConflictError, WorktreeError, PRCreationError;
var init_errors = __esm(() => {
  KarimoOrchestratorError = class KarimoOrchestratorError extends Error {
    constructor(message) {
      super(message);
      this.name = "KarimoOrchestratorError";
      Object.setPrototypeOf(this, new.target.prototype);
    }
  };
  TaskNotFoundError = class TaskNotFoundError extends KarimoOrchestratorError {
    taskId;
    phaseId;
    constructor(taskId, phaseId) {
      super(`Task "${taskId}" not found in phase "${phaseId}"`);
      this.name = "TaskNotFoundError";
      this.taskId = taskId;
      this.phaseId = phaseId;
    }
  };
  PhaseNotFoundError = class PhaseNotFoundError extends KarimoOrchestratorError {
    phaseId;
    prdPath;
    constructor(phaseId, prdPath) {
      super(`Phase "${phaseId}" PRD not found at "${prdPath}"`);
      this.name = "PhaseNotFoundError";
      this.phaseId = phaseId;
      this.prdPath = prdPath;
    }
  };
  PrePRCheckError = class PrePRCheckError extends KarimoOrchestratorError {
    checkType;
    details;
    constructor(checkType, details) {
      super(`Pre-PR ${checkType} check failed: ${details}`);
      this.name = "PrePRCheckError";
      this.checkType = checkType;
      this.details = details;
    }
  };
  NeverTouchViolationError = class NeverTouchViolationError extends KarimoOrchestratorError {
    violations;
    constructor(violations) {
      const fileList = violations.map((v) => v.file).join(", ");
      super(`Forbidden files modified: ${fileList}`);
      this.name = "NeverTouchViolationError";
      this.violations = violations;
    }
  };
  RebaseConflictError = class RebaseConflictError extends KarimoOrchestratorError {
    conflictFiles;
    targetBranch;
    constructor(conflictFiles, targetBranch) {
      super(`Rebase onto "${targetBranch}" has conflicts in: ${conflictFiles.join(", ")}`);
      this.name = "RebaseConflictError";
      this.conflictFiles = conflictFiles;
      this.targetBranch = targetBranch;
    }
  };
  WorktreeError = class WorktreeError extends KarimoOrchestratorError {
    phaseId;
    reason;
    constructor(phaseId, reason) {
      super(`Worktree operation failed for phase "${phaseId}": ${reason}`);
      this.name = "WorktreeError";
      this.phaseId = phaseId;
      this.reason = reason;
    }
  };
  PRCreationError = class PRCreationError extends KarimoOrchestratorError {
    taskId;
    reason;
    constructor(taskId, reason) {
      super(`Failed to create PR for task "${taskId}": ${reason}`);
      this.name = "PRCreationError";
      this.taskId = taskId;
      this.reason = reason;
    }
  };
});

// src/git/errors.ts
var KarimoGitError, GitCommandError, WorktreeCreateError, BranchCreateError;
var init_errors2 = __esm(() => {
  KarimoGitError = class KarimoGitError extends Error {
    constructor(message) {
      super(message);
      this.name = "KarimoGitError";
    }
  };
  GitCommandError = class GitCommandError extends KarimoGitError {
    args;
    exitCode;
    stderr;
    cwd;
    constructor(args, exitCode, stderr, cwd) {
      const cmd = `git ${args.join(" ")}`;
      const cwdInfo = cwd ? `
  Working directory: ${cwd}` : "";
      super(`Git command failed.
  Command: ${cmd}${cwdInfo}
  Exit code: ${exitCode}
  Error: ${stderr.trim()}

Check that git is installed and the repository state is valid.`);
      this.args = args;
      this.exitCode = exitCode;
      this.stderr = stderr;
      this.cwd = cwd;
      this.name = "GitCommandError";
    }
  };
  WorktreeCreateError = class WorktreeCreateError extends KarimoGitError {
    worktreePath;
    branch;
    reason;
    constructor(worktreePath, branch, reason) {
      super(`Failed to create worktree.
  Path: ${worktreePath}
  Branch: ${branch}
  Reason: ${reason}

Ensure the path is valid and the branch exists or can be created.`);
      this.worktreePath = worktreePath;
      this.branch = branch;
      this.reason = reason;
      this.name = "WorktreeCreateError";
    }
  };
  BranchCreateError = class BranchCreateError extends KarimoGitError {
    branchName;
    reason;
    constructor(branchName, reason) {
      super(`Failed to create branch.
  Branch: ${branchName}
  Reason: ${reason}

Ensure the branch name is valid and doesn't already exist.`);
      this.branchName = branchName;
      this.reason = reason;
      this.name = "BranchCreateError";
    }
  };
});

// src/git/exec.ts
async function gitExec(args, options = {}) {
  const { cwd, timeout = DEFAULT_TIMEOUT, throwOnError = true, env = {} } = options;
  const gitEnv = {
    ...process.env,
    ...env,
    GIT_PAGER: "",
    LC_ALL: "C"
  };
  const proc = Bun.spawn(["git", ...args], {
    ...cwd !== undefined && { cwd },
    env: gitEnv,
    stdout: "pipe",
    stderr: "pipe"
  });
  const timeoutPromise = new Promise((_, reject) => {
    const id = setTimeout(() => {
      proc.kill();
      reject(new GitCommandError(args, -1, `Command timed out after ${timeout}ms`, cwd));
    }, timeout);
    proc.exited.then(() => clearTimeout(id)).catch(() => clearTimeout(id));
  });
  const exitCode = await Promise.race([proc.exited, timeoutPromise]);
  const stdout = await new Response(proc.stdout).text();
  const stderr = await new Response(proc.stderr).text();
  const success = exitCode === 0;
  if (!success && throwOnError) {
    throw new GitCommandError(args, exitCode, stderr, cwd);
  }
  return {
    exitCode,
    stdout,
    stderr,
    success
  };
}
async function getRepoRoot(cwd) {
  const result = await gitExec(["rev-parse", "--show-toplevel"], cwd !== undefined ? { cwd } : {});
  return result.stdout.trim();
}
async function getDefaultBranch(cwd) {
  const result = await gitExec(["symbolic-ref", "--short", "refs/remotes/origin/HEAD"], {
    ...cwd !== undefined && { cwd },
    throwOnError: false
  });
  if (result.success) {
    const parts = result.stdout.trim().split("/");
    return parts[parts.length - 1] ?? "main";
  }
  const mainCheck = await gitExec(["show-ref", "--verify", "--quiet", "refs/heads/main"], {
    ...cwd !== undefined && { cwd },
    throwOnError: false
  });
  return mainCheck.success ? "main" : "master";
}
var DEFAULT_TIMEOUT = 30000;
var init_exec = __esm(() => {
  init_errors2();
});

// src/git/worktree.ts
import { join } from "path";
function parseWorktreeList(output) {
  const worktrees = [];
  const lines = output.trim().split(`
`);
  let current = {};
  for (const line of lines) {
    if (line.startsWith("worktree ")) {
      if (current.path) {
        worktrees.push(current);
      }
      current = {
        path: line.slice("worktree ".length),
        branch: "",
        head: "",
        isDetached: false,
        isMain: false
      };
    } else if (line.startsWith("HEAD ")) {
      current.head = line.slice("HEAD ".length);
    } else if (line.startsWith("branch ")) {
      const branchRef = line.slice("branch ".length);
      current.branch = branchRef.replace("refs/heads/", "");
    } else if (line === "detached") {
      current.isDetached = true;
    } else if (line === "bare") {
      current = {};
    }
  }
  if (current.path) {
    worktrees.push(current);
  }
  if (worktrees[0]) {
    worktrees[0].isMain = true;
  }
  return worktrees;
}
async function listWorktrees(repoPath) {
  const result = await gitExec(["worktree", "list", "--porcelain"], repoPath !== undefined ? { cwd: repoPath } : {});
  return parseWorktreeList(result.stdout);
}
async function worktreeExists(worktreePath, repoPath) {
  const worktrees = await listWorktrees(repoPath);
  return worktrees.some((wt) => wt.path === worktreePath);
}
async function createWorktree(basePath, phaseId, branch, options = {}) {
  const repoRoot = await getRepoRoot(basePath);
  const worktreePath = join(basePath, "worktrees", phaseId);
  if (await worktreeExists(worktreePath, repoRoot)) {
    return worktreePath;
  }
  const branchCheck = await gitExec(["show-ref", "--verify", "--quiet", `refs/heads/${branch}`], {
    cwd: repoRoot,
    throwOnError: false
  });
  if (branchCheck.success) {
    const result = await gitExec(["worktree", "add", worktreePath, branch], {
      cwd: repoRoot,
      ...options,
      throwOnError: false
    });
    if (!result.success) {
      throw new WorktreeCreateError(worktreePath, branch, result.stderr.trim());
    }
  } else {
    const result = await gitExec(["worktree", "add", "-b", branch, worktreePath], {
      cwd: repoRoot,
      ...options,
      throwOnError: false
    });
    if (!result.success) {
      throw new WorktreeCreateError(worktreePath, branch, result.stderr.trim());
    }
  }
  return worktreePath;
}
async function removeWorktree(worktreePath, options = {}) {
  const { force = false, repoPath } = options;
  const args = ["worktree", "remove"];
  if (force) {
    args.push("--force");
  }
  args.push(worktreePath);
  await gitExec(args, repoPath !== undefined ? { cwd: repoPath } : {});
}
var init_worktree = __esm(() => {
  init_errors2();
  init_exec();
});

// src/git/branch.ts
async function createTaskBranch(phaseId, taskId, baseBranch, options = {}) {
  const branchName = `feature/${phaseId}/${taskId}`;
  const base = baseBranch ?? await getDefaultBranch(options.cwd);
  if (await branchExists(branchName, options.cwd)) {
    return branchName;
  }
  const result = await gitExec(["checkout", "-b", branchName, base], {
    ...options,
    throwOnError: false
  });
  if (!result.success) {
    throw new BranchCreateError(branchName, result.stderr.trim());
  }
  return branchName;
}
async function branchExists(branchName, cwd, checkRemote = true) {
  const localResult = await gitExec(["show-ref", "--verify", "--quiet", `refs/heads/${branchName}`], {
    ...cwd !== undefined && { cwd },
    throwOnError: false
  });
  if (localResult.success) {
    return true;
  }
  if (checkRemote) {
    const remoteResult = await gitExec(["show-ref", "--verify", "--quiet", `refs/remotes/origin/${branchName}`], {
      ...cwd !== undefined && { cwd },
      throwOnError: false
    });
    return remoteResult.success;
  }
  return false;
}
async function pushBranch(branchName, remote = "origin", options = {}) {
  await gitExec(["push", "-u", remote, branchName], options);
}
var init_branch = __esm(() => {
  init_errors2();
  init_exec();
});

// src/git/rebase.ts
async function rebaseOntoTarget(targetBranch, options = {}) {
  const result = await gitExec(["rebase", targetBranch], {
    ...options,
    throwOnError: false
  });
  if (result.success) {
    return {
      success: true,
      conflictFiles: []
    };
  }
  const isConflict = result.stderr.includes("CONFLICT") || result.stderr.includes("could not apply") || result.stderr.includes("Resolve all conflicts") || result.stdout.includes("CONFLICT");
  if (isConflict) {
    const conflictFiles = await getConflictFiles(options.cwd);
    await abortRebase(options);
    return {
      success: false,
      conflictFiles
    };
  }
  return {
    success: false,
    conflictFiles: [],
    error: result.stderr.trim() || result.stdout.trim()
  };
}
async function abortRebase(options = {}) {
  if (!await isRebaseInProgress(options.cwd)) {
    return;
  }
  await gitExec(["rebase", "--abort"], options);
}
async function isRebaseInProgress(cwd) {
  const result = await gitExec(["rev-parse", "--git-path", "rebase-merge"], {
    ...cwd !== undefined && { cwd },
    throwOnError: false
  });
  if (result.success) {
    const rebaseMergePath = result.stdout.trim();
    const exists = await Bun.file(rebaseMergePath).exists();
    if (exists) {
      return true;
    }
  }
  const applyResult = await gitExec(["rev-parse", "--git-path", "rebase-apply"], {
    ...cwd !== undefined && { cwd },
    throwOnError: false
  });
  if (applyResult.success) {
    const rebaseApplyPath = applyResult.stdout.trim();
    return Bun.file(rebaseApplyPath).exists();
  }
  return false;
}
async function getConflictFiles(cwd) {
  const result = await gitExec(["diff", "--name-only", "--diff-filter=U"], {
    ...cwd !== undefined && { cwd },
    throwOnError: false
  });
  if (!result.success) {
    return [];
  }
  return result.stdout.trim().split(`
`).filter((f) => f.length > 0);
}
var init_rebase = __esm(() => {
  init_exec();
});

// src/git/diff.ts
var {Glob } = globalThis.Bun;
async function getChangedFiles(baseRef, headRef = "HEAD", options = {}) {
  const result = await gitExec(["diff", "--name-only", `${baseRef}...${headRef}`], options);
  return result.stdout.trim().split(`
`).filter((f) => f.length > 0);
}
function matchesPattern(filePath, pattern) {
  if (!pattern.includes("*") && !pattern.includes("?") && !pattern.includes("[")) {
    const normalizedFile = filePath.replace(/\\/g, "/");
    const normalizedPattern = pattern.replace(/\\/g, "/");
    return normalizedFile === normalizedPattern || normalizedFile.endsWith(`/${normalizedPattern}`);
  }
  const glob = new Glob(pattern);
  return glob.match(filePath);
}
function detectCautionFiles(changedFiles, patterns) {
  const matches = [];
  const cautionFiles = [];
  for (const file of changedFiles) {
    for (const pattern of patterns) {
      if (matchesPattern(file, pattern)) {
        if (!cautionFiles.includes(file)) {
          cautionFiles.push(file);
        }
        matches.push({ file, pattern });
        break;
      }
    }
  }
  return {
    cautionFiles,
    matches
  };
}
function detectNeverTouchViolations(changedFiles, neverTouchPatterns) {
  const violations = [];
  for (const file of changedFiles) {
    for (const pattern of neverTouchPatterns) {
      if (matchesPattern(file, pattern)) {
        violations.push({ file, pattern });
        break;
      }
    }
  }
  return violations;
}
var init_diff = __esm(() => {
  init_exec();
});

// src/git/index.ts
var init_git = __esm(() => {
  init_errors2();
  init_exec();
  init_worktree();
  init_branch();
  init_rebase();
  init_diff();
});

// src/orchestrator/pre-pr-checks.ts
async function runCommand(command, cwd) {
  const startTime = Date.now();
  try {
    const parts = command.split(" ").filter((p) => p.length > 0);
    const cmd = parts[0];
    const args = parts.slice(1);
    if (!cmd) {
      return {
        command,
        success: false,
        exitCode: 1,
        stdout: "",
        stderr: "Empty command",
        durationMs: Date.now() - startTime
      };
    }
    const proc = Bun.spawn([cmd, ...args], {
      cwd,
      stdout: "pipe",
      stderr: "pipe",
      env: process.env
    });
    const exitCode = await proc.exited;
    const stdout = await new Response(proc.stdout).text();
    const stderr = await new Response(proc.stderr).text();
    return {
      command,
      success: exitCode === 0,
      exitCode,
      stdout,
      stderr,
      durationMs: Date.now() - startTime
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      command,
      success: false,
      exitCode: 1,
      stdout: "",
      stderr: message,
      durationMs: Date.now() - startTime
    };
  }
}
async function prePRChecks(options) {
  const {
    worktreePath,
    targetBranch,
    buildCommand,
    typecheckCommand,
    neverTouchPatterns,
    requireReviewPatterns
  } = options;
  const rebaseResult = await rebaseOntoTarget(targetBranch, { cwd: worktreePath });
  if (!rebaseResult.success) {
    if (rebaseResult.conflictFiles.length > 0) {
      return {
        success: false,
        rebase: {
          success: false,
          conflictFiles: rebaseResult.conflictFiles
        },
        changedFiles: [],
        cautionFiles: [],
        neverTouchViolations: [],
        errorMessage: `Rebase conflicts in: ${rebaseResult.conflictFiles.join(", ")}`
      };
    }
    return {
      success: false,
      rebase: {
        success: false,
        conflictFiles: []
      },
      changedFiles: [],
      cautionFiles: [],
      neverTouchViolations: [],
      errorMessage: `Rebase failed: ${rebaseResult.error ?? "Unknown error"}`
    };
  }
  const buildResult = await runCommand(buildCommand, worktreePath);
  if (!buildResult.success) {
    return {
      success: false,
      rebase: { success: true, conflictFiles: [] },
      build: buildResult,
      changedFiles: [],
      cautionFiles: [],
      neverTouchViolations: [],
      errorMessage: `Build failed with exit code ${buildResult.exitCode}`
    };
  }
  let typecheckResult;
  if (typecheckCommand !== null) {
    typecheckResult = await runCommand(typecheckCommand, worktreePath);
    if (!typecheckResult.success) {
      return {
        success: false,
        rebase: { success: true, conflictFiles: [] },
        build: buildResult,
        typecheck: typecheckResult,
        changedFiles: [],
        cautionFiles: [],
        neverTouchViolations: [],
        errorMessage: `Typecheck failed with exit code ${typecheckResult.exitCode}`
      };
    }
  }
  const changedFiles = await getChangedFiles(targetBranch, "HEAD", { cwd: worktreePath });
  const cautionResult = detectCautionFiles(changedFiles, requireReviewPatterns);
  const cautionFiles = cautionResult.cautionFiles;
  const violations = detectNeverTouchViolations(changedFiles, neverTouchPatterns);
  if (violations.length > 0) {
    return {
      success: false,
      rebase: { success: true, conflictFiles: [] },
      build: buildResult,
      ...typecheckResult !== undefined && { typecheck: typecheckResult },
      changedFiles,
      cautionFiles,
      neverTouchViolations: violations,
      errorMessage: `Forbidden files modified: ${violations.map((v) => v.file).join(", ")}`
    };
  }
  return {
    success: true,
    rebase: { success: true, conflictFiles: [] },
    build: buildResult,
    ...typecheckResult !== undefined && { typecheck: typecheckResult },
    changedFiles,
    cautionFiles,
    neverTouchViolations: []
  };
}
var init_pre_pr_checks = __esm(() => {
  init_git();
});

// src/agents/errors.ts
var KarimoAgentError, AgentNotFoundError, AgentSpawnError, AgentTimeoutError;
var init_errors3 = __esm(() => {
  KarimoAgentError = class KarimoAgentError extends Error {
    constructor(message) {
      super(message);
      this.name = "KarimoAgentError";
      Object.setPrototypeOf(this, new.target.prototype);
    }
  };
  AgentNotFoundError = class AgentNotFoundError extends KarimoAgentError {
    engine;
    constructor(engine) {
      super(`Agent engine "${engine}" is not installed or not available in PATH`);
      this.name = "AgentNotFoundError";
      this.engine = engine;
    }
  };
  AgentSpawnError = class AgentSpawnError extends KarimoAgentError {
    engine;
    reason;
    constructor(engine, reason) {
      super(`Failed to spawn ${engine} agent: ${reason}`);
      this.name = "AgentSpawnError";
      this.engine = engine;
      this.reason = reason;
    }
  };
  AgentTimeoutError = class AgentTimeoutError extends KarimoAgentError {
    engine;
    timeoutMs;
    constructor(engine, timeoutMs) {
      super(`Agent ${engine} timed out after ${timeoutMs}ms`);
      this.name = "AgentTimeoutError";
      this.engine = engine;
      this.timeoutMs = timeoutMs;
    }
  };
});

// src/agents/prompt-builder.ts
function buildAgentPrompt(context) {
  const { task, config, phaseId } = context;
  const sections = [];
  sections.push("# KARIMO Task Execution");
  sections.push("");
  sections.push(`You are executing task **${task.id}** from phase **${phaseId}**.`);
  sections.push("");
  sections.push("## Task");
  sections.push("");
  sections.push(`**Title:** ${task.title}`);
  sections.push("");
  sections.push("**Description:**");
  sections.push(task.description);
  sections.push("");
  if (task.success_criteria.length > 0) {
    sections.push("## Success Criteria");
    sections.push("");
    sections.push("Your implementation must satisfy ALL of the following:");
    sections.push("");
    for (const criterion of task.success_criteria) {
      sections.push(`- ${criterion}`);
    }
    sections.push("");
  }
  if (task.files_affected.length > 0) {
    sections.push("## Scope");
    sections.push("");
    sections.push("Focus your changes on these files/directories:");
    sections.push("");
    for (const file of task.files_affected) {
      sections.push(`- \`${file}\``);
    }
    sections.push("");
  }
  if (task.agent_context) {
    sections.push("## Additional Context");
    sections.push("");
    sections.push(task.agent_context);
    sections.push("");
  }
  if (config.rules.length > 0) {
    sections.push("## Project Rules");
    sections.push("");
    sections.push("You MUST follow these rules:");
    sections.push("");
    for (const rule of config.rules) {
      sections.push(`- ${rule}`);
    }
    sections.push("");
  }
  const hasNeverTouch = config.boundaries.never_touch.length > 0;
  const hasRequireReview = config.boundaries.require_review.length > 0;
  if (hasNeverTouch || hasRequireReview) {
    sections.push("## File Boundaries");
    sections.push("");
    if (hasNeverTouch) {
      sections.push("### FORBIDDEN Files (never modify)");
      sections.push("");
      sections.push("Do NOT modify or create files matching these patterns:");
      sections.push("");
      for (const pattern of config.boundaries.never_touch) {
        sections.push(`- \`${pattern}\``);
      }
      sections.push("");
    }
    if (hasRequireReview) {
      sections.push("### Caution Files (require review)");
      sections.push("");
      sections.push("Changes to files matching these patterns will flag the PR for review:");
      sections.push("");
      for (const pattern of config.boundaries.require_review) {
        sections.push(`- \`${pattern}\``);
      }
      sections.push("");
    }
  }
  sections.push("## Validation");
  sections.push("");
  sections.push("Before completing, ensure your changes pass:");
  sections.push("");
  sections.push(`1. **Build:** \`${config.commands.build}\``);
  sections.push(`2. **Type check:** \`${config.commands.typecheck}\``);
  sections.push(`3. **Lint:** \`${config.commands.lint}\``);
  sections.push("");
  sections.push("## Budget");
  sections.push("");
  sections.push(`- **Complexity:** ${task.complexity}/10`);
  sections.push(`- **Cost Ceiling:** $${task.cost_ceiling}`);
  sections.push(`- **Estimated Iterations:** ${task.estimated_iterations}`);
  sections.push("");
  sections.push("## Instructions");
  sections.push("");
  sections.push("1. Implement the changes required to satisfy all success criteria");
  sections.push("2. Run the validation commands and fix any issues");
  sections.push("3. Commit your changes with clear, descriptive messages");
  sections.push("4. Keep changes focused on the task scope");
  sections.push("");
  return sections.join(`
`);
}

// src/agents/sandbox.ts
function buildAgentEnvironment(config) {
  const env = {};
  const allowedSet = new Set(config.sandbox.allowed_env);
  const excludeSet = new Set(ALWAYS_EXCLUDE);
  for (const key of ALWAYS_INCLUDE) {
    const value = process.env[key];
    if (value !== undefined && !excludeSet.has(key)) {
      env[key] = value;
    }
  }
  for (const key of allowedSet) {
    if (excludeSet.has(key)) {
      continue;
    }
    const value = process.env[key];
    if (value !== undefined) {
      env[key] = value;
    }
  }
  return env;
}
var ALWAYS_INCLUDE, ALWAYS_EXCLUDE;
var init_sandbox = __esm(() => {
  ALWAYS_INCLUDE = ["PATH", "HOME", "TERM", "SHELL", "USER", "LANG"];
  ALWAYS_EXCLUDE = [
    "GITHUB_TOKEN",
    "GH_TOKEN",
    "GITHUB_PERSONAL_ACCESS_TOKEN",
    "GIT_ASKPASS",
    "KARIMO_DASHBOARD_API_KEY",
    "KARIMO_DASHBOARD_SECRET",
    "KARIMO_WEBHOOK_SECRET",
    "DB_SERVICE_KEY",
    "DATABASE_URL",
    "DB_PASSWORD",
    "POSTGRES_PASSWORD",
    "MYSQL_PASSWORD",
    "MONGODB_URI",
    "AWS_SECRET_ACCESS_KEY",
    "AWS_SESSION_TOKEN",
    "GOOGLE_APPLICATION_CREDENTIALS",
    "AZURE_CLIENT_SECRET",
    "API_KEY",
    "API_SECRET",
    "SECRET_KEY",
    "PRIVATE_KEY",
    "SIGNING_KEY",
    "ENCRYPTION_KEY",
    "AUTH_TOKEN",
    "ACCESS_TOKEN",
    "REFRESH_TOKEN",
    "JWT_SECRET",
    "SESSION_SECRET",
    "STRIPE_SECRET_KEY",
    "OPENAI_API_KEY",
    "ANTHROPIC_API_KEY",
    "SENDGRID_API_KEY",
    "TWILIO_AUTH_TOKEN"
  ];
});

// src/agents/claude-code.ts
class ClaudeCodeEngine {
  name = "claude-code";
  async isAvailable() {
    try {
      const proc = Bun.spawn(["claude", "--version"], {
        stdout: "pipe",
        stderr: "pipe"
      });
      const exitCode = await proc.exited;
      return exitCode === 0;
    } catch {
      return false;
    }
  }
  async execute(options) {
    const { prompt, workdir, env, timeoutMs, jsonSchema, enableThinking } = options;
    if (!await this.isAvailable()) {
      throw new AgentNotFoundError("claude-code");
    }
    const startTime = Date.now();
    try {
      const args = ["claude", "--print"];
      if (jsonSchema) {
        args.push("--output-format", "json");
      }
      let finalPrompt = prompt;
      if (enableThinking) {
        finalPrompt = this.enhancePromptForThinking(prompt);
      }
      args.push(finalPrompt);
      const proc = Bun.spawn(args, {
        cwd: workdir,
        env: {
          ...env,
          CI: "true",
          TERM: "dumb"
        },
        stdout: "pipe",
        stderr: "pipe"
      });
      if (timeoutMs !== undefined && timeoutMs > 0) {
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => {
            proc.kill();
            reject(new AgentTimeoutError("claude-code", timeoutMs));
          }, timeoutMs);
        });
        const exitPromise = proc.exited;
        try {
          await Promise.race([exitPromise, timeoutPromise]);
        } catch (error) {
          if (error instanceof AgentTimeoutError) {
            throw error;
          }
          throw new AgentSpawnError("claude-code", String(error));
        }
      }
      const exitCode = await proc.exited;
      const stdout = await new Response(proc.stdout).text();
      const stderr = await new Response(proc.stderr).text();
      const durationMs = Date.now() - startTime;
      return {
        success: exitCode === 0,
        exitCode,
        stdout,
        stderr,
        durationMs
      };
    } catch (error) {
      if (error instanceof AgentTimeoutError || error instanceof AgentNotFoundError) {
        throw error;
      }
      const message = error instanceof Error ? error.message : String(error);
      throw new AgentSpawnError("claude-code", message);
    }
  }
  enhancePromptForThinking(prompt) {
    const thinkingPrefix = `## Reasoning Mode

Before implementing, take time to carefully analyze:
1. What are the key requirements and constraints?
2. What are the potential edge cases?
3. What is the best approach and why?
4. What could go wrong and how to prevent it?

Think through each step methodically before writing code.

---

`;
    return thinkingPrefix + prompt;
  }
}
function createClaudeCodeEngine() {
  return new ClaudeCodeEngine;
}
var init_claude_code = __esm(() => {
  init_errors3();
});

// src/agents/index.ts
var init_agents = __esm(() => {
  init_errors3();
  init_sandbox();
  init_claude_code();
});

// node_modules/zod/v3/helpers/util.js
var util, objectUtil, ZodParsedType, getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var init_util = __esm(() => {
  (function(util2) {
    util2.assertEqual = (_) => {};
    function assertIs(_arg) {}
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error;
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
      };
    };
  })(objectUtil || (objectUtil = {}));
  ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
});

// node_modules/zod/v3/ZodError.js
var ZodIssueCode, quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, ZodError;
var init_ZodError = __esm(() => {
  init_util();
  ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  ZodError = class ZodError extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          const firstEl = sub.path[0];
          fieldErrors[firstEl] = fieldErrors[firstEl] || [];
          fieldErrors[firstEl].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
});

// node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
}, en_default;
var init_en = __esm(() => {
  init_ZodError();
  init_util();
  en_default = errorMap;
});

// node_modules/zod/v3/errors.js
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var overrideErrorMap;
var init_errors4 = __esm(() => {
  init_en();
  overrideErrorMap = en_default;
});

// node_modules/zod/v3/helpers/parseUtil.js
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === en_default ? undefined : en_default
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
}, EMPTY_PATH, INVALID, DIRTY = (value) => ({ status: "dirty", value }), OK = (value) => ({ status: "valid", value }), isAborted = (x) => x.status === "aborted", isDirty = (x) => x.status === "dirty", isValid = (x) => x.status === "valid", isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var init_parseUtil = __esm(() => {
  init_errors4();
  init_en();
  EMPTY_PATH = [];
  INVALID = Object.freeze({
    status: "aborted"
  });
});

// node_modules/zod/v3/helpers/typeAliases.js
var init_typeAliases = () => {};

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
var init_errorUtil = __esm(() => {
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
  })(errorUtil || (errorUtil = {}));
});

// node_modules/zod/v3/types.js
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
}, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring = () => stringType().optional(), onumber = () => numberType().optional(), oboolean = () => booleanType().optional(), coerce, NEVER;
var init_types = __esm(() => {
  init_ZodError();
  init_errors4();
  init_errorUtil();
  init_parseUtil();
  init_util();
  cuidRegex = /^c[^\s-]{8,}$/i;
  cuid2Regex = /^[0-9a-z]+$/;
  ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  nanoidRegex = /^[a-z0-9_-]{21}$/i;
  jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  dateRegex = new RegExp(`^${dateRegexSource}$`);
  ZodString = class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "jwt",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cidr",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        offset: options?.offset ?? false,
        local: options?.local ?? false,
        ...errorUtil.errToObj(options?.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        ...errorUtil.errToObj(options?.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options?.position,
        ...errorUtil.errToObj(options?.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString.create = (params) => {
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  ZodNumber = class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = undefined;
      const status = new ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null;
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  ZodBigInt = class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = undefined;
      const status = new ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt.create = (params) => {
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  ZodBoolean = class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  ZodDate = class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (Number.isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: params?.coerce || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  ZodSymbol = class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  ZodUndefined = class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  ZodNull = class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  ZodAny = class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  ZodUnknown = class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  ZodNever = class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  ZodVoid = class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  ZodArray = class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : undefined,
            maximum: tooBig ? def.exactLength.value : undefined,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  ZodObject = class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      this._cached = { shape, keys };
      return this._cached;
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") {} else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== undefined ? {
          errorMap: (issue, ctx) => {
            const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: errorUtil.errToObj(message).message ?? defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    catchall(index) {
      return new ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      for (const key of util.objectKeys(mask)) {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodUnion = class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = undefined;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  ZodDiscriminatedUnion = class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(discriminator, options, params) {
      const optionsMap = new Map;
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  };
  ZodIntersection = class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  ZodTuple = class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  ZodRecord = class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  };
  ZodMap = class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = new Map;
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = new Map;
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  ZodSet = class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = new Set;
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  ZodFunction = class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  };
  ZodLazy = class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  ZodLiteral = class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  ZodEnum = class ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(this._def.values);
      }
      if (!this._cache.has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  };
  ZodEnum.create = createZodEnum;
  ZodNativeEnum = class ZodNativeEnum extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(util.getValidEnumValues(this._def.values));
      }
      if (!this._cache.has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  ZodPromise = class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  ZodEffects = class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return INVALID;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return INVALID;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
              status: status.value,
              value: result
            }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  ZodOptional = class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(undefined);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  ZodNullable = class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  ZodDefault = class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  ZodCatch = class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  ZodNaN = class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  BRAND = Symbol("zod_brand");
  ZodBranded = class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  ZodPipeline = class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  };
  ZodReadonly = class ZodReadonly extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  late = {
    object: ZodObject.lazycreate
  };
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  stringType = ZodString.create;
  numberType = ZodNumber.create;
  nanType = ZodNaN.create;
  bigIntType = ZodBigInt.create;
  booleanType = ZodBoolean.create;
  dateType = ZodDate.create;
  symbolType = ZodSymbol.create;
  undefinedType = ZodUndefined.create;
  nullType = ZodNull.create;
  anyType = ZodAny.create;
  unknownType = ZodUnknown.create;
  neverType = ZodNever.create;
  voidType = ZodVoid.create;
  arrayType = ZodArray.create;
  objectType = ZodObject.create;
  strictObjectType = ZodObject.strictCreate;
  unionType = ZodUnion.create;
  discriminatedUnionType = ZodDiscriminatedUnion.create;
  intersectionType = ZodIntersection.create;
  tupleType = ZodTuple.create;
  recordType = ZodRecord.create;
  mapType = ZodMap.create;
  setType = ZodSet.create;
  functionType = ZodFunction.create;
  lazyType = ZodLazy.create;
  literalType = ZodLiteral.create;
  enumType = ZodEnum.create;
  nativeEnumType = ZodNativeEnum.create;
  promiseType = ZodPromise.create;
  effectsType = ZodEffects.create;
  optionalType = ZodOptional.create;
  nullableType = ZodNullable.create;
  preprocessType = ZodEffects.createWithPreprocess;
  pipelineType = ZodPipeline.create;
  coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  NEVER = INVALID;
});

// node_modules/zod/v3/external.js
var exports_external = {};
__export(exports_external, {
  void: () => voidType,
  util: () => util,
  unknown: () => unknownType,
  union: () => unionType,
  undefined: () => undefinedType,
  tuple: () => tupleType,
  transformer: () => effectsType,
  symbol: () => symbolType,
  string: () => stringType,
  strictObject: () => strictObjectType,
  setErrorMap: () => setErrorMap,
  set: () => setType,
  record: () => recordType,
  quotelessJson: () => quotelessJson,
  promise: () => promiseType,
  preprocess: () => preprocessType,
  pipeline: () => pipelineType,
  ostring: () => ostring,
  optional: () => optionalType,
  onumber: () => onumber,
  oboolean: () => oboolean,
  objectUtil: () => objectUtil,
  object: () => objectType,
  number: () => numberType,
  nullable: () => nullableType,
  null: () => nullType,
  never: () => neverType,
  nativeEnum: () => nativeEnumType,
  nan: () => nanType,
  map: () => mapType,
  makeIssue: () => makeIssue,
  literal: () => literalType,
  lazy: () => lazyType,
  late: () => late,
  isValid: () => isValid,
  isDirty: () => isDirty,
  isAsync: () => isAsync,
  isAborted: () => isAborted,
  intersection: () => intersectionType,
  instanceof: () => instanceOfType,
  getParsedType: () => getParsedType,
  getErrorMap: () => getErrorMap,
  function: () => functionType,
  enum: () => enumType,
  effect: () => effectsType,
  discriminatedUnion: () => discriminatedUnionType,
  defaultErrorMap: () => en_default,
  datetimeRegex: () => datetimeRegex,
  date: () => dateType,
  custom: () => custom,
  coerce: () => coerce,
  boolean: () => booleanType,
  bigint: () => bigIntType,
  array: () => arrayType,
  any: () => anyType,
  addIssueToContext: () => addIssueToContext,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransformer: () => ZodEffects,
  ZodSymbol: () => ZodSymbol,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodSchema: () => ZodType,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPipeline: () => ZodPipeline,
  ZodParsedType: () => ZodParsedType,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNever: () => ZodNever,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEffects: () => ZodEffects,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCatch: () => ZodCatch,
  ZodBranded: () => ZodBranded,
  ZodBoolean: () => ZodBoolean,
  ZodBigInt: () => ZodBigInt,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  Schema: () => ZodType,
  ParseStatus: () => ParseStatus,
  OK: () => OK,
  NEVER: () => NEVER,
  INVALID: () => INVALID,
  EMPTY_PATH: () => EMPTY_PATH,
  DIRTY: () => DIRTY,
  BRAND: () => BRAND
});
var init_external = __esm(() => {
  init_errors4();
  init_parseUtil();
  init_typeAliases();
  init_util();
  init_types();
  init_ZodError();
});

// node_modules/zod/index.js
var init_zod = __esm(() => {
  init_external();
  init_external();
});

// src/config/schema.ts
var ProjectSchema, CommandsSchema, RulesSchema, BoundariesSchema, ModelPreferenceSchema, CostSchema, FallbackTriggerSchema, FallbackEngineItemSchema, FallbackEngineSchema, SandboxSchema, KarimoConfigSchema;
var init_schema = __esm(() => {
  init_zod();
  ProjectSchema = exports_external.object({
    name: exports_external.string().min(1, "Project name is required"),
    language: exports_external.string().min(1, "Language is required").default("typescript"),
    framework: exports_external.string().optional(),
    runtime: exports_external.string().min(1, "Runtime is required").default("bun"),
    database: exports_external.string().optional()
  });
  CommandsSchema = exports_external.object({
    build: exports_external.string().min(1, "Build command is required"),
    lint: exports_external.string().min(1, "Lint command is required"),
    test: exports_external.string().min(1, "Test command cannot be empty (use null to skip)").nullable().default(null),
    typecheck: exports_external.string().min(1, "Typecheck command cannot be empty (use null to skip)").nullable().default(null)
  });
  RulesSchema = exports_external.array(exports_external.string().min(1, "Rule cannot be empty")).min(1, "At least one rule is required");
  BoundariesSchema = exports_external.object({
    never_touch: exports_external.array(exports_external.string()).default([]),
    require_review: exports_external.array(exports_external.string()).default([])
  });
  ModelPreferenceSchema = exports_external.enum(["haiku", "sonnet", "opus"]).default("sonnet");
  CostSchema = exports_external.object({
    model_preference: ModelPreferenceSchema,
    cost_multiplier: exports_external.number().min(0.5).default(3),
    base_iterations: exports_external.number().int().min(1).default(5),
    iteration_multiplier: exports_external.number().min(0.5).default(3),
    revision_budget_percent: exports_external.number().min(0).max(100).default(50),
    max_revision_loops: exports_external.number().int().min(0).default(3),
    abort_on_fatal: exports_external.boolean().default(true),
    fallback_cost_per_minute: exports_external.number().min(0).default(0.5),
    phase_budget_cap: exports_external.number().positive().nullable().default(null),
    phase_budget_overflow: exports_external.number().min(0).max(1).default(0.1),
    session_budget_cap: exports_external.number().positive().nullable().default(null),
    budget_warning_threshold: exports_external.number().min(0).max(1).default(0.75)
  });
  FallbackTriggerSchema = exports_external.enum([
    "rate-limit",
    "quota-exceeded",
    "auth-failure",
    "timeout"
  ]);
  FallbackEngineItemSchema = exports_external.object({
    name: exports_external.string().min(1, "Engine name is required"),
    command: exports_external.string().min(1, "Engine command is required"),
    budget_cap: exports_external.number().positive(),
    priority: exports_external.number().int().min(1)
  });
  FallbackEngineSchema = exports_external.object({
    enabled: exports_external.boolean().default(false),
    engines: exports_external.array(FallbackEngineItemSchema).default([]),
    trigger_on: exports_external.array(FallbackTriggerSchema).default(["rate-limit", "quota-exceeded"])
  });
  SandboxSchema = exports_external.object({
    allowed_env: exports_external.array(exports_external.string()).min(1, "At least one allowed env variable is required")
  });
  KarimoConfigSchema = exports_external.object({
    project: ProjectSchema,
    commands: CommandsSchema,
    rules: RulesSchema,
    boundaries: BoundariesSchema.default({ never_touch: [], require_review: [] }),
    cost: CostSchema.default({
      model_preference: "sonnet",
      cost_multiplier: 3,
      base_iterations: 5,
      iteration_multiplier: 3,
      revision_budget_percent: 50,
      max_revision_loops: 3,
      abort_on_fatal: true,
      fallback_cost_per_minute: 0.5,
      phase_budget_cap: null,
      phase_budget_overflow: 0.1,
      session_budget_cap: null,
      budget_warning_threshold: 0.75
    }),
    fallback_engine: FallbackEngineSchema.default({
      enabled: false,
      engines: [],
      trigger_on: ["rate-limit", "quota-exceeded"]
    }),
    sandbox: SandboxSchema
  });
});

// node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS((exports) => {
  var ALIAS = Symbol.for("yaml.alias");
  var DOC = Symbol.for("yaml.document");
  var MAP = Symbol.for("yaml.map");
  var PAIR = Symbol.for("yaml.pair");
  var SCALAR = Symbol.for("yaml.scalar");
  var SEQ = Symbol.for("yaml.seq");
  var NODE_TYPE = Symbol.for("yaml.node.type");
  var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
  var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
  var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
  var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
  var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
  var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
  function isCollection(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case MAP:
        case SEQ:
          return true;
      }
    return false;
  }
  function isNode(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case ALIAS:
        case MAP:
        case SCALAR:
        case SEQ:
          return true;
      }
    return false;
  }
  var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
  exports.ALIAS = ALIAS;
  exports.DOC = DOC;
  exports.MAP = MAP;
  exports.NODE_TYPE = NODE_TYPE;
  exports.PAIR = PAIR;
  exports.SCALAR = SCALAR;
  exports.SEQ = SEQ;
  exports.hasAnchor = hasAnchor;
  exports.isAlias = isAlias;
  exports.isCollection = isCollection;
  exports.isDocument = isDocument;
  exports.isMap = isMap;
  exports.isNode = isNode;
  exports.isPair = isPair;
  exports.isScalar = isScalar;
  exports.isSeq = isSeq;
});

// node_modules/yaml/dist/visit.js
var require_visit = __commonJS((exports) => {
  var identity = require_identity();
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove node");
  function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
      const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      visit_(null, node, visitor_, Object.freeze([]));
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = visit_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = visit_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = visit_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
      const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      await visitAsync_(null, node, visitor_, Object.freeze([]));
  }
  visitAsync.BREAK = BREAK;
  visitAsync.SKIP = SKIP;
  visitAsync.REMOVE = REMOVE;
  async function visitAsync_(key, node, visitor, path) {
    const ctrl = await callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = await visitAsync_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = await visitAsync_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = await visitAsync_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  function initVisitor(visitor) {
    if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
      return Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
      }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
      }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
      }, visitor);
    }
    return visitor;
  }
  function callVisitor(key, node, visitor, path) {
    if (typeof visitor === "function")
      return visitor(key, node, path);
    if (identity.isMap(node))
      return visitor.Map?.(key, node, path);
    if (identity.isSeq(node))
      return visitor.Seq?.(key, node, path);
    if (identity.isPair(node))
      return visitor.Pair?.(key, node, path);
    if (identity.isScalar(node))
      return visitor.Scalar?.(key, node, path);
    if (identity.isAlias(node))
      return visitor.Alias?.(key, node, path);
    return;
  }
  function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (identity.isCollection(parent)) {
      parent.items[key] = node;
    } else if (identity.isPair(parent)) {
      if (key === "key")
        parent.key = node;
      else
        parent.value = node;
    } else if (identity.isDocument(parent)) {
      parent.contents = node;
    } else {
      const pt = identity.isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
  }
  exports.visit = visit;
  exports.visitAsync = visitAsync;
});

// node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS((exports) => {
  var identity = require_identity();
  var visit = require_visit();
  var escapeChars = {
    "!": "%21",
    ",": "%2C",
    "[": "%5B",
    "]": "%5D",
    "{": "%7B",
    "}": "%7D"
  };
  var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);

  class Directives {
    constructor(yaml, tags) {
      this.docStart = null;
      this.docEnd = false;
      this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
      this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
      const copy = new Directives(this.yaml, this.tags);
      copy.docStart = this.docStart;
      return copy;
    }
    atDocument() {
      const res = new Directives(this.yaml, this.tags);
      switch (this.yaml.version) {
        case "1.1":
          this.atNextDocument = true;
          break;
        case "1.2":
          this.atNextDocument = false;
          this.yaml = {
            explicit: Directives.defaultYaml.explicit,
            version: "1.2"
          };
          this.tags = Object.assign({}, Directives.defaultTags);
          break;
      }
      return res;
    }
    add(line, onError) {
      if (this.atNextDocument) {
        this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
        this.tags = Object.assign({}, Directives.defaultTags);
        this.atNextDocument = false;
      }
      const parts = line.trim().split(/[ \t]+/);
      const name = parts.shift();
      switch (name) {
        case "%TAG": {
          if (parts.length !== 2) {
            onError(0, "%TAG directive should contain exactly two parts");
            if (parts.length < 2)
              return false;
          }
          const [handle, prefix] = parts;
          this.tags[handle] = prefix;
          return true;
        }
        case "%YAML": {
          this.yaml.explicit = true;
          if (parts.length !== 1) {
            onError(0, "%YAML directive should contain exactly one part");
            return false;
          }
          const [version] = parts;
          if (version === "1.1" || version === "1.2") {
            this.yaml.version = version;
            return true;
          } else {
            const isValid2 = /^\d+\.\d+$/.test(version);
            onError(6, `Unsupported YAML version ${version}`, isValid2);
            return false;
          }
        }
        default:
          onError(0, `Unknown directive ${name}`, true);
          return false;
      }
    }
    tagName(source, onError) {
      if (source === "!")
        return "!";
      if (source[0] !== "!") {
        onError(`Not a valid tag: ${source}`);
        return null;
      }
      if (source[1] === "<") {
        const verbatim = source.slice(2, -1);
        if (verbatim === "!" || verbatim === "!!") {
          onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
          return null;
        }
        if (source[source.length - 1] !== ">")
          onError("Verbatim tags must end with a >");
        return verbatim;
      }
      const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
      if (!suffix)
        onError(`The ${source} tag has no suffix`);
      const prefix = this.tags[handle];
      if (prefix) {
        try {
          return prefix + decodeURIComponent(suffix);
        } catch (error) {
          onError(String(error));
          return null;
        }
      }
      if (handle === "!")
        return source;
      onError(`Could not resolve tag: ${source}`);
      return null;
    }
    tagString(tag) {
      for (const [handle, prefix] of Object.entries(this.tags)) {
        if (tag.startsWith(prefix))
          return handle + escapeTagName(tag.substring(prefix.length));
      }
      return tag[0] === "!" ? tag : `!<${tag}>`;
    }
    toString(doc) {
      const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
      const tagEntries = Object.entries(this.tags);
      let tagNames;
      if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
        const tags = {};
        visit.visit(doc.contents, (_key, node) => {
          if (identity.isNode(node) && node.tag)
            tags[node.tag] = true;
        });
        tagNames = Object.keys(tags);
      } else
        tagNames = [];
      for (const [handle, prefix] of tagEntries) {
        if (handle === "!!" && prefix === "tag:yaml.org,2002:")
          continue;
        if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
          lines.push(`%TAG ${handle} ${prefix}`);
      }
      return lines.join(`
`);
    }
  }
  Directives.defaultYaml = { explicit: false, version: "1.2" };
  Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
  exports.Directives = Directives;
});

// node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS((exports) => {
  var identity = require_identity();
  var visit = require_visit();
  function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
      const sa = JSON.stringify(anchor);
      const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
      throw new Error(msg);
    }
    return true;
  }
  function anchorNames(root) {
    const anchors = new Set;
    visit.visit(root, {
      Value(_key, node) {
        if (node.anchor)
          anchors.add(node.anchor);
      }
    });
    return anchors;
  }
  function findNewAnchor(prefix, exclude) {
    for (let i = 1;; ++i) {
      const name = `${prefix}${i}`;
      if (!exclude.has(name))
        return name;
    }
  }
  function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map;
    let prevAnchors = null;
    return {
      onAnchor: (source) => {
        aliasObjects.push(source);
        prevAnchors ?? (prevAnchors = anchorNames(doc));
        const anchor = findNewAnchor(prefix, prevAnchors);
        prevAnchors.add(anchor);
        return anchor;
      },
      setAnchors: () => {
        for (const source of aliasObjects) {
          const ref = sourceObjects.get(source);
          if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
            ref.node.anchor = ref.anchor;
          } else {
            const error = new Error("Failed to resolve repeated object (this should not happen)");
            error.source = source;
            throw error;
          }
        }
      },
      sourceObjects
    };
  }
  exports.anchorIsValid = anchorIsValid;
  exports.anchorNames = anchorNames;
  exports.createNodeAnchors = createNodeAnchors;
  exports.findNewAnchor = findNewAnchor;
});

// node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS((exports) => {
  function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === "object") {
      if (Array.isArray(val)) {
        for (let i = 0, len = val.length;i < len; ++i) {
          const v0 = val[i];
          const v1 = applyReviver(reviver, val, String(i), v0);
          if (v1 === undefined)
            delete val[i];
          else if (v1 !== v0)
            val[i] = v1;
        }
      } else if (val instanceof Map) {
        for (const k of Array.from(val.keys())) {
          const v0 = val.get(k);
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            val.delete(k);
          else if (v1 !== v0)
            val.set(k, v1);
        }
      } else if (val instanceof Set) {
        for (const v0 of Array.from(val)) {
          const v1 = applyReviver(reviver, val, v0, v0);
          if (v1 === undefined)
            val.delete(v0);
          else if (v1 !== v0) {
            val.delete(v0);
            val.add(v1);
          }
        }
      } else {
        for (const [k, v0] of Object.entries(val)) {
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            delete val[k];
          else if (v1 !== v0)
            val[k] = v1;
        }
      }
    }
    return reviver.call(obj, key, val);
  }
  exports.applyReviver = applyReviver;
});

// node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS((exports) => {
  var identity = require_identity();
  function toJS(value, arg, ctx) {
    if (Array.isArray(value))
      return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === "function") {
      if (!ctx || !identity.hasAnchor(value))
        return value.toJSON(arg, ctx);
      const data = { aliasCount: 0, count: 1, res: undefined };
      ctx.anchors.set(value, data);
      ctx.onCreate = (res2) => {
        data.res = res2;
        delete ctx.onCreate;
      };
      const res = value.toJSON(arg, ctx);
      if (ctx.onCreate)
        ctx.onCreate(res);
      return res;
    }
    if (typeof value === "bigint" && !ctx?.keep)
      return Number(value);
    return value;
  }
  exports.toJS = toJS;
});

// node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS((exports) => {
  var applyReviver = require_applyReviver();
  var identity = require_identity();
  var toJS = require_toJS();

  class NodeBase {
    constructor(type) {
      Object.defineProperty(this, identity.NODE_TYPE, { value: type });
    }
    clone() {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      if (!identity.isDocument(doc))
        throw new TypeError("A document argument is required");
      const ctx = {
        anchors: new Map,
        doc,
        keep: true,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this, "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
  }
  exports.NodeBase = NodeBase;
});

// node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS((exports) => {
  var anchors = require_anchors();
  var visit = require_visit();
  var identity = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();

  class Alias extends Node.NodeBase {
    constructor(source) {
      super(identity.ALIAS);
      this.source = source;
      Object.defineProperty(this, "tag", {
        set() {
          throw new Error("Alias nodes cannot have tags");
        }
      });
    }
    resolve(doc, ctx) {
      let nodes;
      if (ctx?.aliasResolveCache) {
        nodes = ctx.aliasResolveCache;
      } else {
        nodes = [];
        visit.visit(doc, {
          Node: (_key, node) => {
            if (identity.isAlias(node) || identity.hasAnchor(node))
              nodes.push(node);
          }
        });
        if (ctx)
          ctx.aliasResolveCache = nodes;
      }
      let found = undefined;
      for (const node of nodes) {
        if (node === this)
          break;
        if (node.anchor === this.source)
          found = node;
      }
      return found;
    }
    toJSON(_arg, ctx) {
      if (!ctx)
        return { source: this.source };
      const { anchors: anchors2, doc, maxAliasCount } = ctx;
      const source = this.resolve(doc, ctx);
      if (!source) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new ReferenceError(msg);
      }
      let data = anchors2.get(source);
      if (!data) {
        toJS.toJS(source, null, ctx);
        data = anchors2.get(source);
      }
      if (data?.res === undefined) {
        const msg = "This should not happen: Alias anchor was not resolved?";
        throw new ReferenceError(msg);
      }
      if (maxAliasCount >= 0) {
        data.count += 1;
        if (data.aliasCount === 0)
          data.aliasCount = getAliasCount(doc, source, anchors2);
        if (data.count * data.aliasCount > maxAliasCount) {
          const msg = "Excessive alias count indicates a resource exhaustion attack";
          throw new ReferenceError(msg);
        }
      }
      return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
      const src = `*${this.source}`;
      if (ctx) {
        anchors.anchorIsValid(this.source);
        if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new Error(msg);
        }
        if (ctx.implicitKey)
          return `${src} `;
      }
      return src;
    }
  }
  function getAliasCount(doc, node, anchors2) {
    if (identity.isAlias(node)) {
      const source = node.resolve(doc);
      const anchor = anchors2 && source && anchors2.get(source);
      return anchor ? anchor.count * anchor.aliasCount : 0;
    } else if (identity.isCollection(node)) {
      let count = 0;
      for (const item of node.items) {
        const c = getAliasCount(doc, item, anchors2);
        if (c > count)
          count = c;
      }
      return count;
    } else if (identity.isPair(node)) {
      const kc = getAliasCount(doc, node.key, anchors2);
      const vc = getAliasCount(doc, node.value, anchors2);
      return Math.max(kc, vc);
    }
    return 1;
  }
  exports.Alias = Alias;
});

// node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS((exports) => {
  var identity = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();
  var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";

  class Scalar extends Node.NodeBase {
    constructor(value) {
      super(identity.SCALAR);
      this.value = value;
    }
    toJSON(arg, ctx) {
      return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
      return String(this.value);
    }
  }
  Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
  Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
  Scalar.PLAIN = "PLAIN";
  Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
  Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
  exports.Scalar = Scalar;
  exports.isScalarValue = isScalarValue;
});

// node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity = require_identity();
  var Scalar = require_Scalar();
  var defaultTagPrefix = "tag:yaml.org,2002:";
  function findTagObject(value, tagName, tags) {
    if (tagName) {
      const match = tags.filter((t) => t.tag === tagName);
      const tagObj = match.find((t) => !t.format) ?? match[0];
      if (!tagObj)
        throw new Error(`Tag ${tagName} not found`);
      return tagObj;
    }
    return tags.find((t) => t.identify?.(value) && !t.format);
  }
  function createNode(value, tagName, ctx) {
    if (identity.isDocument(value))
      value = value.contents;
    if (identity.isNode(value))
      return value;
    if (identity.isPair(value)) {
      const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
      map.items.push(value);
      return map;
    }
    if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
      value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === "object") {
      ref = sourceObjects.get(value);
      if (ref) {
        ref.anchor ?? (ref.anchor = onAnchor(value));
        return new Alias.Alias(ref.anchor);
      } else {
        ref = { anchor: null, node: null };
        sourceObjects.set(value, ref);
      }
    }
    if (tagName?.startsWith("!!"))
      tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
      if (value && typeof value.toJSON === "function") {
        value = value.toJSON();
      }
      if (!value || typeof value !== "object") {
        const node2 = new Scalar.Scalar(value);
        if (ref)
          ref.node = node2;
        return node2;
      }
      tagObj = value instanceof Map ? schema[identity.MAP] : (Symbol.iterator in Object(value)) ? schema[identity.SEQ] : schema[identity.MAP];
    }
    if (onTagObj) {
      onTagObj(tagObj);
      delete ctx.onTagObj;
    }
    const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
    if (tagName)
      node.tag = tagName;
    else if (!tagObj.default)
      node.tag = tagObj.tag;
    if (ref)
      ref.node = node;
    return node;
  }
  exports.createNode = createNode;
});

// node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS((exports) => {
  var createNode = require_createNode();
  var identity = require_identity();
  var Node = require_Node();
  function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1;i >= 0; --i) {
      const k = path[i];
      if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
        const a = [];
        a[k] = v;
        v = a;
      } else {
        v = new Map([[k, v]]);
      }
    }
    return createNode.createNode(v, undefined, {
      aliasDuplicateObjects: false,
      keepUndefined: false,
      onAnchor: () => {
        throw new Error("This should not happen, please report a bug.");
      },
      schema,
      sourceObjects: new Map
    });
  }
  var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;

  class Collection extends Node.NodeBase {
    constructor(type, schema) {
      super(type);
      Object.defineProperty(this, "schema", {
        value: schema,
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
    clone(schema) {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (schema)
        copy.schema = schema;
      copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    addIn(path, value) {
      if (isEmptyPath(path))
        this.add(value);
      else {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (identity.isCollection(node))
          node.addIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
    deleteIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.delete(key);
      const node = this.get(key, true);
      if (identity.isCollection(node))
        return node.deleteIn(rest);
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    getIn(path, keepScalar) {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (rest.length === 0)
        return !keepScalar && identity.isScalar(node) ? node.value : node;
      else
        return identity.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
      return this.items.every((node) => {
        if (!identity.isPair(node))
          return false;
        const n = node.value;
        return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
      });
    }
    hasIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.has(key);
      const node = this.get(key, true);
      return identity.isCollection(node) ? node.hasIn(rest) : false;
    }
    setIn(path, value) {
      const [key, ...rest] = path;
      if (rest.length === 0) {
        this.set(key, value);
      } else {
        const node = this.get(key, true);
        if (identity.isCollection(node))
          node.setIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
  }
  exports.Collection = Collection;
  exports.collectionFromPath = collectionFromPath;
  exports.isEmptyPath = isEmptyPath;
});

// node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS((exports) => {
  var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
  function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
      return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
  }
  var lineComment = (str, indent, comment) => str.endsWith(`
`) ? indentComment(comment, indent) : comment.includes(`
`) ? `
` + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
  exports.indentComment = indentComment;
  exports.lineComment = lineComment;
  exports.stringifyComment = stringifyComment;
});

// node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS((exports) => {
  var FOLD_FLOW = "flow";
  var FOLD_BLOCK = "block";
  var FOLD_QUOTED = "quoted";
  function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
      return text;
    if (lineWidth < minContentWidth)
      minContentWidth = 0;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
      return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === "number") {
      if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
        folds.push(0);
      else
        end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
      i = consumeMoreIndentedLines(text, i, indent.length);
      if (i !== -1)
        end = i + endStep;
    }
    for (let ch;ch = text[i += 1]; ) {
      if (mode === FOLD_QUOTED && ch === "\\") {
        escStart = i;
        switch (text[i + 1]) {
          case "x":
            i += 3;
            break;
          case "u":
            i += 5;
            break;
          case "U":
            i += 9;
            break;
          default:
            i += 1;
        }
        escEnd = i;
      }
      if (ch === `
`) {
        if (mode === FOLD_BLOCK)
          i = consumeMoreIndentedLines(text, i, indent.length);
        end = i + indent.length + endStep;
        split = undefined;
      } else {
        if (ch === " " && prev && prev !== " " && prev !== `
` && prev !== "\t") {
          const next = text[i + 1];
          if (next && next !== " " && next !== `
` && next !== "\t")
            split = i;
        }
        if (i >= end) {
          if (split) {
            folds.push(split);
            end = split + endStep;
            split = undefined;
          } else if (mode === FOLD_QUOTED) {
            while (prev === " " || prev === "\t") {
              prev = ch;
              ch = text[i += 1];
              overflow = true;
            }
            const j = i > escEnd + 1 ? i - 2 : escStart - 1;
            if (escapedFolds[j])
              return text;
            folds.push(j);
            escapedFolds[j] = true;
            end = j + endStep;
            split = undefined;
          } else {
            overflow = true;
          }
        }
      }
      prev = ch;
    }
    if (overflow && onOverflow)
      onOverflow();
    if (folds.length === 0)
      return text;
    if (onFold)
      onFold();
    let res = text.slice(0, folds[0]);
    for (let i2 = 0;i2 < folds.length; ++i2) {
      const fold = folds[i2];
      const end2 = folds[i2 + 1] || text.length;
      if (fold === 0)
        res = `
${indent}${text.slice(0, end2)}`;
      else {
        if (mode === FOLD_QUOTED && escapedFolds[fold])
          res += `${text[fold]}\\`;
        res += `
${indent}${text.slice(fold + 1, end2)}`;
      }
    }
    return res;
  }
  function consumeMoreIndentedLines(text, i, indent) {
    let end = i;
    let start = i + 1;
    let ch = text[start];
    while (ch === " " || ch === "\t") {
      if (i < start + indent) {
        ch = text[++i];
      } else {
        do {
          ch = text[++i];
        } while (ch && ch !== `
`);
        end = i;
        start = i + 1;
        ch = text[start];
      }
    }
    return end;
  }
  exports.FOLD_BLOCK = FOLD_BLOCK;
  exports.FOLD_FLOW = FOLD_FLOW;
  exports.FOLD_QUOTED = FOLD_QUOTED;
  exports.foldFlowLines = foldFlowLines;
});

// node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var foldFlowLines = require_foldFlowLines();
  var getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
  });
  var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
  function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
      return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
      return false;
    for (let i = 0, start = 0;i < strLen; ++i) {
      if (str[i] === `
`) {
        if (i - start > limit)
          return true;
        start = i + 1;
        if (strLen - start <= limit)
          return false;
      }
    }
    return true;
  }
  function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
      return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    let str = "";
    let start = 0;
    for (let i = 0, ch = json[i];ch; ch = json[++i]) {
      if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
        str += json.slice(start, i) + "\\ ";
        i += 1;
        start = i;
        ch = "\\";
      }
      if (ch === "\\")
        switch (json[i + 1]) {
          case "u":
            {
              str += json.slice(start, i);
              const code = json.substr(i + 2, 4);
              switch (code) {
                case "0000":
                  str += "\\0";
                  break;
                case "0007":
                  str += "\\a";
                  break;
                case "000b":
                  str += "\\v";
                  break;
                case "001b":
                  str += "\\e";
                  break;
                case "0085":
                  str += "\\N";
                  break;
                case "00a0":
                  str += "\\_";
                  break;
                case "2028":
                  str += "\\L";
                  break;
                case "2029":
                  str += "\\P";
                  break;
                default:
                  if (code.substr(0, 2) === "00")
                    str += "\\x" + code.substr(2);
                  else
                    str += json.substr(i, 6);
              }
              i += 5;
              start = i + 1;
            }
            break;
          case "n":
            if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
              i += 1;
            } else {
              str += json.slice(start, i) + `

`;
              while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                str += `
`;
                i += 2;
              }
              str += indent;
              if (json[i + 2] === " ")
                str += "\\";
              i += 1;
              start = i + 1;
            }
            break;
          default:
            i += 1;
        }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
  }
  function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes(`
`) || /[ \t]\n|\n[ \t]/.test(value))
      return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
    return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
      qs = doubleQuotedString;
    else {
      const hasDouble = value.includes('"');
      const hasSingle = value.includes("'");
      if (hasDouble && !hasSingle)
        qs = singleQuotedString;
      else if (hasSingle && !hasDouble)
        qs = doubleQuotedString;
      else
        qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
  }
  var blockEndNewlines;
  try {
    blockEndNewlines = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
  } catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
  }
  function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    if (!blockQuote || /\n[\t ]+$/.test(value)) {
      return quotedString(value, ctx);
    }
    const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
    const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
      return literal ? `|
` : `>
`;
    let chomp;
    let endStart;
    for (endStart = value.length;endStart > 0; --endStart) {
      const ch = value[endStart - 1];
      if (ch !== `
` && ch !== "\t" && ch !== " ")
        break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf(`
`);
    if (endNlPos === -1) {
      chomp = "-";
    } else if (value === end || endNlPos !== end.length - 1) {
      chomp = "+";
      if (onChompKeep)
        onChompKeep();
    } else {
      chomp = "";
    }
    if (end) {
      value = value.slice(0, -end.length);
      if (end[end.length - 1] === `
`)
        end = end.slice(0, -1);
      end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0;startEnd < value.length; ++startEnd) {
      const ch = value[startEnd];
      if (ch === " ")
        startWithSpace = true;
      else if (ch === `
`)
        startNlPos = startEnd;
      else
        break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
      value = value.substring(start.length);
      start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? "2" : "1";
    let header = (startWithSpace ? indentSize : "") + chomp;
    if (comment) {
      header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
      if (onComment)
        onComment();
    }
    if (!literal) {
      const foldedValue = value.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      let literalFallback = false;
      const foldOptions = getFoldOptions(ctx, true);
      if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
        foldOptions.onOverflow = () => {
          literalFallback = true;
        };
      }
      const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
      if (!literalFallback)
        return `>${header}
${indent}${body}`;
    }
    value = value.replace(/\n+/g, `$&${indent}`);
    return `|${header}
${indent}${start}${value}${end}`;
  }
  function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if (implicitKey && value.includes(`
`) || inFlow && /[[\]{},]/.test(value)) {
      return quotedString(value, ctx);
    }
    if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
      return implicitKey || inFlow || !value.includes(`
`) ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes(`
`)) {
      return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
      if (indent === "") {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      } else if (implicitKey && indent === indentStep) {
        return quotedString(value, ctx);
      }
    }
    const str = value.replace(/\n+/g, `$&
${indent}`);
    if (actualString) {
      const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
      const { compat, tags } = ctx.doc.schema;
      if (tags.some(test) || compat?.some(test))
        return quotedString(value, ctx);
    }
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
      if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
        type = Scalar.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
      switch (_type) {
        case Scalar.Scalar.BLOCK_FOLDED:
        case Scalar.Scalar.BLOCK_LITERAL:
          return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
        case Scalar.Scalar.QUOTE_DOUBLE:
          return doubleQuotedString(ss.value, ctx);
        case Scalar.Scalar.QUOTE_SINGLE:
          return singleQuotedString(ss.value, ctx);
        case Scalar.Scalar.PLAIN:
          return plainString(ss, ctx, onComment, onChompKeep);
        default:
          return null;
      }
    };
    let res = _stringify(type);
    if (res === null) {
      const { defaultKeyType, defaultStringType } = ctx.options;
      const t = implicitKey && defaultKeyType || defaultStringType;
      res = _stringify(t);
      if (res === null)
        throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
  }
  exports.stringifyString = stringifyString;
});

// node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS((exports) => {
  var anchors = require_anchors();
  var identity = require_identity();
  var stringifyComment = require_stringifyComment();
  var stringifyString = require_stringifyString();
  function createStringifyContext(doc, options) {
    const opt = Object.assign({
      blockQuote: true,
      commentString: stringifyComment.stringifyComment,
      defaultKeyType: null,
      defaultStringType: "PLAIN",
      directives: null,
      doubleQuotedAsJSON: false,
      doubleQuotedMinMultiLineLength: 40,
      falseStr: "false",
      flowCollectionPadding: true,
      indentSeq: true,
      lineWidth: 80,
      minContentWidth: 20,
      nullStr: "null",
      simpleKeys: false,
      singleQuote: null,
      trueStr: "true",
      verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
      case "block":
        inFlow = false;
        break;
      case "flow":
        inFlow = true;
        break;
      default:
        inFlow = null;
    }
    return {
      anchors: new Set,
      doc,
      flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
      indent: "",
      indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
      inFlow,
      options: opt
    };
  }
  function getTagObject(tags, item) {
    if (item.tag) {
      const match = tags.filter((t) => t.tag === item.tag);
      if (match.length > 0)
        return match.find((t) => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (identity.isScalar(item)) {
      obj = item.value;
      let match = tags.filter((t) => t.identify?.(obj));
      if (match.length > 1) {
        const testMatch = match.filter((t) => t.test);
        if (testMatch.length > 0)
          match = testMatch;
      }
      tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
    } else {
      obj = item;
      tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
      const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
      throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
  }
  function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
    if (!doc.directives)
      return "";
    const props = [];
    const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
      anchors$1.add(anchor);
      props.push(`&${anchor}`);
    }
    const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
    if (tag)
      props.push(doc.directives.tagString(tag));
    return props.join(" ");
  }
  function stringify(item, ctx, onComment, onChompKeep) {
    if (identity.isPair(item))
      return item.toString(ctx, onComment, onChompKeep);
    if (identity.isAlias(item)) {
      if (ctx.doc.directives)
        return item.toString(ctx);
      if (ctx.resolvedAliases?.has(item)) {
        throw new TypeError(`Cannot stringify circular structure without alias nodes`);
      } else {
        if (ctx.resolvedAliases)
          ctx.resolvedAliases.add(item);
        else
          ctx.resolvedAliases = new Set([item]);
        item = item.resolve(ctx.doc);
      }
    }
    let tagObj = undefined;
    const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
    tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
      ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
    if (!props)
      return str;
    return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
  }
  exports.createStringifyContext = createStringifyContext;
  exports.stringify = stringify;
});

// node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = identity.isNode(key) && key.comment || null;
    if (simpleKeys) {
      if (keyComment) {
        throw new Error("With simple keys, key nodes cannot have comments");
      }
      if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") {
        const msg = "With simple keys, collection cannot be used as a key value";
        throw new Error(msg);
      }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
    ctx = Object.assign({}, ctx, {
      allNullValues: false,
      implicitKey: !explicitKey && (simpleKeys || !allNullValues),
      indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
      if (simpleKeys)
        throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
      explicitKey = true;
    }
    if (ctx.inFlow) {
      if (allNullValues || value == null) {
        if (keyCommentDone && onComment)
          onComment();
        return str === "" ? "?" : explicitKey ? `? ${str}` : str;
      }
    } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
      str = `? ${str}`;
      if (keyComment && !keyCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    if (keyCommentDone)
      keyComment = null;
    if (explicitKey) {
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      str = `? ${str}
${indent}:`;
    } else {
      str = `${str}:`;
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (identity.isNode(value)) {
      vsb = !!value.spaceBefore;
      vcb = value.commentBefore;
      valueComment = value.comment;
    } else {
      vsb = false;
      vcb = null;
      valueComment = null;
      if (value && typeof value === "object")
        value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && identity.isScalar(value))
      ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
      ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
    let ws = " ";
    if (keyComment || vsb || vcb) {
      ws = vsb ? `
` : "";
      if (vcb) {
        const cs = commentString(vcb);
        ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
      }
      if (valueStr === "" && !ctx.inFlow) {
        if (ws === `
` && valueComment)
          ws = `

`;
      } else {
        ws += `
${ctx.indent}`;
      }
    } else if (!explicitKey && identity.isCollection(value)) {
      const vs0 = valueStr[0];
      const nl0 = valueStr.indexOf(`
`);
      const hasNewline = nl0 !== -1;
      const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
      if (hasNewline || !flow) {
        let hasPropsLine = false;
        if (hasNewline && (vs0 === "&" || vs0 === "!")) {
          let sp0 = valueStr.indexOf(" ");
          if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
            sp0 = valueStr.indexOf(" ", sp0 + 1);
          }
          if (sp0 === -1 || nl0 < sp0)
            hasPropsLine = true;
        }
        if (!hasPropsLine)
          ws = `
${ctx.indent}`;
      }
    } else if (valueStr === "" || valueStr[0] === `
`) {
      ws = "";
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
      if (valueCommentDone && onComment)
        onComment();
    } else if (valueComment && !valueCommentDone) {
      str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
    } else if (chompKeep && onChompKeep) {
      onChompKeep();
    }
    return str;
  }
  exports.stringifyPair = stringifyPair;
});

// node_modules/yaml/dist/log.js
var require_log = __commonJS((exports) => {
  var node_process = __require("process");
  function debug(logLevel, ...messages) {
    if (logLevel === "debug")
      console.log(...messages);
  }
  function warn(logLevel, warning) {
    if (logLevel === "debug" || logLevel === "warn") {
      if (typeof node_process.emitWarning === "function")
        node_process.emitWarning(warning);
      else
        console.warn(warning);
    }
  }
  exports.debug = debug;
  exports.warn = warn;
});

// node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var MERGE_KEY = "<<";
  var merge = {
    identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
    default: "key",
    tag: "tag:yaml.org,2002:merge",
    test: /^<<$/,
    resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
      addToJSMap: addMergeToJSMap
    }),
    stringify: () => MERGE_KEY
  };
  var isMergeKey = (ctx, key) => (merge.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default);
  function addMergeToJSMap(ctx, map, value) {
    value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (identity.isSeq(value))
      for (const it of value.items)
        mergeValue(ctx, map, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeValue(ctx, map, it);
    else
      mergeValue(ctx, map, value);
  }
  function mergeValue(ctx, map, value) {
    const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!identity.isMap(source))
      throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value2] of srcMap) {
      if (map instanceof Map) {
        if (!map.has(key))
          map.set(key, value2);
      } else if (map instanceof Set) {
        map.add(key);
      } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
        Object.defineProperty(map, key, {
          value: value2,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
    }
    return map;
  }
  exports.addMergeToJSMap = addMergeToJSMap;
  exports.isMergeKey = isMergeKey;
  exports.merge = merge;
});

// node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS((exports) => {
  var log = require_log();
  var merge = require_merge();
  var stringify = require_stringify();
  var identity = require_identity();
  var toJS = require_toJS();
  function addPairToJSMap(ctx, map, { key, value }) {
    if (identity.isNode(key) && key.addToJSMap)
      key.addToJSMap(ctx, map, value);
    else if (merge.isMergeKey(ctx, key))
      merge.addMergeToJSMap(ctx, map, value);
    else {
      const jsKey = toJS.toJS(key, "", ctx);
      if (map instanceof Map) {
        map.set(jsKey, toJS.toJS(value, jsKey, ctx));
      } else if (map instanceof Set) {
        map.add(jsKey);
      } else {
        const stringKey = stringifyKey(key, jsKey, ctx);
        const jsValue = toJS.toJS(value, stringKey, ctx);
        if (stringKey in map)
          Object.defineProperty(map, stringKey, {
            value: jsValue,
            writable: true,
            enumerable: true,
            configurable: true
          });
        else
          map[stringKey] = jsValue;
      }
    }
    return map;
  }
  function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
      return "";
    if (typeof jsKey !== "object")
      return String(jsKey);
    if (identity.isNode(key) && ctx?.doc) {
      const strCtx = stringify.createStringifyContext(ctx.doc, {});
      strCtx.anchors = new Set;
      for (const node of ctx.anchors.keys())
        strCtx.anchors.add(node.anchor);
      strCtx.inFlow = true;
      strCtx.inStringifyKey = true;
      const strKey = key.toString(strCtx);
      if (!ctx.mapKeyWarned) {
        let jsonStr = JSON.stringify(strKey);
        if (jsonStr.length > 40)
          jsonStr = jsonStr.substring(0, 36) + '..."';
        log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
        ctx.mapKeyWarned = true;
      }
      return strKey;
    }
    return JSON.stringify(jsKey);
  }
  exports.addPairToJSMap = addPairToJSMap;
});

// node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyPair = require_stringifyPair();
  var addPairToJSMap = require_addPairToJSMap();
  var identity = require_identity();
  function createPair(key, value, ctx) {
    const k = createNode.createNode(key, undefined, ctx);
    const v = createNode.createNode(value, undefined, ctx);
    return new Pair(k, v);
  }

  class Pair {
    constructor(key, value = null) {
      Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
      this.key = key;
      this.value = value;
    }
    clone(schema) {
      let { key, value } = this;
      if (identity.isNode(key))
        key = key.clone(schema);
      if (identity.isNode(value))
        value = value.clone(schema);
      return new Pair(key, value);
    }
    toJSON(_, ctx) {
      const pair = ctx?.mapAsMap ? new Map : {};
      return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
      return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
    }
  }
  exports.Pair = Pair;
  exports.createPair = createPair;
});

// node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS((exports) => {
  var identity = require_identity();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify2(collection, ctx, options);
  }
  function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment2 = null;
      if (identity.isNode(item)) {
        if (!chompKeep && item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
        if (item.comment)
          comment2 = item.comment;
      } else if (identity.isPair(item)) {
        const ik = identity.isNode(item.key) ? item.key : null;
        if (ik) {
          if (!chompKeep && ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
        }
      }
      chompKeep = false;
      let str2 = stringify.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
      if (comment2)
        str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
      if (chompKeep && comment2)
        chompKeep = false;
      lines.push(blockItemPrefix + str2);
    }
    let str;
    if (lines.length === 0) {
      str = flowChars.start + flowChars.end;
    } else {
      str = lines[0];
      for (let i = 1;i < lines.length; ++i) {
        const line = lines[i];
        str += line ? `
${indent}${line}` : `
`;
      }
    }
    if (comment) {
      str += `
` + stringifyComment.indentComment(commentString(comment), indent);
      if (onComment)
        onComment();
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
      indent: itemIndent,
      inFlow: true,
      type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment = null;
      if (identity.isNode(item)) {
        if (item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, false);
        if (item.comment)
          comment = item.comment;
      } else if (identity.isPair(item)) {
        const ik = identity.isNode(item.key) ? item.key : null;
        if (ik) {
          if (ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, false);
          if (ik.comment)
            reqNewline = true;
        }
        const iv = identity.isNode(item.value) ? item.value : null;
        if (iv) {
          if (iv.comment)
            comment = iv.comment;
          if (iv.commentBefore)
            reqNewline = true;
        } else if (item.value == null && ik?.comment) {
          comment = ik.comment;
        }
      }
      if (comment)
        reqNewline = true;
      let str = stringify.stringify(item, itemCtx, () => comment = null);
      if (i < items.length - 1)
        str += ",";
      if (comment)
        str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
      if (!reqNewline && (lines.length > linesAtValue || str.includes(`
`)))
        reqNewline = true;
      lines.push(str);
      linesAtValue = lines.length;
    }
    const { start, end } = flowChars;
    if (lines.length === 0) {
      return start + end;
    } else {
      if (!reqNewline) {
        const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
        reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
      }
      if (reqNewline) {
        let str = start;
        for (const line of lines)
          str += line ? `
${indentStep}${indent}${line}` : `
`;
        return `${str}
${indent}${end}`;
      } else {
        return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
      }
    }
  }
  function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
      comment = comment.replace(/^\n+/, "");
    if (comment) {
      const ic = stringifyComment.indentComment(commentString(comment), indent);
      lines.push(ic.trimStart());
    }
  }
  exports.stringifyCollection = stringifyCollection;
});

// node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS((exports) => {
  var stringifyCollection = require_stringifyCollection();
  var addPairToJSMap = require_addPairToJSMap();
  var Collection = require_Collection();
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  function findPair(items, key) {
    const k = identity.isScalar(key) ? key.value : key;
    for (const it of items) {
      if (identity.isPair(it)) {
        if (it.key === key || it.key === k)
          return it;
        if (identity.isScalar(it.key) && it.key.value === k)
          return it;
      }
    }
    return;
  }

  class YAMLMap extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:map";
    }
    constructor(schema) {
      super(identity.MAP, schema);
      this.items = [];
    }
    static from(schema, obj, ctx) {
      const { keepUndefined, replacer } = ctx;
      const map = new this(schema);
      const add = (key, value) => {
        if (typeof replacer === "function")
          value = replacer.call(obj, key, value);
        else if (Array.isArray(replacer) && !replacer.includes(key))
          return;
        if (value !== undefined || keepUndefined)
          map.items.push(Pair.createPair(key, value, ctx));
      };
      if (obj instanceof Map) {
        for (const [key, value] of obj)
          add(key, value);
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          add(key, obj[key]);
      }
      if (typeof schema.sortMapEntries === "function") {
        map.items.sort(schema.sortMapEntries);
      }
      return map;
    }
    add(pair, overwrite) {
      let _pair;
      if (identity.isPair(pair))
        _pair = pair;
      else if (!pair || typeof pair !== "object" || !("key" in pair)) {
        _pair = new Pair.Pair(pair, pair?.value);
      } else
        _pair = new Pair.Pair(pair.key, pair.value);
      const prev = findPair(this.items, _pair.key);
      const sortEntries = this.schema?.sortMapEntries;
      if (prev) {
        if (!overwrite)
          throw new Error(`Key ${_pair.key} already set`);
        if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
          prev.value.value = _pair.value;
        else
          prev.value = _pair.value;
      } else if (sortEntries) {
        const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
        if (i === -1)
          this.items.push(_pair);
        else
          this.items.splice(i, 0, _pair);
      } else {
        this.items.push(_pair);
      }
    }
    delete(key) {
      const it = findPair(this.items, key);
      if (!it)
        return false;
      const del = this.items.splice(this.items.indexOf(it), 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const it = findPair(this.items, key);
      const node = it?.value;
      return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
      return !!findPair(this.items, key);
    }
    set(key, value) {
      this.add(new Pair.Pair(key, value), true);
    }
    toJSON(_, ctx, Type) {
      const map = Type ? new Type : ctx?.mapAsMap ? new Map : {};
      if (ctx?.onCreate)
        ctx.onCreate(map);
      for (const item of this.items)
        addPairToJSMap.addPairToJSMap(ctx, map, item);
      return map;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      for (const item of this.items) {
        if (!identity.isPair(item))
          throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
      }
      if (!ctx.allNullValues && this.hasAllNullValues(false))
        ctx = Object.assign({}, ctx, { allNullValues: true });
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "",
        flowChars: { start: "{", end: "}" },
        itemIndent: ctx.indent || "",
        onChompKeep,
        onComment
      });
    }
  }
  exports.YAMLMap = YAMLMap;
  exports.findPair = findPair;
});

// node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS((exports) => {
  var identity = require_identity();
  var YAMLMap = require_YAMLMap();
  var map = {
    collection: "map",
    default: true,
    nodeClass: YAMLMap.YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve(map2, onError) {
      if (!identity.isMap(map2))
        onError("Expected a mapping for this tag");
      return map2;
    },
    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
  };
  exports.map = map;
});

// node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyCollection = require_stringifyCollection();
  var Collection = require_Collection();
  var identity = require_identity();
  var Scalar = require_Scalar();
  var toJS = require_toJS();

  class YAMLSeq extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:seq";
    }
    constructor(schema) {
      super(identity.SEQ, schema);
      this.items = [];
    }
    add(value) {
      this.items.push(value);
    }
    delete(key) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return false;
      const del = this.items.splice(idx, 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return;
      const it = this.items[idx];
      return !keepScalar && identity.isScalar(it) ? it.value : it;
    }
    has(key) {
      const idx = asItemIndex(key);
      return typeof idx === "number" && idx < this.items.length;
    }
    set(key, value) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        throw new Error(`Expected a valid index, not ${key}.`);
      const prev = this.items[idx];
      if (identity.isScalar(prev) && Scalar.isScalarValue(value))
        prev.value = value;
      else
        this.items[idx] = value;
    }
    toJSON(_, ctx) {
      const seq = [];
      if (ctx?.onCreate)
        ctx.onCreate(seq);
      let i = 0;
      for (const item of this.items)
        seq.push(toJS.toJS(item, String(i++), ctx));
      return seq;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "- ",
        flowChars: { start: "[", end: "]" },
        itemIndent: (ctx.indent || "") + "  ",
        onChompKeep,
        onComment
      });
    }
    static from(schema, obj, ctx) {
      const { replacer } = ctx;
      const seq = new this(schema);
      if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it of obj) {
          if (typeof replacer === "function") {
            const key = obj instanceof Set ? it : String(i++);
            it = replacer.call(obj, key, it);
          }
          seq.items.push(createNode.createNode(it, undefined, ctx));
        }
      }
      return seq;
    }
  }
  function asItemIndex(key) {
    let idx = identity.isScalar(key) ? key.value : key;
    if (idx && typeof idx === "string")
      idx = Number(idx);
    return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
  }
  exports.YAMLSeq = YAMLSeq;
});

// node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS((exports) => {
  var identity = require_identity();
  var YAMLSeq = require_YAMLSeq();
  var seq = {
    collection: "seq",
    default: true,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve(seq2, onError) {
      if (!identity.isSeq(seq2))
        onError("Expected a sequence for this tag");
      return seq2;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
  };
  exports.seq = seq;
});

// node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS((exports) => {
  var stringifyString = require_stringifyString();
  var string = {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify(item, ctx, onComment, onChompKeep) {
      ctx = Object.assign({ actualString: true }, ctx);
      return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
    }
  };
  exports.string = string;
});

// node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var nullTag = {
    identify: (value) => value == null,
    createNode: () => new Scalar.Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
  };
  exports.nullTag = nullTag;
});

// node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var boolTag = {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
    stringify({ source, value }, ctx) {
      if (source && boolTag.test.test(source)) {
        const sv = source[0] === "t" || source[0] === "T";
        if (value === sv)
          return source;
      }
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
  };
  exports.boolTag = boolTag;
});

// node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS((exports) => {
  function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === "bigint")
      return String(value);
    const num = typeof value === "number" ? value : Number(value);
    if (!isFinite(num))
      return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n = Object.is(value, -0) ? "-0" : JSON.stringify(value);
    if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
      let i = n.indexOf(".");
      if (i < 0) {
        i = n.length;
        n += ".";
      }
      let d = minFractionDigits - (n.length - i - 1);
      while (d-- > 0)
        n += "0";
    }
    return n;
  }
  exports.stringifyNumber = stringifyNumber;
});

// node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str));
      const dot = str.indexOf(".");
      if (dot !== -1 && str[str.length - 1] === "0")
        node.minFractionDigits = str.length - dot - 1;
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
      return prefix + value.toString(radix);
    return stringifyNumber.stringifyNumber(node);
  }
  var intOct = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: (node) => intStringify(node, 8, "0o")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS((exports) => {
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.boolTag,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var map = require_map();
  var seq = require_seq();
  function intIdentify(value) {
    return typeof value === "bigint" || Number.isInteger(value);
  }
  var stringifyJSON = ({ value }) => JSON.stringify(value);
  var jsonScalars = [
    {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify: stringifyJSON
    },
    {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    },
    {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true$|^false$/,
      resolve: (str) => str === "true",
      stringify: stringifyJSON
    },
    {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: stringifyJSON
    }
  ];
  var jsonError = {
    default: true,
    tag: "",
    test: /^/,
    resolve(str, onError) {
      onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
      return str;
    }
  };
  var schema = [map.map, seq.seq].concat(jsonScalars, jsonError);
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS((exports) => {
  var node_buffer = __require("buffer");
  var Scalar = require_Scalar();
  var stringifyString = require_stringifyString();
  var binary = {
    identify: (value) => value instanceof Uint8Array,
    default: false,
    tag: "tag:yaml.org,2002:binary",
    resolve(src, onError) {
      if (typeof node_buffer.Buffer === "function") {
        return node_buffer.Buffer.from(src, "base64");
      } else if (typeof atob === "function") {
        const str = atob(src.replace(/[\n\r]/g, ""));
        const buffer = new Uint8Array(str.length);
        for (let i = 0;i < str.length; ++i)
          buffer[i] = str.charCodeAt(i);
        return buffer;
      } else {
        onError("This environment does not support reading binary tags; either Buffer or atob is required");
        return src;
      }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
      if (!value)
        return "";
      const buf = value;
      let str;
      if (typeof node_buffer.Buffer === "function") {
        str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
      } else if (typeof btoa === "function") {
        let s = "";
        for (let i = 0;i < buf.length; ++i)
          s += String.fromCharCode(buf[i]);
        str = btoa(s);
      } else {
        throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
      }
      type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
        const n = Math.ceil(str.length / lineWidth);
        const lines = new Array(n);
        for (let i = 0, o = 0;i < n; ++i, o += lineWidth) {
          lines[i] = str.substr(o, lineWidth);
        }
        str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? `
` : " ");
      }
      return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
  };
  exports.binary = binary;
});

// node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  var YAMLSeq = require_YAMLSeq();
  function resolvePairs(seq, onError) {
    if (identity.isSeq(seq)) {
      for (let i = 0;i < seq.items.length; ++i) {
        let item = seq.items[i];
        if (identity.isPair(item))
          continue;
        else if (identity.isMap(item)) {
          if (item.items.length > 1)
            onError("Each pair must have its own sequence indicator");
          const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
          if (item.commentBefore)
            pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
          if (item.comment) {
            const cn = pair.value ?? pair.key;
            cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
          }
          item = pair;
        }
        seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
      }
    } else
      onError("Expected a sequence for this tag");
    return seq;
  }
  function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs2 = new YAMLSeq.YAMLSeq(schema);
    pairs2.tag = "tag:yaml.org,2002:pairs";
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
      for (let it of iterable) {
        if (typeof replacer === "function")
          it = replacer.call(iterable, String(i++), it);
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys = Object.keys(it);
          if (keys.length === 1) {
            key = keys[0];
            value = it[key];
          } else {
            throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
          }
        } else {
          key = it;
        }
        pairs2.items.push(Pair.createPair(key, value, ctx));
      }
    return pairs2;
  }
  var pairs = {
    collection: "seq",
    default: false,
    tag: "tag:yaml.org,2002:pairs",
    resolve: resolvePairs,
    createNode: createPairs
  };
  exports.createPairs = createPairs;
  exports.pairs = pairs;
  exports.resolvePairs = resolvePairs;
});

// node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS((exports) => {
  var identity = require_identity();
  var toJS = require_toJS();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var pairs = require_pairs();

  class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
      super();
      this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
      this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
      this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
      this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
      this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
      this.tag = YAMLOMap.tag;
    }
    toJSON(_, ctx) {
      if (!ctx)
        return super.toJSON(_);
      const map = new Map;
      if (ctx?.onCreate)
        ctx.onCreate(map);
      for (const pair of this.items) {
        let key, value;
        if (identity.isPair(pair)) {
          key = toJS.toJS(pair.key, "", ctx);
          value = toJS.toJS(pair.value, key, ctx);
        } else {
          key = toJS.toJS(pair, "", ctx);
        }
        if (map.has(key))
          throw new Error("Ordered maps must not include duplicate keys");
        map.set(key, value);
      }
      return map;
    }
    static from(schema, iterable, ctx) {
      const pairs$1 = pairs.createPairs(schema, iterable, ctx);
      const omap2 = new this;
      omap2.items = pairs$1.items;
      return omap2;
    }
  }
  YAMLOMap.tag = "tag:yaml.org,2002:omap";
  var omap = {
    collection: "seq",
    identify: (value) => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: "tag:yaml.org,2002:omap",
    resolve(seq, onError) {
      const pairs$1 = pairs.resolvePairs(seq, onError);
      const seenKeys = [];
      for (const { key } of pairs$1.items) {
        if (identity.isScalar(key)) {
          if (seenKeys.includes(key.value)) {
            onError(`Ordered maps must not include duplicate keys: ${key.value}`);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap, pairs$1);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
  };
  exports.YAMLOMap = YAMLOMap;
  exports.omap = omap;
});

// node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
      return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
  var trueTag = {
    identify: (value) => value === true,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(true),
    stringify: boolStringify
  };
  var falseTag = {
    identify: (value) => value === false,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
    resolve: () => new Scalar.Scalar(false),
    stringify: boolStringify
  };
  exports.falseTag = falseTag;
  exports.trueTag = trueTag;
});

// node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, "")),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
      const dot = str.indexOf(".");
      if (dot !== -1) {
        const f = str.substring(dot + 1).replace(/_/g, "");
        if (f[f.length - 1] === "0")
          node.minFractionDigits = f.length;
      }
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === "-" || sign === "+")
      offset += 1;
    str = str.substring(offset).replace(/_/g, "");
    if (intAsBigInt) {
      switch (radix) {
        case 2:
          str = `0b${str}`;
          break;
        case 8:
          str = `0o${str}`;
          break;
        case 16:
          str = `0x${str}`;
          break;
      }
      const n2 = BigInt(str);
      return sign === "-" ? BigInt(-1) * n2 : n2;
    }
    const n = parseInt(str, radix);
    return sign === "-" ? -1 * n : n;
  }
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
      const str = value.toString(radix);
      return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
  }
  var intBin = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: (node) => intStringify(node, 2, "0b")
  };
  var intOct = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: (node) => intStringify(node, 8, "0")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int;
  exports.intBin = intBin;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();

  class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
      super(schema);
      this.tag = YAMLSet.tag;
    }
    add(key) {
      let pair;
      if (identity.isPair(key))
        pair = key;
      else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
        pair = new Pair.Pair(key.key, null);
      else
        pair = new Pair.Pair(key, null);
      const prev = YAMLMap.findPair(this.items, pair.key);
      if (!prev)
        this.items.push(pair);
    }
    get(key, keepPair) {
      const pair = YAMLMap.findPair(this.items, key);
      return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
    }
    set(key, value) {
      if (typeof value !== "boolean")
        throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
      const prev = YAMLMap.findPair(this.items, key);
      if (prev && !value) {
        this.items.splice(this.items.indexOf(prev), 1);
      } else if (!prev && value) {
        this.items.push(new Pair.Pair(key));
      }
    }
    toJSON(_, ctx) {
      return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      if (this.hasAllNullValues(true))
        return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
      else
        throw new Error("Set items must all have null values");
    }
    static from(schema, iterable, ctx) {
      const { replacer } = ctx;
      const set2 = new this(schema);
      if (iterable && Symbol.iterator in Object(iterable))
        for (let value of iterable) {
          if (typeof replacer === "function")
            value = replacer.call(iterable, value, value);
          set2.items.push(Pair.createPair(value, null, ctx));
        }
      return set2;
    }
  }
  YAMLSet.tag = "tag:yaml.org,2002:set";
  var set = {
    collection: "map",
    identify: (value) => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: "tag:yaml.org,2002:set",
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map, onError) {
      if (identity.isMap(map)) {
        if (map.hasAllNullValues(true))
          return Object.assign(new YAMLSet, map);
        else
          onError("Set items must all have null values");
      } else
        onError("Expected a mapping for this tag");
      return map;
    }
  };
  exports.YAMLSet = YAMLSet;
  exports.set = set;
});

// node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
    return sign === "-" ? num(-1) * res : res;
  }
  function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === "bigint")
      num = (n) => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
      return stringifyNumber.stringifyNumber(node);
    let sign = "";
    if (value < 0) {
      sign = "-";
      value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60];
    if (value < 60) {
      parts.unshift(0);
    } else {
      value = (value - parts[0]) / _60;
      parts.unshift(value % _60);
      if (value >= 60) {
        value = (value - parts[0]) / _60;
        parts.unshift(value);
      }
    }
    return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
  }
  var intTime = {
    identify: (value) => typeof value === "bigint" || Number.isInteger(value),
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
  };
  var floatTime = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: (str) => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
  };
  var timestamp = {
    identify: (value) => value instanceof Date,
    default: true,
    tag: "tag:yaml.org,2002:timestamp",
    test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})" + "(?:" + "(?:t|T|[ \\t]+)" + "([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)" + "(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?" + ")?$"),
    resolve(str) {
      const match = str.match(timestamp.test);
      if (!match)
        throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
      const [, year, month, day, hour, minute, second] = match.map(Number);
      const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
      let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
      const tz = match[8];
      if (tz && tz !== "Z") {
        let d = parseSexagesimal(tz, false);
        if (Math.abs(d) < 30)
          d *= 60;
        date -= 60000 * d;
      }
      return new Date(date);
    },
    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
  };
  exports.floatTime = floatTime;
  exports.intTime = intTime;
  exports.timestamp = timestamp;
});

// node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS((exports) => {
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var binary = require_binary();
  var bool = require_bool2();
  var float = require_float2();
  var int = require_int2();
  var merge = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var set = require_set();
  var timestamp = require_timestamp();
  var schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.trueTag,
    bool.falseTag,
    int.intBin,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float,
    binary.binary,
    merge.merge,
    omap.omap,
    pairs.pairs,
    set.set,
    timestamp.intTime,
    timestamp.floatTime,
    timestamp.timestamp
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS((exports) => {
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = require_schema();
  var schema$1 = require_schema2();
  var binary = require_binary();
  var merge = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var schema$2 = require_schema3();
  var set = require_set();
  var timestamp = require_timestamp();
  var schemas = new Map([
    ["core", schema.schema],
    ["failsafe", [map.map, seq.seq, string.string]],
    ["json", schema$1.schema],
    ["yaml11", schema$2.schema],
    ["yaml-1.1", schema$2.schema]
  ]);
  var tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map.map,
    merge: merge.merge,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq.seq,
    set: set.set,
    timestamp: timestamp.timestamp
  };
  var coreKnownTags = {
    "tag:yaml.org,2002:binary": binary.binary,
    "tag:yaml.org,2002:merge": merge.merge,
    "tag:yaml.org,2002:omap": omap.omap,
    "tag:yaml.org,2002:pairs": pairs.pairs,
    "tag:yaml.org,2002:set": set.set,
    "tag:yaml.org,2002:timestamp": timestamp.timestamp
  };
  function getTags(customTags, schemaName, addMergeTag) {
    const schemaTags = schemas.get(schemaName);
    if (schemaTags && !customTags) {
      return addMergeTag && !schemaTags.includes(merge.merge) ? schemaTags.concat(merge.merge) : schemaTags.slice();
    }
    let tags = schemaTags;
    if (!tags) {
      if (Array.isArray(customTags))
        tags = [];
      else {
        const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
      }
    }
    if (Array.isArray(customTags)) {
      for (const tag of customTags)
        tags = tags.concat(tag);
    } else if (typeof customTags === "function") {
      tags = customTags(tags.slice());
    }
    if (addMergeTag)
      tags = tags.concat(merge.merge);
    return tags.reduce((tags2, tag) => {
      const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
      if (!tagObj) {
        const tagName = JSON.stringify(tag);
        const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
      }
      if (!tags2.includes(tagObj))
        tags2.push(tagObj);
      return tags2;
    }, []);
  }
  exports.coreKnownTags = coreKnownTags;
  exports.getTags = getTags;
});

// node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS((exports) => {
  var identity = require_identity();
  var map = require_map();
  var seq = require_seq();
  var string = require_string();
  var tags = require_tags();
  var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;

  class Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
      this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
      this.name = typeof schema === "string" && schema || "core";
      this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
      this.tags = tags.getTags(customTags, this.name, merge);
      this.toStringOptions = toStringDefaults ?? null;
      Object.defineProperty(this, identity.MAP, { value: map.map });
      Object.defineProperty(this, identity.SCALAR, { value: string.string });
      Object.defineProperty(this, identity.SEQ, { value: seq.seq });
      this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
    }
    clone() {
      const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
      copy.tags = this.tags.slice();
      return copy;
    }
  }
  exports.Schema = Schema;
});

// node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS((exports) => {
  var identity = require_identity();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
      const dir = doc.directives.toString(doc);
      if (dir) {
        lines.push(dir);
        hasDirectives = true;
      } else if (doc.directives.docStart)
        hasDirectives = true;
    }
    if (hasDirectives)
      lines.push("---");
    const ctx = stringify.createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
      if (lines.length !== 1)
        lines.unshift("");
      const cs = commentString(doc.commentBefore);
      lines.unshift(stringifyComment.indentComment(cs, ""));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
      if (identity.isNode(doc.contents)) {
        if (doc.contents.spaceBefore && hasDirectives)
          lines.push("");
        if (doc.contents.commentBefore) {
          const cs = commentString(doc.contents.commentBefore);
          lines.push(stringifyComment.indentComment(cs, ""));
        }
        ctx.forceBlockIndent = !!doc.comment;
        contentComment = doc.contents.comment;
      }
      const onChompKeep = contentComment ? undefined : () => chompKeep = true;
      let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
      if (contentComment)
        body += stringifyComment.lineComment(body, "", commentString(contentComment));
      if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
        lines[lines.length - 1] = `--- ${body}`;
      } else
        lines.push(body);
    } else {
      lines.push(stringify.stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
      if (doc.comment) {
        const cs = commentString(doc.comment);
        if (cs.includes(`
`)) {
          lines.push("...");
          lines.push(stringifyComment.indentComment(cs, ""));
        } else {
          lines.push(`... ${cs}`);
        }
      } else {
        lines.push("...");
      }
    } else {
      let dc = doc.comment;
      if (dc && chompKeep)
        dc = dc.replace(/^\n+/, "");
      if (dc) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
          lines.push("");
        lines.push(stringifyComment.indentComment(commentString(dc), ""));
      }
    }
    return lines.join(`
`) + `
`;
  }
  exports.stringifyDocument = stringifyDocument;
});

// node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS((exports) => {
  var Alias = require_Alias();
  var Collection = require_Collection();
  var identity = require_identity();
  var Pair = require_Pair();
  var toJS = require_toJS();
  var Schema = require_Schema();
  var stringifyDocument = require_stringifyDocument();
  var anchors = require_anchors();
  var applyReviver = require_applyReviver();
  var createNode = require_createNode();
  var directives = require_directives();

  class Document {
    constructor(value, replacer, options) {
      this.commentBefore = null;
      this.comment = null;
      this.errors = [];
      this.warnings = [];
      Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const opt = Object.assign({
        intAsBigInt: false,
        keepSourceTokens: false,
        logLevel: "warn",
        prettyErrors: true,
        strict: true,
        stringKeys: false,
        uniqueKeys: true,
        version: "1.2"
      }, options);
      this.options = opt;
      let { version } = opt;
      if (options?._directives) {
        this.directives = options._directives.atDocument();
        if (this.directives.yaml.explicit)
          version = this.directives.yaml.version;
      } else
        this.directives = new directives.Directives({ version });
      this.setSchema(version, options);
      this.contents = value === undefined ? null : this.createNode(value, _replacer, options);
    }
    clone() {
      const copy = Object.create(Document.prototype, {
        [identity.NODE_TYPE]: { value: identity.DOC }
      });
      copy.commentBefore = this.commentBefore;
      copy.comment = this.comment;
      copy.errors = this.errors.slice();
      copy.warnings = this.warnings.slice();
      copy.options = Object.assign({}, this.options);
      if (this.directives)
        copy.directives = this.directives.clone();
      copy.schema = this.schema.clone();
      copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    add(value) {
      if (assertCollection(this.contents))
        this.contents.add(value);
    }
    addIn(path, value) {
      if (assertCollection(this.contents))
        this.contents.addIn(path, value);
    }
    createAlias(node, name) {
      if (!node.anchor) {
        const prev = anchors.anchorNames(this);
        node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
      }
      return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
      let _replacer = undefined;
      if (typeof replacer === "function") {
        value = replacer.call({ "": value }, "", value);
        _replacer = replacer;
      } else if (Array.isArray(replacer)) {
        const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
        const asStr = replacer.filter(keyToStr).map(String);
        if (asStr.length > 0)
          replacer = replacer.concat(asStr);
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
      const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || "a");
      const ctx = {
        aliasDuplicateObjects: aliasDuplicateObjects ?? true,
        keepUndefined: keepUndefined ?? false,
        onAnchor,
        onTagObj,
        replacer: _replacer,
        schema: this.schema,
        sourceObjects
      };
      const node = createNode.createNode(value, tag, ctx);
      if (flow && identity.isCollection(node))
        node.flow = true;
      setAnchors();
      return node;
    }
    createPair(key, value, options = {}) {
      const k = this.createNode(key, null, options);
      const v = this.createNode(value, null, options);
      return new Pair.Pair(k, v);
    }
    delete(key) {
      return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    deleteIn(path) {
      if (Collection.isEmptyPath(path)) {
        if (this.contents == null)
          return false;
        this.contents = null;
        return true;
      }
      return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
    }
    get(key, keepScalar) {
      return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : undefined;
    }
    getIn(path, keepScalar) {
      if (Collection.isEmptyPath(path))
        return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
      return identity.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : undefined;
    }
    has(key) {
      return identity.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    hasIn(path) {
      if (Collection.isEmptyPath(path))
        return this.contents !== undefined;
      return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    set(key, value) {
      if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, [key], value);
      } else if (assertCollection(this.contents)) {
        this.contents.set(key, value);
      }
    }
    setIn(path, value) {
      if (Collection.isEmptyPath(path)) {
        this.contents = value;
      } else if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
      } else if (assertCollection(this.contents)) {
        this.contents.setIn(path, value);
      }
    }
    setSchema(version, options = {}) {
      if (typeof version === "number")
        version = String(version);
      let opt;
      switch (version) {
        case "1.1":
          if (this.directives)
            this.directives.yaml.version = "1.1";
          else
            this.directives = new directives.Directives({ version: "1.1" });
          opt = { resolveKnownTags: false, schema: "yaml-1.1" };
          break;
        case "1.2":
        case "next":
          if (this.directives)
            this.directives.yaml.version = version;
          else
            this.directives = new directives.Directives({ version });
          opt = { resolveKnownTags: true, schema: "core" };
          break;
        case null:
          if (this.directives)
            delete this.directives;
          opt = null;
          break;
        default: {
          const sv = JSON.stringify(version);
          throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
        }
      }
      if (options.schema instanceof Object)
        this.schema = options.schema;
      else if (opt)
        this.schema = new Schema.Schema(Object.assign(opt, options));
      else
        throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      const ctx = {
        anchors: new Map,
        doc: this,
        keep: !json,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
    toJSON(jsonArg, onAnchor) {
      return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    toString(options = {}) {
      if (this.errors.length > 0)
        throw new Error("Document with errors cannot be stringified");
      if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
        const s = JSON.stringify(options.indent);
        throw new Error(`"indent" option must be a positive integer, not ${s}`);
      }
      return stringifyDocument.stringifyDocument(this, options);
    }
  }
  function assertCollection(contents) {
    if (identity.isCollection(contents))
      return true;
    throw new Error("Expected a YAML collection as document contents");
  }
  exports.Document = Document;
});

// node_modules/yaml/dist/errors.js
var require_errors = __commonJS((exports) => {
  class YAMLError extends Error {
    constructor(name, pos, code, message) {
      super();
      this.name = name;
      this.code = code;
      this.message = message;
      this.pos = pos;
    }
  }

  class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLParseError", pos, code, message);
    }
  }

  class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLWarning", pos, code, message);
    }
  }
  var prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
      return;
    error.linePos = error.pos.map((pos) => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
    if (ci >= 60 && lineStr.length > 80) {
      const trimStart = Math.min(ci - 39, lineStr.length - 79);
      lineStr = "\u2026" + lineStr.substring(trimStart);
      ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
      lineStr = lineStr.substring(0, 79) + "\u2026";
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
      let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
      if (prev.length > 80)
        prev = prev.substring(0, 79) + `\u2026
`;
      lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
      let count = 1;
      const end = error.linePos[1];
      if (end?.line === line && end.col > col) {
        count = Math.max(1, Math.min(end.col - col, 80 - ci));
      }
      const pointer = " ".repeat(ci) + "^".repeat(count);
      error.message += `:

${lineStr}
${pointer}
`;
    }
  };
  exports.YAMLError = YAMLError;
  exports.YAMLParseError = YAMLParseError;
  exports.YAMLWarning = YAMLWarning;
  exports.prettifyError = prettifyError;
});

// node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS((exports) => {
  function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = "";
    let commentSep = "";
    let hasNewline = false;
    let reqSpace = false;
    let tab = null;
    let anchor = null;
    let tag = null;
    let newlineAfterProp = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
      if (reqSpace) {
        if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
          onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
        reqSpace = false;
      }
      if (tab) {
        if (atNewline && token.type !== "comment" && token.type !== "newline") {
          onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        }
        tab = null;
      }
      switch (token.type) {
        case "space":
          if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("\t")) {
            tab = token;
          }
          hasSpace = true;
          break;
        case "comment": {
          if (!hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = token.source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += commentSep + cb;
          commentSep = "";
          atNewline = false;
          break;
        }
        case "newline":
          if (atNewline) {
            if (comment)
              comment += token.source;
            else if (!found || indicator !== "seq-item-ind")
              spaceBefore = true;
          } else
            commentSep += token.source;
          atNewline = true;
          hasNewline = true;
          if (anchor || tag)
            newlineAfterProp = token;
          hasSpace = true;
          break;
        case "anchor":
          if (anchor)
            onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
          if (token.source.endsWith(":"))
            onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
          anchor = token;
          start ?? (start = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        case "tag": {
          if (tag)
            onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
          tag = token;
          start ?? (start = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        }
        case indicator:
          if (anchor || tag)
            onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
          if (found)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
          found = token;
          atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
          hasSpace = false;
          break;
        case "comma":
          if (flow) {
            if (comma)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
            comma = token;
            atNewline = false;
            hasSpace = false;
            break;
          }
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
          atNewline = false;
          hasSpace = false;
      }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
      onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
    }
    if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
      onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
    return {
      comma,
      found,
      spaceBefore,
      comment,
      hasNewline,
      anchor,
      tag,
      newlineAfterProp,
      end,
      start: start ?? end
    };
  }
  exports.resolveProps = resolveProps;
});

// node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS((exports) => {
  function containsNewline(key) {
    if (!key)
      return null;
    switch (key.type) {
      case "alias":
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        if (key.source.includes(`
`))
          return true;
        if (key.end) {
          for (const st of key.end)
            if (st.type === "newline")
              return true;
        }
        return false;
      case "flow-collection":
        for (const it of key.items) {
          for (const st of it.start)
            if (st.type === "newline")
              return true;
          if (it.sep) {
            for (const st of it.sep)
              if (st.type === "newline")
                return true;
          }
          if (containsNewline(it.key) || containsNewline(it.value))
            return true;
        }
        return false;
      default:
        return true;
    }
  }
  exports.containsNewline = containsNewline;
});

// node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS((exports) => {
  var utilContainsNewline = require_util_contains_newline();
  function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === "flow-collection") {
      const end = fc.end[0];
      if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
        const msg = "Flow end indicator should be more indented than parent";
        onError(end, "BAD_INDENT", msg, true);
      }
    }
  }
  exports.flowIndentCheck = flowIndentCheck;
});

// node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS((exports) => {
  var identity = require_identity();
  function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
      return false;
    const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
    return items.some((pair) => isEqual(pair.key, search));
  }
  exports.mapIncludes = mapIncludes;
});

// node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS((exports) => {
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  var utilMapIncludes = require_util_map_includes();
  var startColMsg = "All mapping items must start at the same column";
  function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
    const map = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
      const { start, key, sep, value } = collItem;
      const keyProps = resolveProps.resolveProps(start, {
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        parentIndent: bm.indent,
        startOnNewline: true
      });
      const implicitKey = !keyProps.found;
      if (implicitKey) {
        if (key) {
          if (key.type === "block-seq")
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
          else if ("indent" in key && key.indent !== bm.indent)
            onError(offset, "BAD_INDENT", startColMsg);
        }
        if (!keyProps.anchor && !keyProps.tag && !sep) {
          commentEnd = keyProps.end;
          if (keyProps.comment) {
            if (map.comment)
              map.comment += `
` + keyProps.comment;
            else
              map.comment = keyProps.comment;
          }
          continue;
        }
        if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
          onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        }
      } else if (keyProps.found?.indent !== bm.indent) {
        onError(offset, "BAD_INDENT", startColMsg);
      }
      ctx.atKey = true;
      const keyStart = keyProps.end;
      const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
      ctx.atKey = false;
      if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
        onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
      const valueProps = resolveProps.resolveProps(sep ?? [], {
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: bm.indent,
        startOnNewline: !key || key.type === "block-scalar"
      });
      offset = valueProps.end;
      if (valueProps.found) {
        if (implicitKey) {
          if (value?.type === "block-map" && !valueProps.hasNewline)
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
          if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
            onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
        offset = valueNode.range[2];
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map.items.push(pair);
      } else {
        if (implicitKey)
          onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
        if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map.items.push(pair);
      }
    }
    if (commentEnd && commentEnd < offset)
      onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
    map.range = [bm.offset, offset, commentEnd ?? offset];
    return map;
  }
  exports.resolveBlockMap = resolveBlockMap;
});

// node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS((exports) => {
  var YAMLSeq = require_YAMLSeq();
  var resolveProps = require_resolve_props();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
      const props = resolveProps.resolveProps(start, {
        indicator: "seq-item-ind",
        next: value,
        offset,
        onError,
        parentIndent: bs.indent,
        startOnNewline: true
      });
      if (!props.found) {
        if (props.anchor || props.tag || value) {
          if (value?.type === "block-seq")
            onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
          else
            onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
        } else {
          commentEnd = props.end;
          if (props.comment)
            seq.comment = props.comment;
          continue;
        }
      }
      const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
      offset = node.range[2];
      seq.items.push(node);
    }
    seq.range = [bs.offset, offset, commentEnd ?? offset];
    return seq;
  }
  exports.resolveBlockSeq = resolveBlockSeq;
});

// node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS((exports) => {
  function resolveEnd(end, offset, reqSpace, onError) {
    let comment = "";
    if (end) {
      let hasSpace = false;
      let sep = "";
      for (const token of end) {
        const { source, type } = token;
        switch (type) {
          case "space":
            hasSpace = true;
            break;
          case "comment": {
            if (reqSpace && !hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += sep + cb;
            sep = "";
            break;
          }
          case "newline":
            if (comment)
              sep += source;
            hasSpace = true;
            break;
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
        }
        offset += source.length;
      }
    }
    return { comment, offset };
  }
  exports.resolveEnd = resolveEnd;
});

// node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilMapIncludes = require_util_map_includes();
  var blockMsg = "Block collections are not allowed within flow collections";
  var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === "{";
    const fcName = isMap ? "flow map" : "flow sequence";
    const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0;i < fc.items.length; ++i) {
      const collItem = fc.items[i];
      const { start, key, sep, value } = collItem;
      const props = resolveProps.resolveProps(start, {
        flow: fcName,
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (!props.found) {
        if (!props.anchor && !props.tag && !sep && !value) {
          if (i === 0 && props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
          else if (i < fc.items.length - 1)
            onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
          if (props.comment) {
            if (coll.comment)
              coll.comment += `
` + props.comment;
            else
              coll.comment = props.comment;
          }
          offset = props.end;
          continue;
        }
        if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
          onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
      }
      if (i === 0) {
        if (props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
      } else {
        if (!props.comma)
          onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
        if (props.comment) {
          let prevItemComment = "";
          loop:
            for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
          if (prevItemComment) {
            let prev = coll.items[coll.items.length - 1];
            if (identity.isPair(prev))
              prev = prev.value ?? prev.key;
            if (prev.comment)
              prev.comment += `
` + prevItemComment;
            else
              prev.comment = prevItemComment;
            props.comment = props.comment.substring(prevItemComment.length + 1);
          }
        }
      }
      if (!isMap && !sep && !props.found) {
        const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
        coll.items.push(valueNode);
        offset = valueNode.range[2];
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else {
        ctx.atKey = true;
        const keyStart = props.end;
        const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
        if (isBlock(key))
          onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
        ctx.atKey = false;
        const valueProps = resolveProps.resolveProps(sep ?? [], {
          flow: fcName,
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (valueProps.found) {
          if (!isMap && !props.found && ctx.options.strict) {
            if (sep)
              for (const st of sep) {
                if (st === valueProps.found)
                  break;
                if (st.type === "newline") {
                  onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                  break;
                }
              }
            if (props.start < valueProps.found.offset - 1024)
              onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
          }
        } else if (value) {
          if ("source" in value && value.source?.[0] === ":")
            onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
          else
            onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
        if (valueNode) {
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        if (isMap) {
          const map = coll;
          if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
          map.items.push(pair);
        } else {
          const map = new YAMLMap.YAMLMap(ctx.schema);
          map.flow = true;
          map.items.push(pair);
          const endRange = (valueNode ?? keyNode).range;
          map.range = [keyNode.range[0], endRange[1], endRange[2]];
          coll.items.push(map);
        }
        offset = valueNode ? valueNode.range[2] : valueProps.end;
      }
    }
    const expectedEnd = isMap ? "}" : "]";
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce?.source === expectedEnd)
      cePos = ce.offset + ce.source.length;
    else {
      const name = fcName[0].toUpperCase() + fcName.substring(1);
      const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
      onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
      if (ce && ce.source.length !== 1)
        ee.unshift(ce);
    }
    if (ee.length > 0) {
      const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
      if (end.comment) {
        if (coll.comment)
          coll.comment += `
` + end.comment;
        else
          coll.comment = end.comment;
      }
      coll.range = [fc.offset, cePos, end.offset];
    } else {
      coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
  }
  exports.resolveFlowCollection = resolveFlowCollection;
});

// node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveBlockMap = require_resolve_block_map();
  var resolveBlockSeq = require_resolve_block_seq();
  var resolveFlowCollection = require_resolve_flow_collection();
  function resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    if (tagName === "!" || tagName === Coll.tagName) {
      coll.tag = Coll.tagName;
      return coll;
    }
    if (tagName)
      coll.tag = tagName;
    return coll;
  }
  function composeCollection(CN, ctx, token, props, onError) {
    const tagToken = props.tag;
    const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
    if (token.type === "block-seq") {
      const { anchor, newlineAfterProp: nl } = props;
      const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
      if (lastProp && (!nl || nl.offset < lastProp.offset)) {
        const message = "Missing newline after block sequence props";
        onError(lastProp, "MISSING_CHAR", message);
      }
    }
    const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
    if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
      return resolveCollection(CN, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
    if (!tag) {
      const kt = ctx.schema.knownTags[tagName];
      if (kt?.collection === expType) {
        ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
        tag = kt;
      } else {
        if (kt) {
          onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
        } else {
          onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
        }
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
    const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
      node.format = tag.format;
    return node;
  }
  exports.composeCollection = composeCollection;
});

// node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function resolveBlockScalar(ctx, scalar, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
    if (!header)
      return { value: "", type: null, comment: "", range: [start, start, start] };
    const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    let chompStart = lines.length;
    for (let i = lines.length - 1;i >= 0; --i) {
      const content = lines[i][1];
      if (content === "" || content === "\r")
        chompStart = i;
      else
        break;
    }
    if (chompStart === 0) {
      const value2 = header.chomp === "+" && lines.length > 0 ? `
`.repeat(Math.max(1, lines.length - 1)) : "";
      let end2 = start + header.length;
      if (scalar.source)
        end2 += scalar.source.length;
      return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
    }
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0;i < chompStart; ++i) {
      const [indent, content] = lines[i];
      if (content === "" || content === "\r") {
        if (header.indent === 0 && indent.length > trimIndent)
          trimIndent = indent.length;
      } else {
        if (indent.length < trimIndent) {
          const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
          onError(offset + indent.length, "MISSING_CHAR", message);
        }
        if (header.indent === 0)
          trimIndent = indent.length;
        contentStart = i;
        if (trimIndent === 0 && !ctx.atRoot) {
          const message = "Block scalar values in collections must be indented";
          onError(offset, "BAD_INDENT", message);
        }
        break;
      }
      offset += indent.length + content.length + 1;
    }
    for (let i = lines.length - 1;i >= chompStart; --i) {
      if (lines[i][0].length > trimIndent)
        chompStart = i + 1;
    }
    let value = "";
    let sep = "";
    let prevMoreIndented = false;
    for (let i = 0;i < contentStart; ++i)
      value += lines[i][0].slice(trimIndent) + `
`;
    for (let i = contentStart;i < chompStart; ++i) {
      let [indent, content] = lines[i];
      offset += indent.length + content.length + 1;
      const crlf = content[content.length - 1] === "\r";
      if (crlf)
        content = content.slice(0, -1);
      if (content && indent.length < trimIndent) {
        const src = header.indent ? "explicit indentation indicator" : "first line";
        const message = `Block scalar lines must not be less indented than their ${src}`;
        onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
        indent = "";
      }
      if (type === Scalar.Scalar.BLOCK_LITERAL) {
        value += sep + indent.slice(trimIndent) + content;
        sep = `
`;
      } else if (indent.length > trimIndent || content[0] === "\t") {
        if (sep === " ")
          sep = `
`;
        else if (!prevMoreIndented && sep === `
`)
          sep = `

`;
        value += sep + indent.slice(trimIndent) + content;
        sep = `
`;
        prevMoreIndented = true;
      } else if (content === "") {
        if (sep === `
`)
          value += `
`;
        else
          sep = `
`;
      } else {
        value += sep + content;
        sep = " ";
        prevMoreIndented = false;
      }
    }
    switch (header.chomp) {
      case "-":
        break;
      case "+":
        for (let i = chompStart;i < lines.length; ++i)
          value += `
` + lines[i][0].slice(trimIndent);
        if (value[value.length - 1] !== `
`)
          value += `
`;
        break;
      default:
        value += `
`;
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
  }
  function parseBlockScalarHeader({ offset, props }, strict, onError) {
    if (props[0].type !== "block-scalar-header") {
      onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
      return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = "";
    let error = -1;
    for (let i = 1;i < source.length; ++i) {
      const ch = source[i];
      if (!chomp && (ch === "-" || ch === "+"))
        chomp = ch;
      else {
        const n = Number(ch);
        if (!indent && n)
          indent = n;
        else if (error === -1)
          error = offset + i;
      }
    }
    if (error !== -1)
      onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = "";
    let length = source.length;
    for (let i = 1;i < props.length; ++i) {
      const token = props[i];
      switch (token.type) {
        case "space":
          hasSpace = true;
        case "newline":
          length += token.source.length;
          break;
        case "comment":
          if (strict && !hasSpace) {
            const message = "Comments must be separated from other tokens by white space characters";
            onError(token, "MISSING_CHAR", message);
          }
          length += token.source.length;
          comment = token.source.substring(1);
          break;
        case "error":
          onError(token, "UNEXPECTED_TOKEN", token.message);
          length += token.source.length;
          break;
        default: {
          const message = `Unexpected token in block scalar header: ${token.type}`;
          onError(token, "UNEXPECTED_TOKEN", message);
          const ts = token.source;
          if (ts && typeof ts === "string")
            length += ts.length;
        }
      }
    }
    return { mode, indent, chomp, comment, length };
  }
  function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
    const lines = [line0];
    for (let i = 1;i < split.length; i += 2)
      lines.push([split[i], split[i + 1]]);
    return lines;
  }
  exports.resolveBlockScalar = resolveBlockScalar;
});

// node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var resolveEnd = require_resolve_end();
  function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
      case "scalar":
        _type = Scalar.Scalar.PLAIN;
        value = plainValue(source, _onError);
        break;
      case "single-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_SINGLE;
        value = singleQuotedValue(source, _onError);
        break;
      case "double-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_DOUBLE;
        value = doubleQuotedValue(source, _onError);
        break;
      default:
        onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
        return {
          value: "",
          type: null,
          comment: "",
          range: [offset, offset + source.length, offset + source.length]
        };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
    return {
      value,
      type: _type,
      comment: re.comment,
      range: [offset, valueEnd, re.offset]
    };
  }
  function plainValue(source, onError) {
    let badChar = "";
    switch (source[0]) {
      case "\t":
        badChar = "a tab character";
        break;
      case ",":
        badChar = "flow indicator character ,";
        break;
      case "%":
        badChar = "directive indicator character %";
        break;
      case "|":
      case ">": {
        badChar = `block scalar indicator ${source[0]}`;
        break;
      }
      case "@":
      case "`": {
        badChar = `reserved character ${source[0]}`;
        break;
      }
    }
    if (badChar)
      onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
    return foldLines(source);
  }
  function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
      onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
  }
  function foldLines(source) {
    let first, line;
    try {
      first = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy");
      line = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
    } catch {
      first = /(.*?)[ \t]*\r?\n/sy;
      line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
      return source;
    let res = match[1];
    let sep = " ";
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while (match = line.exec(source)) {
      if (match[1] === "") {
        if (sep === `
`)
          res += sep;
        else
          sep = `
`;
      } else {
        res += sep + match[1];
        sep = " ";
      }
      pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? "");
  }
  function doubleQuotedValue(source, onError) {
    let res = "";
    for (let i = 1;i < source.length - 1; ++i) {
      const ch = source[i];
      if (ch === "\r" && source[i + 1] === `
`)
        continue;
      if (ch === `
`) {
        const { fold, offset } = foldNewline(source, i);
        res += fold;
        i = offset;
      } else if (ch === "\\") {
        let next = source[++i];
        const cc = escapeCodes[next];
        if (cc)
          res += cc;
        else if (next === `
`) {
          next = source[i + 1];
          while (next === " " || next === "\t")
            next = source[++i + 1];
        } else if (next === "\r" && source[i + 1] === `
`) {
          next = source[++i + 1];
          while (next === " " || next === "\t")
            next = source[++i + 1];
        } else if (next === "x" || next === "u" || next === "U") {
          const length = { x: 2, u: 4, U: 8 }[next];
          res += parseCharCode(source, i + 1, length, onError);
          i += length;
        } else {
          const raw = source.substr(i - 1, 2);
          onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
          res += raw;
        }
      } else if (ch === " " || ch === "\t") {
        const wsStart = i;
        let next = source[i + 1];
        while (next === " " || next === "\t")
          next = source[++i + 1];
        if (next !== `
` && !(next === "\r" && source[i + 2] === `
`))
          res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
      } else {
        res += ch;
      }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
      onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
    return res;
  }
  function foldNewline(source, offset) {
    let fold = "";
    let ch = source[offset + 1];
    while (ch === " " || ch === "\t" || ch === `
` || ch === "\r") {
      if (ch === "\r" && source[offset + 2] !== `
`)
        break;
      if (ch === `
`)
        fold += `
`;
      offset += 1;
      ch = source[offset + 1];
    }
    if (!fold)
      fold = " ";
    return { fold, offset };
  }
  var escapeCodes = {
    "0": "\x00",
    a: "\x07",
    b: "\b",
    e: "\x1B",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "\t",
    v: "\v",
    N: "\x85",
    _: "\xA0",
    L: "\u2028",
    P: "\u2029",
    " ": " ",
    '"': '"',
    "/": "/",
    "\\": "\\",
    "\t": "\t"
  };
  function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
      const raw = source.substr(offset - 2, length + 2);
      onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
      return raw;
    }
    return String.fromCodePoint(code);
  }
  exports.resolveFlowScalar = resolveFlowScalar;
});

// node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
    let tag;
    if (ctx.options.stringKeys && ctx.atKey) {
      tag = ctx.schema[identity.SCALAR];
    } else if (tagName)
      tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
    else if (token.type === "scalar")
      tag = findScalarTagByTest(ctx, value, token, onError);
    else
      tag = ctx.schema[identity.SCALAR];
    let scalar;
    try {
      const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
      scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
      scalar = new Scalar.Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
      scalar.type = type;
    if (tagName)
      scalar.tag = tagName;
    if (tag.format)
      scalar.format = tag.format;
    if (comment)
      scalar.comment = comment;
    return scalar;
  }
  function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === "!")
      return schema[identity.SCALAR];
    const matchWithTest = [];
    for (const tag of schema.tags) {
      if (!tag.collection && tag.tag === tagName) {
        if (tag.default && tag.test)
          matchWithTest.push(tag);
        else
          return tag;
      }
    }
    for (const tag of matchWithTest)
      if (tag.test?.test(value))
        return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
      schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
      return kt;
    }
    onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
    return schema[identity.SCALAR];
  }
  function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
    const tag = schema.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema[identity.SCALAR];
    if (schema.compat) {
      const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema[identity.SCALAR];
      if (tag.tag !== compat.tag) {
        const ts = directives.tagString(tag.tag);
        const cs = directives.tagString(compat.tag);
        const msg = `Value may be parsed as either ${ts} or ${cs}`;
        onError(token, "TAG_RESOLVE_FAILED", msg, true);
      }
    }
    return tag;
  }
  exports.composeScalar = composeScalar;
});

// node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS((exports) => {
  function emptyScalarPosition(offset, before, pos) {
    if (before) {
      pos ?? (pos = before.length);
      for (let i = pos - 1;i >= 0; --i) {
        let st = before[i];
        switch (st.type) {
          case "space":
          case "comment":
          case "newline":
            offset -= st.source.length;
            continue;
        }
        st = before[++i];
        while (st?.type === "space") {
          offset += st.source.length;
          st = before[++i];
        }
        break;
      }
    }
    return offset;
  }
  exports.emptyScalarPosition = emptyScalarPosition;
});

// node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity = require_identity();
  var composeCollection = require_compose_collection();
  var composeScalar = require_compose_scalar();
  var resolveEnd = require_resolve_end();
  var utilEmptyScalarPosition = require_util_empty_scalar_position();
  var CN = { composeNode, composeEmptyNode };
  function composeNode(ctx, token, props, onError) {
    const atKey = ctx.atKey;
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
      case "alias":
        node = composeAlias(ctx, token, onError);
        if (anchor || tag)
          onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
        break;
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "block-scalar":
        node = composeScalar.composeScalar(ctx, token, tag, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      case "block-map":
      case "block-seq":
      case "flow-collection":
        node = composeCollection.composeCollection(CN, ctx, token, props, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      default: {
        const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
        onError(token, "UNEXPECTED_TOKEN", message);
        node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
        isSrcToken = false;
      }
    }
    if (anchor && node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
      const msg = "With stringKeys, all keys must be strings";
      onError(tag ?? token, "NON_STRING_KEY", msg);
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      if (token.type === "scalar" && token.source === "")
        node.comment = comment;
      else
        node.commentBefore = comment;
    }
    if (ctx.options.keepSourceTokens && isSrcToken)
      node.srcToken = token;
    return node;
  }
  function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
      type: "scalar",
      offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
      indent: -1,
      source: ""
    };
    const node = composeScalar.composeScalar(ctx, token, tag, onError);
    if (anchor) {
      node.anchor = anchor.source.substring(1);
      if (node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      node.comment = comment;
      node.range[2] = end;
    }
    return node;
  }
  function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias.Alias(source.substring(1));
    if (alias.source === "")
      onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
    if (alias.source.endsWith(":"))
      onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
      alias.comment = re.comment;
    return alias;
  }
  exports.composeEmptyNode = composeEmptyNode;
  exports.composeNode = composeNode;
});

// node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS((exports) => {
  var Document = require_Document();
  var composeNode = require_compose_node();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document.Document(undefined, opts);
    const ctx = {
      atKey: false,
      atRoot: true,
      directives: doc.directives,
      options: doc.options,
      schema: doc.schema
    };
    const props = resolveProps.resolveProps(start, {
      indicator: "doc-start",
      next: value ?? end?.[0],
      offset,
      onError,
      parentIndent: 0,
      startOnNewline: true
    });
    if (props.found) {
      doc.directives.docStart = true;
      if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
        onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
    }
    doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
      doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
  }
  exports.composeDoc = composeDoc;
});

// node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS((exports) => {
  var node_process = __require("process");
  var directives = require_directives();
  var Document = require_Document();
  var errors2 = require_errors();
  var identity = require_identity();
  var composeDoc = require_compose_doc();
  var resolveEnd = require_resolve_end();
  function getErrorPos(src) {
    if (typeof src === "number")
      return [src, src + 1];
    if (Array.isArray(src))
      return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === "string" ? source.length : 1)];
  }
  function parsePrelude(prelude) {
    let comment = "";
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0;i < prelude.length; ++i) {
      const source = prelude[i];
      switch (source[0]) {
        case "#":
          comment += (comment === "" ? "" : afterEmptyLine ? `

` : `
`) + (source.substring(1) || " ");
          atComment = true;
          afterEmptyLine = false;
          break;
        case "%":
          if (prelude[i + 1]?.[0] !== "#")
            i += 1;
          atComment = false;
          break;
        default:
          if (!atComment)
            afterEmptyLine = true;
          atComment = false;
      }
    }
    return { comment, afterEmptyLine };
  }

  class Composer {
    constructor(options = {}) {
      this.doc = null;
      this.atDirectives = false;
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
      this.onError = (source, code, message, warning) => {
        const pos = getErrorPos(source);
        if (warning)
          this.warnings.push(new errors2.YAMLWarning(pos, code, message));
        else
          this.errors.push(new errors2.YAMLParseError(pos, code, message));
      };
      this.directives = new directives.Directives({ version: options.version || "1.2" });
      this.options = options;
    }
    decorate(doc, afterDoc) {
      const { comment, afterEmptyLine } = parsePrelude(this.prelude);
      if (comment) {
        const dc = doc.contents;
        if (afterDoc) {
          doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
        } else if (afterEmptyLine || doc.directives.docStart || !dc) {
          doc.commentBefore = comment;
        } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
          let it = dc.items[0];
          if (identity.isPair(it))
            it = it.key;
          const cb = it.commentBefore;
          it.commentBefore = cb ? `${comment}
${cb}` : comment;
        } else {
          const cb = dc.commentBefore;
          dc.commentBefore = cb ? `${comment}
${cb}` : comment;
        }
      }
      if (afterDoc) {
        Array.prototype.push.apply(doc.errors, this.errors);
        Array.prototype.push.apply(doc.warnings, this.warnings);
      } else {
        doc.errors = this.errors;
        doc.warnings = this.warnings;
      }
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
    }
    streamInfo() {
      return {
        comment: parsePrelude(this.prelude).comment,
        directives: this.directives,
        errors: this.errors,
        warnings: this.warnings
      };
    }
    *compose(tokens, forceDoc = false, endOffset = -1) {
      for (const token of tokens)
        yield* this.next(token);
      yield* this.end(forceDoc, endOffset);
    }
    *next(token) {
      if (node_process.env.LOG_STREAM)
        console.dir(token, { depth: null });
      switch (token.type) {
        case "directive":
          this.directives.add(token.source, (offset, message, warning) => {
            const pos = getErrorPos(token);
            pos[0] += offset;
            this.onError(pos, "BAD_DIRECTIVE", message, warning);
          });
          this.prelude.push(token.source);
          this.atDirectives = true;
          break;
        case "document": {
          const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
          if (this.atDirectives && !doc.directives.docStart)
            this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
          this.decorate(doc, false);
          if (this.doc)
            yield this.doc;
          this.doc = doc;
          this.atDirectives = false;
          break;
        }
        case "byte-order-mark":
        case "space":
          break;
        case "comment":
        case "newline":
          this.prelude.push(token.source);
          break;
        case "error": {
          const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
          const error = new errors2.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
          if (this.atDirectives || !this.doc)
            this.errors.push(error);
          else
            this.doc.errors.push(error);
          break;
        }
        case "doc-end": {
          if (!this.doc) {
            const msg = "Unexpected doc-end without preceding document";
            this.errors.push(new errors2.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
            break;
          }
          this.doc.directives.docEnd = true;
          const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
          this.decorate(this.doc, true);
          if (end.comment) {
            const dc = this.doc.comment;
            this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
          }
          this.doc.range[2] = end.offset;
          break;
        }
        default:
          this.errors.push(new errors2.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
      }
    }
    *end(forceDoc = false, endOffset = -1) {
      if (this.doc) {
        this.decorate(this.doc, true);
        yield this.doc;
        this.doc = null;
      } else if (forceDoc) {
        const opts = Object.assign({ _directives: this.directives }, this.options);
        const doc = new Document.Document(undefined, opts);
        if (this.atDirectives)
          this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
        doc.range = [0, endOffset, endOffset];
        this.decorate(doc, false);
        yield doc;
      }
    }
  }
  exports.Composer = Composer;
});

// node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS((exports) => {
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  var errors2 = require_errors();
  var stringifyString = require_stringifyString();
  function resolveAsScalar(token, strict = true, onError) {
    if (token) {
      const _onError = (pos, code, message) => {
        const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
        if (onError)
          onError(offset, code, message);
        else
          throw new errors2.YAMLParseError([offset, offset + 1], code, message);
      };
      switch (token.type) {
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
        case "block-scalar":
          return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
      }
    }
    return null;
  }
  function createScalarToken(value, context) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey,
      indent: indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    const end = context.end ?? [
      { type: "newline", offset: -1, indent, source: `
` }
    ];
    switch (source[0]) {
      case "|":
      case ">": {
        const he = source.indexOf(`
`);
        const head = source.substring(0, he);
        const body = source.substring(he + 1) + `
`;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, end))
          props.push({ type: "newline", offset: -1, indent, source: `
` });
        return { type: "block-scalar", offset, indent, props, source: body };
      }
      case '"':
        return { type: "double-quoted-scalar", offset, indent, source, end };
      case "'":
        return { type: "single-quoted-scalar", offset, indent, source, end };
      default:
        return { type: "scalar", offset, indent, source, end };
    }
  }
  function setScalarValue(token, value, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = "indent" in token ? token.indent : null;
    if (afterKey && typeof indent === "number")
      indent += 2;
    if (!type)
      switch (token.type) {
        case "single-quoted-scalar":
          type = "QUOTE_SINGLE";
          break;
        case "double-quoted-scalar":
          type = "QUOTE_DOUBLE";
          break;
        case "block-scalar": {
          const header = token.props[0];
          if (header.type !== "block-scalar-header")
            throw new Error("Invalid block scalar header");
          type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
          break;
        }
        default:
          type = "PLAIN";
      }
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey: implicitKey || indent === null,
      indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
      case "|":
      case ">":
        setBlockScalarValue(token, source);
        break;
      case '"':
        setFlowScalarValue(token, source, "double-quoted-scalar");
        break;
      case "'":
        setFlowScalarValue(token, source, "single-quoted-scalar");
        break;
      default:
        setFlowScalarValue(token, source, "scalar");
    }
  }
  function setBlockScalarValue(token, source) {
    const he = source.indexOf(`
`);
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + `
`;
    if (token.type === "block-scalar") {
      const header = token.props[0];
      if (header.type !== "block-scalar-header")
        throw new Error("Invalid block scalar header");
      header.source = head;
      token.source = body;
    } else {
      const { offset } = token;
      const indent = "indent" in token ? token.indent : -1;
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, "end" in token ? token.end : undefined))
        props.push({ type: "newline", offset: -1, indent, source: `
` });
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type: "block-scalar", indent, props, source: body });
    }
  }
  function addEndtoBlockProps(props, end) {
    if (end)
      for (const st of end)
        switch (st.type) {
          case "space":
          case "comment":
            props.push(st);
            break;
          case "newline":
            props.push(st);
            return true;
        }
    return false;
  }
  function setFlowScalarValue(token, source, type) {
    switch (token.type) {
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        token.type = type;
        token.source = source;
        break;
      case "block-scalar": {
        const end = token.props.slice(1);
        let oa = source.length;
        if (token.props[0].type === "block-scalar-header")
          oa -= token.props[0].source.length;
        for (const tok of end)
          tok.offset += oa;
        delete token.props;
        Object.assign(token, { type, source, end });
        break;
      }
      case "block-map":
      case "block-seq": {
        const offset = token.offset + source.length;
        const nl = { type: "newline", offset, indent: token.indent, source: `
` };
        delete token.items;
        Object.assign(token, { type, source, end: [nl] });
        break;
      }
      default: {
        const indent = "indent" in token ? token.indent : -1;
        const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type, indent, source, end });
      }
    }
  }
  exports.createScalarToken = createScalarToken;
  exports.resolveAsScalar = resolveAsScalar;
  exports.setScalarValue = setScalarValue;
});

// node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS((exports) => {
  var stringify = (cst) => ("type" in cst) ? stringifyToken(cst) : stringifyItem(cst);
  function stringifyToken(token) {
    switch (token.type) {
      case "block-scalar": {
        let res = "";
        for (const tok of token.props)
          res += stringifyToken(tok);
        return res + token.source;
      }
      case "block-map":
      case "block-seq": {
        let res = "";
        for (const item of token.items)
          res += stringifyItem(item);
        return res;
      }
      case "flow-collection": {
        let res = token.start.source;
        for (const item of token.items)
          res += stringifyItem(item);
        for (const st of token.end)
          res += st.source;
        return res;
      }
      case "document": {
        let res = stringifyItem(token);
        if (token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
      default: {
        let res = token.source;
        if ("end" in token && token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
    }
  }
  function stringifyItem({ start, key, sep, value }) {
    let res = "";
    for (const st of start)
      res += st.source;
    if (key)
      res += stringifyToken(key);
    if (sep)
      for (const st of sep)
        res += st.source;
    if (value)
      res += stringifyToken(value);
    return res;
  }
  exports.stringify = stringify;
});

// node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS((exports) => {
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove item");
  function visit(cst, visitor) {
    if ("type" in cst && cst.type === "document")
      cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
      const tok = item?.[field];
      if (tok && "items" in tok) {
        item = tok.items[index];
      } else
        return;
    }
    return item;
  };
  visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && "items" in coll)
      return coll;
    throw new Error("Parent collection not found");
  };
  function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === "symbol")
      return ctrl;
    for (const field of ["key", "value"]) {
      const token = item[field];
      if (token && "items" in token) {
        for (let i = 0;i < token.items.length; ++i) {
          const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            token.items.splice(i, 1);
            i -= 1;
          }
        }
        if (typeof ctrl === "function" && field === "key")
          ctrl = ctrl(item, path);
      }
    }
    return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
  }
  exports.visit = visit;
});

// node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS((exports) => {
  var cstScalar = require_cst_scalar();
  var cstStringify = require_cst_stringify();
  var cstVisit = require_cst_visit();
  var BOM = "\uFEFF";
  var DOCUMENT = "\x02";
  var FLOW_END = "\x18";
  var SCALAR = "\x1F";
  var isCollection = (token) => !!token && ("items" in token);
  var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
  function prettyToken(token) {
    switch (token) {
      case BOM:
        return "<BOM>";
      case DOCUMENT:
        return "<DOC>";
      case FLOW_END:
        return "<FLOW_END>";
      case SCALAR:
        return "<SCALAR>";
      default:
        return JSON.stringify(token);
    }
  }
  function tokenType(source) {
    switch (source) {
      case BOM:
        return "byte-order-mark";
      case DOCUMENT:
        return "doc-mode";
      case FLOW_END:
        return "flow-error-end";
      case SCALAR:
        return "scalar";
      case "---":
        return "doc-start";
      case "...":
        return "doc-end";
      case "":
      case `
`:
      case `\r
`:
        return "newline";
      case "-":
        return "seq-item-ind";
      case "?":
        return "explicit-key-ind";
      case ":":
        return "map-value-ind";
      case "{":
        return "flow-map-start";
      case "}":
        return "flow-map-end";
      case "[":
        return "flow-seq-start";
      case "]":
        return "flow-seq-end";
      case ",":
        return "comma";
    }
    switch (source[0]) {
      case " ":
      case "\t":
        return "space";
      case "#":
        return "comment";
      case "%":
        return "directive-line";
      case "*":
        return "alias";
      case "&":
        return "anchor";
      case "!":
        return "tag";
      case "'":
        return "single-quoted-scalar";
      case '"':
        return "double-quoted-scalar";
      case "|":
      case ">":
        return "block-scalar-header";
    }
    return null;
  }
  exports.createScalarToken = cstScalar.createScalarToken;
  exports.resolveAsScalar = cstScalar.resolveAsScalar;
  exports.setScalarValue = cstScalar.setScalarValue;
  exports.stringify = cstStringify.stringify;
  exports.visit = cstVisit.visit;
  exports.BOM = BOM;
  exports.DOCUMENT = DOCUMENT;
  exports.FLOW_END = FLOW_END;
  exports.SCALAR = SCALAR;
  exports.isCollection = isCollection;
  exports.isScalar = isScalar;
  exports.prettyToken = prettyToken;
  exports.tokenType = tokenType;
});

// node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS((exports) => {
  var cst = require_cst();
  function isEmpty(ch) {
    switch (ch) {
      case undefined:
      case " ":
      case `
`:
      case "\r":
      case "\t":
        return true;
      default:
        return false;
    }
  }
  var hexDigits = new Set("0123456789ABCDEFabcdef");
  var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
  var flowIndicatorChars = new Set(",[]{}");
  var invalidAnchorChars = new Set(` ,[]{}
\r	`);
  var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);

  class Lexer {
    constructor() {
      this.atEnd = false;
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      this.buffer = "";
      this.flowKey = false;
      this.flowLevel = 0;
      this.indentNext = 0;
      this.indentValue = 0;
      this.lineEndPos = null;
      this.next = null;
      this.pos = 0;
    }
    *lex(source, incomplete = false) {
      if (source) {
        if (typeof source !== "string")
          throw TypeError("source is not a string");
        this.buffer = this.buffer ? this.buffer + source : source;
        this.lineEndPos = null;
      }
      this.atEnd = !incomplete;
      let next = this.next ?? "stream";
      while (next && (incomplete || this.hasChars(1)))
        next = yield* this.parseNext(next);
    }
    atLineEnd() {
      let i = this.pos;
      let ch = this.buffer[i];
      while (ch === " " || ch === "\t")
        ch = this.buffer[++i];
      if (!ch || ch === "#" || ch === `
`)
        return true;
      if (ch === "\r")
        return this.buffer[i + 1] === `
`;
      return false;
    }
    charAt(n) {
      return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
      let ch = this.buffer[offset];
      if (this.indentNext > 0) {
        let indent = 0;
        while (ch === " ")
          ch = this.buffer[++indent + offset];
        if (ch === "\r") {
          const next = this.buffer[indent + offset + 1];
          if (next === `
` || !next && !this.atEnd)
            return offset + indent + 1;
        }
        return ch === `
` || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
      }
      if (ch === "-" || ch === ".") {
        const dt = this.buffer.substr(offset, 3);
        if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
          return -1;
      }
      return offset;
    }
    getLine() {
      let end = this.lineEndPos;
      if (typeof end !== "number" || end !== -1 && end < this.pos) {
        end = this.buffer.indexOf(`
`, this.pos);
        this.lineEndPos = end;
      }
      if (end === -1)
        return this.atEnd ? this.buffer.substring(this.pos) : null;
      if (this.buffer[end - 1] === "\r")
        end -= 1;
      return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
      return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
      this.buffer = this.buffer.substring(this.pos);
      this.pos = 0;
      this.lineEndPos = null;
      this.next = state;
      return null;
    }
    peek(n) {
      return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
      switch (next) {
        case "stream":
          return yield* this.parseStream();
        case "line-start":
          return yield* this.parseLineStart();
        case "block-start":
          return yield* this.parseBlockStart();
        case "doc":
          return yield* this.parseDocument();
        case "flow":
          return yield* this.parseFlowCollection();
        case "quoted-scalar":
          return yield* this.parseQuotedScalar();
        case "block-scalar":
          return yield* this.parseBlockScalar();
        case "plain-scalar":
          return yield* this.parsePlainScalar();
      }
    }
    *parseStream() {
      let line = this.getLine();
      if (line === null)
        return this.setNext("stream");
      if (line[0] === cst.BOM) {
        yield* this.pushCount(1);
        line = line.substring(1);
      }
      if (line[0] === "%") {
        let dirEnd = line.length;
        let cs = line.indexOf("#");
        while (cs !== -1) {
          const ch = line[cs - 1];
          if (ch === " " || ch === "\t") {
            dirEnd = cs - 1;
            break;
          } else {
            cs = line.indexOf("#", cs + 1);
          }
        }
        while (true) {
          const ch = line[dirEnd - 1];
          if (ch === " " || ch === "\t")
            dirEnd -= 1;
          else
            break;
        }
        const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
        yield* this.pushCount(line.length - n);
        this.pushNewline();
        return "stream";
      }
      if (this.atLineEnd()) {
        const sp = yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - sp);
        yield* this.pushNewline();
        return "stream";
      }
      yield cst.DOCUMENT;
      return yield* this.parseLineStart();
    }
    *parseLineStart() {
      const ch = this.charAt(0);
      if (!ch && !this.atEnd)
        return this.setNext("line-start");
      if (ch === "-" || ch === ".") {
        if (!this.atEnd && !this.hasChars(4))
          return this.setNext("line-start");
        const s = this.peek(3);
        if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
          yield* this.pushCount(3);
          this.indentValue = 0;
          this.indentNext = 0;
          return s === "---" ? "doc" : "stream";
        }
      }
      this.indentValue = yield* this.pushSpaces(false);
      if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
        this.indentNext = this.indentValue;
      return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
      const [ch0, ch1] = this.peek(2);
      if (!ch1 && !this.atEnd)
        return this.setNext("block-start");
      if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
        const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
        this.indentNext = this.indentValue + 1;
        this.indentValue += n;
        return yield* this.parseBlockStart();
      }
      return "doc";
    }
    *parseDocument() {
      yield* this.pushSpaces(true);
      const line = this.getLine();
      if (line === null)
        return this.setNext("doc");
      let n = yield* this.pushIndicators();
      switch (line[n]) {
        case "#":
          yield* this.pushCount(line.length - n);
        case undefined:
          yield* this.pushNewline();
          return yield* this.parseLineStart();
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel = 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          return "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "doc";
        case '"':
        case "'":
          return yield* this.parseQuotedScalar();
        case "|":
        case ">":
          n += yield* this.parseBlockScalarHeader();
          n += yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - n);
          yield* this.pushNewline();
          return yield* this.parseBlockScalar();
        default:
          return yield* this.parsePlainScalar();
      }
    }
    *parseFlowCollection() {
      let nl, sp;
      let indent = -1;
      do {
        nl = yield* this.pushNewline();
        if (nl > 0) {
          sp = yield* this.pushSpaces(false);
          this.indentValue = indent = sp;
        } else {
          sp = 0;
        }
        sp += yield* this.pushSpaces(true);
      } while (nl + sp > 0);
      const line = this.getLine();
      if (line === null)
        return this.setNext("flow");
      if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
        const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
        if (!atFlowEndMarker) {
          this.flowLevel = 0;
          yield cst.FLOW_END;
          return yield* this.parseLineStart();
        }
      }
      let n = 0;
      while (line[n] === ",") {
        n += yield* this.pushCount(1);
        n += yield* this.pushSpaces(true);
        this.flowKey = false;
      }
      n += yield* this.pushIndicators();
      switch (line[n]) {
        case undefined:
          return "flow";
        case "#":
          yield* this.pushCount(line.length - n);
          return "flow";
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel += 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          this.flowKey = true;
          this.flowLevel -= 1;
          return this.flowLevel ? "flow" : "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "flow";
        case '"':
        case "'":
          this.flowKey = true;
          return yield* this.parseQuotedScalar();
        case ":": {
          const next = this.charAt(1);
          if (this.flowKey || isEmpty(next) || next === ",") {
            this.flowKey = false;
            yield* this.pushCount(1);
            yield* this.pushSpaces(true);
            return "flow";
          }
        }
        default:
          this.flowKey = false;
          return yield* this.parsePlainScalar();
      }
    }
    *parseQuotedScalar() {
      const quote = this.charAt(0);
      let end = this.buffer.indexOf(quote, this.pos + 1);
      if (quote === "'") {
        while (end !== -1 && this.buffer[end + 1] === "'")
          end = this.buffer.indexOf("'", end + 2);
      } else {
        while (end !== -1) {
          let n = 0;
          while (this.buffer[end - 1 - n] === "\\")
            n += 1;
          if (n % 2 === 0)
            break;
          end = this.buffer.indexOf('"', end + 1);
        }
      }
      const qb = this.buffer.substring(0, end);
      let nl = qb.indexOf(`
`, this.pos);
      if (nl !== -1) {
        while (nl !== -1) {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = qb.indexOf(`
`, cs);
        }
        if (nl !== -1) {
          end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
        }
      }
      if (end === -1) {
        if (!this.atEnd)
          return this.setNext("quoted-scalar");
        end = this.buffer.length;
      }
      yield* this.pushToIndex(end + 1, false);
      return this.flowLevel ? "flow" : "doc";
    }
    *parseBlockScalarHeader() {
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      let i = this.pos;
      while (true) {
        const ch = this.buffer[++i];
        if (ch === "+")
          this.blockScalarKeep = true;
        else if (ch > "0" && ch <= "9")
          this.blockScalarIndent = Number(ch) - 1;
        else if (ch !== "-")
          break;
      }
      return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
    }
    *parseBlockScalar() {
      let nl = this.pos - 1;
      let indent = 0;
      let ch;
      loop:
        for (let i2 = this.pos;ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case `
`:
              nl = i2;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i2 + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === `
`)
                break;
            }
            default:
              break loop;
          }
        }
      if (!ch && !this.atEnd)
        return this.setNext("block-scalar");
      if (indent >= this.indentNext) {
        if (this.blockScalarIndent === -1)
          this.indentNext = indent;
        else {
          this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
        }
        do {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = this.buffer.indexOf(`
`, cs);
        } while (nl !== -1);
        if (nl === -1) {
          if (!this.atEnd)
            return this.setNext("block-scalar");
          nl = this.buffer.length;
        }
      }
      let i = nl + 1;
      ch = this.buffer[i];
      while (ch === " ")
        ch = this.buffer[++i];
      if (ch === "\t") {
        while (ch === "\t" || ch === " " || ch === "\r" || ch === `
`)
          ch = this.buffer[++i];
        nl = i - 1;
      } else if (!this.blockScalarKeep) {
        do {
          let i2 = nl - 1;
          let ch2 = this.buffer[i2];
          if (ch2 === "\r")
            ch2 = this.buffer[--i2];
          const lastChar = i2;
          while (ch2 === " ")
            ch2 = this.buffer[--i2];
          if (ch2 === `
` && i2 >= this.pos && i2 + 1 + indent > lastChar)
            nl = i2;
          else
            break;
        } while (true);
      }
      yield cst.SCALAR;
      yield* this.pushToIndex(nl + 1, true);
      return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
      const inFlow = this.flowLevel > 0;
      let end = this.pos - 1;
      let i = this.pos - 1;
      let ch;
      while (ch = this.buffer[++i]) {
        if (ch === ":") {
          const next = this.buffer[i + 1];
          if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
            break;
          end = i;
        } else if (isEmpty(ch)) {
          let next = this.buffer[i + 1];
          if (ch === "\r") {
            if (next === `
`) {
              i += 1;
              ch = `
`;
              next = this.buffer[i + 1];
            } else
              end = i;
          }
          if (next === "#" || inFlow && flowIndicatorChars.has(next))
            break;
          if (ch === `
`) {
            const cs = this.continueScalar(i + 1);
            if (cs === -1)
              break;
            i = Math.max(i, cs - 2);
          }
        } else {
          if (inFlow && flowIndicatorChars.has(ch))
            break;
          end = i;
        }
      }
      if (!ch && !this.atEnd)
        return this.setNext("plain-scalar");
      yield cst.SCALAR;
      yield* this.pushToIndex(end + 1, true);
      return inFlow ? "flow" : "doc";
    }
    *pushCount(n) {
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos += n;
        return n;
      }
      return 0;
    }
    *pushToIndex(i, allowEmpty) {
      const s = this.buffer.slice(this.pos, i);
      if (s) {
        yield s;
        this.pos += s.length;
        return s.length;
      } else if (allowEmpty)
        yield "";
      return 0;
    }
    *pushIndicators() {
      switch (this.charAt(0)) {
        case "!":
          return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "&":
          return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "-":
        case "?":
        case ":": {
          const inFlow = this.flowLevel > 0;
          const ch1 = this.charAt(1);
          if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
            if (!inFlow)
              this.indentNext = this.indentValue + 1;
            else if (this.flowKey)
              this.flowKey = false;
            return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          }
        }
      }
      return 0;
    }
    *pushTag() {
      if (this.charAt(1) === "<") {
        let i = this.pos + 2;
        let ch = this.buffer[i];
        while (!isEmpty(ch) && ch !== ">")
          ch = this.buffer[++i];
        return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
      } else {
        let i = this.pos + 1;
        let ch = this.buffer[i];
        while (ch) {
          if (tagChars.has(ch))
            ch = this.buffer[++i];
          else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
            ch = this.buffer[i += 3];
          } else
            break;
        }
        return yield* this.pushToIndex(i, false);
      }
    }
    *pushNewline() {
      const ch = this.buffer[this.pos];
      if (ch === `
`)
        return yield* this.pushCount(1);
      else if (ch === "\r" && this.charAt(1) === `
`)
        return yield* this.pushCount(2);
      else
        return 0;
    }
    *pushSpaces(allowTabs) {
      let i = this.pos - 1;
      let ch;
      do {
        ch = this.buffer[++i];
      } while (ch === " " || allowTabs && ch === "\t");
      const n = i - this.pos;
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos = i;
      }
      return n;
    }
    *pushUntil(test) {
      let i = this.pos;
      let ch = this.buffer[i];
      while (!test(ch))
        ch = this.buffer[++i];
      return yield* this.pushToIndex(i, false);
    }
  }
  exports.Lexer = Lexer;
});

// node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS((exports) => {
  class LineCounter {
    constructor() {
      this.lineStarts = [];
      this.addNewLine = (offset) => this.lineStarts.push(offset);
      this.linePos = (offset) => {
        let low = 0;
        let high = this.lineStarts.length;
        while (low < high) {
          const mid = low + high >> 1;
          if (this.lineStarts[mid] < offset)
            low = mid + 1;
          else
            high = mid;
        }
        if (this.lineStarts[low] === offset)
          return { line: low + 1, col: 1 };
        if (low === 0)
          return { line: 0, col: offset };
        const start = this.lineStarts[low - 1];
        return { line: low, col: offset - start + 1 };
      };
    }
  }
  exports.LineCounter = LineCounter;
});

// node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS((exports) => {
  var node_process = __require("process");
  var cst = require_cst();
  var lexer = require_lexer();
  function includesToken(list, type) {
    for (let i = 0;i < list.length; ++i)
      if (list[i].type === type)
        return true;
    return false;
  }
  function findNonEmptyIndex(list) {
    for (let i = 0;i < list.length; ++i) {
      switch (list[i].type) {
        case "space":
        case "comment":
        case "newline":
          break;
        default:
          return i;
      }
    }
    return -1;
  }
  function isFlowToken(token) {
    switch (token?.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "flow-collection":
        return true;
      default:
        return false;
    }
  }
  function getPrevProps(parent) {
    switch (parent.type) {
      case "document":
        return parent.start;
      case "block-map": {
        const it = parent.items[parent.items.length - 1];
        return it.sep ?? it.start;
      }
      case "block-seq":
        return parent.items[parent.items.length - 1].start;
      default:
        return [];
    }
  }
  function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
      return [];
    let i = prev.length;
    loop:
      while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
    while (prev[++i]?.type === "space") {}
    return prev.splice(i, prev.length);
  }
  function fixFlowSeqItems(fc) {
    if (fc.start.type === "flow-seq-start") {
      for (const it of fc.items) {
        if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
          if (it.key)
            it.value = it.key;
          delete it.key;
          if (isFlowToken(it.value)) {
            if (it.value.end)
              Array.prototype.push.apply(it.value.end, it.sep);
            else
              it.value.end = it.sep;
          } else
            Array.prototype.push.apply(it.start, it.sep);
          delete it.sep;
        }
      }
    }
  }

  class Parser {
    constructor(onNewLine) {
      this.atNewLine = true;
      this.atScalar = false;
      this.indent = 0;
      this.offset = 0;
      this.onKeyLine = false;
      this.stack = [];
      this.source = "";
      this.type = "";
      this.lexer = new lexer.Lexer;
      this.onNewLine = onNewLine;
    }
    *parse(source, incomplete = false) {
      if (this.onNewLine && this.offset === 0)
        this.onNewLine(0);
      for (const lexeme of this.lexer.lex(source, incomplete))
        yield* this.next(lexeme);
      if (!incomplete)
        yield* this.end();
    }
    *next(source) {
      this.source = source;
      if (node_process.env.LOG_TOKENS)
        console.log("|", cst.prettyToken(source));
      if (this.atScalar) {
        this.atScalar = false;
        yield* this.step();
        this.offset += source.length;
        return;
      }
      const type = cst.tokenType(source);
      if (!type) {
        const message = `Not a YAML token: ${source}`;
        yield* this.pop({ type: "error", offset: this.offset, message, source });
        this.offset += source.length;
      } else if (type === "scalar") {
        this.atNewLine = false;
        this.atScalar = true;
        this.type = "scalar";
      } else {
        this.type = type;
        yield* this.step();
        switch (type) {
          case "newline":
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine)
              this.onNewLine(this.offset + source.length);
            break;
          case "space":
            if (this.atNewLine && source[0] === " ")
              this.indent += source.length;
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            if (this.atNewLine)
              this.indent += source.length;
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = false;
        }
        this.offset += source.length;
      }
    }
    *end() {
      while (this.stack.length > 0)
        yield* this.pop();
    }
    get sourceToken() {
      const st = {
        type: this.type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
      return st;
    }
    *step() {
      const top = this.peek(1);
      if (this.type === "doc-end" && top?.type !== "doc-end") {
        while (this.stack.length > 0)
          yield* this.pop();
        this.stack.push({
          type: "doc-end",
          offset: this.offset,
          source: this.source
        });
        return;
      }
      if (!top)
        return yield* this.stream();
      switch (top.type) {
        case "document":
          return yield* this.document(top);
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return yield* this.scalar(top);
        case "block-scalar":
          return yield* this.blockScalar(top);
        case "block-map":
          return yield* this.blockMap(top);
        case "block-seq":
          return yield* this.blockSequence(top);
        case "flow-collection":
          return yield* this.flowCollection(top);
        case "doc-end":
          return yield* this.documentEnd(top);
      }
      yield* this.pop();
    }
    peek(n) {
      return this.stack[this.stack.length - n];
    }
    *pop(error) {
      const token = error ?? this.stack.pop();
      if (!token) {
        const message = "Tried to pop an empty stack";
        yield { type: "error", offset: this.offset, source: "", message };
      } else if (this.stack.length === 0) {
        yield token;
      } else {
        const top = this.peek(1);
        if (token.type === "block-scalar") {
          token.indent = "indent" in top ? top.indent : 0;
        } else if (token.type === "flow-collection" && top.type === "document") {
          token.indent = 0;
        }
        if (token.type === "flow-collection")
          fixFlowSeqItems(token);
        switch (top.type) {
          case "document":
            top.value = token;
            break;
          case "block-scalar":
            top.props.push(token);
            break;
          case "block-map": {
            const it = top.items[top.items.length - 1];
            if (it.value) {
              top.items.push({ start: [], key: token, sep: [] });
              this.onKeyLine = true;
              return;
            } else if (it.sep) {
              it.value = token;
            } else {
              Object.assign(it, { key: token, sep: [] });
              this.onKeyLine = !it.explicitKey;
              return;
            }
            break;
          }
          case "block-seq": {
            const it = top.items[top.items.length - 1];
            if (it.value)
              top.items.push({ start: [], value: token });
            else
              it.value = token;
            break;
          }
          case "flow-collection": {
            const it = top.items[top.items.length - 1];
            if (!it || it.value)
              top.items.push({ start: [], key: token, sep: [] });
            else if (it.sep)
              it.value = token;
            else
              Object.assign(it, { key: token, sep: [] });
            return;
          }
          default:
            yield* this.pop();
            yield* this.pop(token);
        }
        if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
          const last = token.items[token.items.length - 1];
          if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
            if (top.type === "document")
              top.end = last.start;
            else
              top.items.push({ start: last.start });
            token.items.splice(-1, 1);
          }
        }
      }
    }
    *stream() {
      switch (this.type) {
        case "directive-line":
          yield { type: "directive", offset: this.offset, source: this.source };
          return;
        case "byte-order-mark":
        case "space":
        case "comment":
        case "newline":
          yield this.sourceToken;
          return;
        case "doc-mode":
        case "doc-start": {
          const doc = {
            type: "document",
            offset: this.offset,
            start: []
          };
          if (this.type === "doc-start")
            doc.start.push(this.sourceToken);
          this.stack.push(doc);
          return;
        }
      }
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML stream`,
        source: this.source
      };
    }
    *document(doc) {
      if (doc.value)
        return yield* this.lineEnd(doc);
      switch (this.type) {
        case "doc-start": {
          if (findNonEmptyIndex(doc.start) !== -1) {
            yield* this.pop();
            yield* this.step();
          } else
            doc.start.push(this.sourceToken);
          return;
        }
        case "anchor":
        case "tag":
        case "space":
        case "comment":
        case "newline":
          doc.start.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(doc);
      if (bv)
        this.stack.push(bv);
      else {
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML document`,
          source: this.source
        };
      }
    }
    *scalar(scalar) {
      if (this.type === "map-value-ind") {
        const prev = getPrevProps(this.peek(2));
        const start = getFirstKeyStartProps(prev);
        let sep;
        if (scalar.end) {
          sep = scalar.end;
          sep.push(this.sourceToken);
          delete scalar.end;
        } else
          sep = [this.sourceToken];
        const map = {
          type: "block-map",
          offset: scalar.offset,
          indent: scalar.indent,
          items: [{ start, key: scalar, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map;
      } else
        yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
      switch (this.type) {
        case "space":
        case "comment":
        case "newline":
          scalar.props.push(this.sourceToken);
          return;
        case "scalar":
          scalar.source = this.source;
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine) {
            let nl = this.source.indexOf(`
`) + 1;
            while (nl !== 0) {
              this.onNewLine(this.offset + nl);
              nl = this.source.indexOf(`
`, nl) + 1;
            }
          }
          yield* this.pop();
          break;
        default:
          yield* this.pop();
          yield* this.step();
      }
    }
    *blockMap(map) {
      const it = map.items[map.items.length - 1];
      switch (this.type) {
        case "newline":
          this.onKeyLine = false;
          if (it.value) {
            const end = "end" in it.value ? it.value.end : undefined;
            const last = Array.isArray(end) ? end[end.length - 1] : undefined;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              map.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "space":
        case "comment":
          if (it.value) {
            map.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            if (this.atIndentedComment(it.start, map.indent)) {
              const prev = map.items[map.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                map.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
      }
      if (this.indent >= map.indent) {
        const atMapIndent = !this.onKeyLine && this.indent === map.indent;
        const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
        let start = [];
        if (atNextItem && it.sep && !it.value) {
          const nl = [];
          for (let i = 0;i < it.sep.length; ++i) {
            const st = it.sep[i];
            switch (st.type) {
              case "newline":
                nl.push(i);
                break;
              case "space":
                break;
              case "comment":
                if (st.indent > map.indent)
                  nl.length = 0;
                break;
              default:
                nl.length = 0;
            }
          }
          if (nl.length >= 2)
            start = it.sep.splice(nl[1]);
        }
        switch (this.type) {
          case "anchor":
          case "tag":
            if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map.items.push({ start });
              this.onKeyLine = true;
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "explicit-key-ind":
            if (!it.sep && !it.explicitKey) {
              it.start.push(this.sourceToken);
              it.explicitKey = true;
            } else if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map.items.push({ start, explicitKey: true });
            } else {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [this.sourceToken], explicitKey: true }]
              });
            }
            this.onKeyLine = true;
            return;
          case "map-value-ind":
            if (it.explicitKey) {
              if (!it.sep) {
                if (includesToken(it.start, "newline")) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else {
                  const start2 = getFirstKeyStartProps(it.start);
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                  });
                }
              } else if (it.value) {
                map.items.push({ start: [], key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start, key: null, sep: [this.sourceToken] }]
                });
              } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                const start2 = getFirstKeyStartProps(it.start);
                const key = it.key;
                const sep = it.sep;
                sep.push(this.sourceToken);
                delete it.key;
                delete it.sep;
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key, sep }]
                });
              } else if (start.length > 0) {
                it.sep = it.sep.concat(start, this.sourceToken);
              } else {
                it.sep.push(this.sourceToken);
              }
            } else {
              if (!it.sep) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else if (it.value || atNextItem) {
                map.items.push({ start, key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [], key: null, sep: [this.sourceToken] }]
                });
              } else {
                it.sep.push(this.sourceToken);
              }
            }
            this.onKeyLine = true;
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (atNextItem || it.value) {
              map.items.push({ start, key: fs, sep: [] });
              this.onKeyLine = true;
            } else if (it.sep) {
              this.stack.push(fs);
            } else {
              Object.assign(it, { key: fs, sep: [] });
              this.onKeyLine = true;
            }
            return;
          }
          default: {
            const bv = this.startBlockValue(map);
            if (bv) {
              if (bv.type === "block-seq") {
                if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                  yield* this.pop({
                    type: "error",
                    offset: this.offset,
                    message: "Unexpected block-seq-ind on same line with key",
                    source: this.source
                  });
                  return;
                }
              } else if (atMapIndent) {
                map.items.push({ start });
              }
              this.stack.push(bv);
              return;
            }
          }
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *blockSequence(seq) {
      const it = seq.items[seq.items.length - 1];
      switch (this.type) {
        case "newline":
          if (it.value) {
            const end = "end" in it.value ? it.value.end : undefined;
            const last = Array.isArray(end) ? end[end.length - 1] : undefined;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              seq.items.push({ start: [this.sourceToken] });
          } else
            it.start.push(this.sourceToken);
          return;
        case "space":
        case "comment":
          if (it.value)
            seq.items.push({ start: [this.sourceToken] });
          else {
            if (this.atIndentedComment(it.start, seq.indent)) {
              const prev = seq.items[seq.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                seq.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
        case "anchor":
        case "tag":
          if (it.value || this.indent <= seq.indent)
            break;
          it.start.push(this.sourceToken);
          return;
        case "seq-item-ind":
          if (this.indent !== seq.indent)
            break;
          if (it.value || includesToken(it.start, "seq-item-ind"))
            seq.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
      }
      if (this.indent > seq.indent) {
        const bv = this.startBlockValue(seq);
        if (bv) {
          this.stack.push(bv);
          return;
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *flowCollection(fc) {
      const it = fc.items[fc.items.length - 1];
      if (this.type === "flow-error-end") {
        let top;
        do {
          yield* this.pop();
          top = this.peek(1);
        } while (top?.type === "flow-collection");
      } else if (fc.end.length === 0) {
        switch (this.type) {
          case "comma":
          case "explicit-key-ind":
            if (!it || it.sep)
              fc.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
          case "map-value-ind":
            if (!it || it.value)
              fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            return;
          case "space":
          case "comment":
          case "newline":
          case "anchor":
          case "tag":
            if (!it || it.value)
              fc.items.push({ start: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              it.start.push(this.sourceToken);
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (!it || it.value)
              fc.items.push({ start: [], key: fs, sep: [] });
            else if (it.sep)
              this.stack.push(fs);
            else
              Object.assign(it, { key: fs, sep: [] });
            return;
          }
          case "flow-map-end":
          case "flow-seq-end":
            fc.end.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(fc);
        if (bv)
          this.stack.push(bv);
        else {
          yield* this.pop();
          yield* this.step();
        }
      } else {
        const parent = this.peek(2);
        if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
          yield* this.pop();
          yield* this.step();
        } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          fixFlowSeqItems(fc);
          const sep = fc.end.splice(1, fc.end.length);
          sep.push(this.sourceToken);
          const map = {
            type: "block-map",
            offset: fc.offset,
            indent: fc.indent,
            items: [{ start, key: fc, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else {
          yield* this.lineEnd(fc);
        }
      }
    }
    flowScalar(type) {
      if (this.onNewLine) {
        let nl = this.source.indexOf(`
`) + 1;
        while (nl !== 0) {
          this.onNewLine(this.offset + nl);
          nl = this.source.indexOf(`
`, nl) + 1;
        }
      }
      return {
        type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
    }
    startBlockValue(parent) {
      switch (this.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return this.flowScalar(this.type);
        case "block-scalar-header":
          return {
            type: "block-scalar",
            offset: this.offset,
            indent: this.indent,
            props: [this.sourceToken],
            source: ""
          };
        case "flow-map-start":
        case "flow-seq-start":
          return {
            type: "flow-collection",
            offset: this.offset,
            indent: this.indent,
            start: this.sourceToken,
            items: [],
            end: []
          };
        case "seq-item-ind":
          return {
            type: "block-seq",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken] }]
          };
        case "explicit-key-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          start.push(this.sourceToken);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start, explicitKey: true }]
          };
        }
        case "map-value-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start, key: null, sep: [this.sourceToken] }]
          };
        }
      }
      return null;
    }
    atIndentedComment(start, indent) {
      if (this.type !== "comment")
        return false;
      if (this.indent <= indent)
        return false;
      return start.every((st) => st.type === "newline" || st.type === "space");
    }
    *documentEnd(docEnd) {
      if (this.type !== "doc-mode") {
        if (docEnd.end)
          docEnd.end.push(this.sourceToken);
        else
          docEnd.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
      }
    }
    *lineEnd(token) {
      switch (this.type) {
        case "comma":
        case "doc-start":
        case "doc-end":
        case "flow-seq-end":
        case "flow-map-end":
        case "map-value-ind":
          yield* this.pop();
          yield* this.step();
          break;
        case "newline":
          this.onKeyLine = false;
        case "space":
        case "comment":
        default:
          if (token.end)
            token.end.push(this.sourceToken);
          else
            token.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
      }
    }
  }
  exports.Parser = Parser;
});

// node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS((exports) => {
  var composer = require_composer();
  var Document = require_Document();
  var errors2 = require_errors();
  var log = require_log();
  var identity = require_identity();
  var lineCounter = require_line_counter();
  var parser = require_parser();
  function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter || null;
    return { lineCounter: lineCounter$1, prettyErrors };
  }
  function parseAllDocuments(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter2)
      for (const doc of docs) {
        doc.errors.forEach(errors2.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors2.prettifyError(source, lineCounter2));
      }
    if (docs.length > 0)
      return docs;
    return Object.assign([], { empty: true }, composer$1.streamInfo());
  }
  function parseDocument(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options);
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
      if (!doc)
        doc = _doc;
      else if (doc.options.logLevel !== "silent") {
        doc.errors.push(new errors2.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
        break;
      }
    }
    if (prettyErrors && lineCounter2) {
      doc.errors.forEach(errors2.prettifyError(source, lineCounter2));
      doc.warnings.forEach(errors2.prettifyError(source, lineCounter2));
    }
    return doc;
  }
  function parse(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === "function") {
      _reviver = reviver;
    } else if (options === undefined && reviver && typeof reviver === "object") {
      options = reviver;
    }
    const doc = parseDocument(src, options);
    if (!doc)
      return null;
    doc.warnings.forEach((warning) => log.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
      if (doc.options.logLevel !== "silent")
        throw doc.errors[0];
      else
        doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
  }
  function stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === undefined && replacer) {
      options = replacer;
    }
    if (typeof options === "string")
      options = options.length;
    if (typeof options === "number") {
      const indent = Math.round(options);
      options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === undefined) {
      const { keepUndefined } = options ?? replacer ?? {};
      if (!keepUndefined)
        return;
    }
    if (identity.isDocument(value) && !_replacer)
      return value.toString(options);
    return new Document.Document(value, _replacer, options).toString(options);
  }
  exports.parse = parse;
  exports.parseAllDocuments = parseAllDocuments;
  exports.parseDocument = parseDocument;
  exports.stringify = stringify;
});

// node_modules/yaml/dist/index.js
var composer, Document, Schema, errors2, Alias, identity, Pair, Scalar, YAMLMap, YAMLSeq, cst, lexer, lineCounter, parser, publicApi, visit, $Composer, $Document, $Schema, $YAMLError, $YAMLParseError, $YAMLWarning, $Alias, $isAlias, $isCollection, $isDocument, $isMap, $isNode, $isPair, $isScalar, $isSeq, $Pair, $Scalar, $YAMLMap, $YAMLSeq, $Lexer, $LineCounter, $Parser, $parse, $parseAllDocuments, $parseDocument, $stringify, $visit, $visitAsync;
var init_dist = __esm(() => {
  composer = require_composer();
  Document = require_Document();
  Schema = require_Schema();
  errors2 = require_errors();
  Alias = require_Alias();
  identity = require_identity();
  Pair = require_Pair();
  Scalar = require_Scalar();
  YAMLMap = require_YAMLMap();
  YAMLSeq = require_YAMLSeq();
  cst = require_cst();
  lexer = require_lexer();
  lineCounter = require_line_counter();
  parser = require_parser();
  publicApi = require_public_api();
  visit = require_visit();
  $Composer = composer.Composer;
  $Document = Document.Document;
  $Schema = Schema.Schema;
  $YAMLError = errors2.YAMLError;
  $YAMLParseError = errors2.YAMLParseError;
  $YAMLWarning = errors2.YAMLWarning;
  $Alias = Alias.Alias;
  $isAlias = identity.isAlias;
  $isCollection = identity.isCollection;
  $isDocument = identity.isDocument;
  $isMap = identity.isMap;
  $isNode = identity.isNode;
  $isPair = identity.isPair;
  $isScalar = identity.isScalar;
  $isSeq = identity.isSeq;
  $Pair = Pair.Pair;
  $Scalar = Scalar.Scalar;
  $YAMLMap = YAMLMap.YAMLMap;
  $YAMLSeq = YAMLSeq.YAMLSeq;
  $Lexer = lexer.Lexer;
  $LineCounter = lineCounter.LineCounter;
  $Parser = parser.Parser;
  $parse = publicApi.parse;
  $parseAllDocuments = publicApi.parseAllDocuments;
  $parseDocument = publicApi.parseDocument;
  $stringify = publicApi.stringify;
  $visit = visit.visit;
  $visitAsync = visit.visitAsync;
});

// src/config/errors.ts
function formatZodIssue(issue) {
  const path = issue.path.length > 0 ? issue.path.join(".") : "(root)";
  return `  - ${path}: ${issue.message}`;
}
var KarimoConfigError, ConfigNotFoundError, ConfigReadError, ConfigParseError, ConfigValidationError;
var init_errors5 = __esm(() => {
  KarimoConfigError = class KarimoConfigError extends Error {
    constructor(message) {
      super(message);
      this.name = "KarimoConfigError";
    }
  };
  ConfigNotFoundError = class ConfigNotFoundError extends KarimoConfigError {
    searchedFrom;
    searchedFor;
    constructor(searchedFrom, searchedFor = ".karimo/config.yaml") {
      super(`Configuration file not found.
  Searched from: ${searchedFrom}
  Looking for: ${searchedFor}

Run 'karimo init' to create a configuration file.`);
      this.searchedFrom = searchedFrom;
      this.searchedFor = searchedFor;
      this.name = "ConfigNotFoundError";
    }
  };
  ConfigReadError = class ConfigReadError extends KarimoConfigError {
    originalError;
    constructor(configPath, originalError) {
      super(`Failed to read configuration file.
  Path: ${configPath}
  Reason: ${originalError.message}

Check file permissions and ensure the file is accessible.`);
      this.name = "ConfigReadError";
      this.originalError = originalError;
    }
  };
  ConfigParseError = class ConfigParseError extends KarimoConfigError {
    originalError;
    constructor(configPath, originalError) {
      super(`Invalid YAML syntax in configuration file.
  Path: ${configPath}
  Reason: ${originalError.message}

Fix the YAML syntax errors and try again.`);
      this.name = "ConfigParseError";
      this.originalError = originalError;
    }
  };
  ConfigValidationError = class ConfigValidationError extends KarimoConfigError {
    configPath;
    zodError;
    issues;
    constructor(configPath, zodError) {
      const issueList = zodError.issues.map(formatZodIssue).join(`
`);
      super(`Configuration validation failed.
  Path: ${configPath}
  Issues:
${issueList}

Fix the configuration values and try again.`);
      this.configPath = configPath;
      this.zodError = zodError;
      this.name = "ConfigValidationError";
      this.issues = zodError.issues;
    }
    getFieldPaths() {
      return this.issues.map((issue) => issue.path.join("."));
    }
  };
});

// src/config/loader.ts
import { readFileSync, statSync } from "fs";
import { dirname, join as join2, resolve } from "path";
function fileExistsSync(path) {
  try {
    const stat = statSync(path);
    return stat.isFile();
  } catch {
    return false;
  }
}
function findConfigPath(startDir) {
  const searchFrom = startDir ? resolve(startDir) : process.cwd();
  let currentDir = searchFrom;
  while (true) {
    const configPath = join2(currentDir, CONFIG_DIR, CONFIG_FILE);
    if (fileExistsSync(configPath)) {
      return {
        configPath,
        rootDir: currentDir
      };
    }
    const parentDir = dirname(currentDir);
    if (parentDir === currentDir) {
      throw new ConfigNotFoundError(searchFrom);
    }
    currentDir = parentDir;
  }
}
async function readConfigFile(configPath) {
  let content;
  try {
    const file = Bun.file(configPath);
    content = await file.text();
  } catch (error) {
    throw new ConfigReadError(configPath, error);
  }
  try {
    return $parse(content);
  } catch (error) {
    throw new ConfigParseError(configPath, error);
  }
}
function readConfigFileSync(configPath) {
  let content;
  try {
    content = readFileSync(configPath, "utf-8");
  } catch (error) {
    throw new ConfigReadError(configPath, error);
  }
  try {
    return $parse(content);
  } catch (error) {
    throw new ConfigParseError(configPath, error);
  }
}
function validateConfig(data, configPath) {
  const result = KarimoConfigSchema.safeParse(data);
  if (!result.success) {
    throw new ConfigValidationError(configPath, result.error);
  }
  return result.data;
}
async function loadConfig(startDir) {
  const { configPath, rootDir } = findConfigPath(startDir);
  const data = await readConfigFile(configPath);
  const config = validateConfig(data, configPath);
  return { config, configPath, rootDir };
}
function loadConfigSync(startDir) {
  const { configPath, rootDir } = findConfigPath(startDir);
  const data = readConfigFileSync(configPath);
  const config = validateConfig(data, configPath);
  return { config, configPath, rootDir };
}
var CONFIG_DIR = ".karimo", CONFIG_FILE = "config.yaml";
var init_loader = __esm(() => {
  init_dist();
  init_errors5();
  init_schema();
});

// src/config/defaults.ts
var DEFAULT_COST, DEFAULT_BOUNDARIES, DEFAULT_FALLBACK_ENGINE, COMMON_ALLOWED_ENV;
var init_defaults = __esm(() => {
  DEFAULT_COST = {
    model_preference: "sonnet",
    cost_multiplier: 3,
    base_iterations: 5,
    iteration_multiplier: 3,
    revision_budget_percent: 50,
    max_revision_loops: 3,
    abort_on_fatal: true,
    fallback_cost_per_minute: 0.5,
    phase_budget_cap: null,
    phase_budget_overflow: 0.1,
    session_budget_cap: null,
    budget_warning_threshold: 0.75
  };
  DEFAULT_BOUNDARIES = {
    never_touch: [],
    require_review: []
  };
  DEFAULT_FALLBACK_ENGINE = {
    enabled: false,
    engines: [],
    trigger_on: ["rate-limit", "quota-exceeded"]
  };
  COMMON_ALLOWED_ENV = [
    "PATH",
    "HOME",
    "USER",
    "SHELL",
    "TERM",
    "LANG",
    "NODE_ENV",
    "CI"
  ];
});

// src/config/detect/types.ts
function high(value, source, reasoning) {
  const result = { value, confidence: "high", source };
  if (reasoning !== undefined) {
    result.reasoning = reasoning;
  }
  return result;
}
function medium(value, source, reasoning) {
  const result = { value, confidence: "medium", source };
  if (reasoning !== undefined) {
    result.reasoning = reasoning;
  }
  return result;
}

// src/config/detect/boundaries.ts
import { existsSync } from "fs";
import { join as join3 } from "path";
function detectNeverTouch(targetDir, _pkg) {
  const patterns = [];
  for (const item of ALWAYS_NEVER_TOUCH) {
    patterns.push(high(item.pattern, item.source, "Critical file that should never be modified"));
  }
  if (existsSync(join3(targetDir, "supabase", "migrations"))) {
    patterns.push(high("supabase/migrations/*.sql", "supabase/migrations/", "Existing database migrations are immutable"));
  }
  if (existsSync(join3(targetDir, "prisma", "migrations"))) {
    patterns.push(high("prisma/migrations/**", "prisma/migrations/", "Existing database migrations are immutable"));
  }
  if (existsSync(join3(targetDir, ".github", "workflows"))) {
    patterns.push(medium(".github/workflows/*.yml", ".github/workflows/", "CI/CD workflows require careful review"));
    patterns.push(medium(".github/workflows/*.yaml", ".github/workflows/", "CI/CD workflows require careful review"));
  }
  if (existsSync(join3(targetDir, "Dockerfile"))) {
    patterns.push(medium("Dockerfile", "Dockerfile", "Container configuration is critical"));
  }
  if (existsSync(join3(targetDir, "docker-compose.yml")) || existsSync(join3(targetDir, "docker-compose.yaml"))) {
    patterns.push(medium("docker-compose*.yml", "docker-compose.yml", "Container orchestration is critical"));
  }
  if (existsSync(join3(targetDir, "terraform")) || existsSync(join3(targetDir, "infra"))) {
    const infraDir = existsSync(join3(targetDir, "terraform")) ? "terraform" : "infra";
    patterns.push(high(`${infraDir}/**/*.tf`, `${infraDir}/`, "Infrastructure as code requires careful review"));
  }
  return patterns;
}
function detectRequireReview(targetDir, pkg) {
  const patterns = [];
  const deps = { ...pkg?.dependencies, ...pkg?.devDependencies };
  if (deps["next"]) {
    if (existsSync(join3(targetDir, "middleware.ts"))) {
      patterns.push(high("middleware.ts", "middleware.ts", "Route protection and request handling"));
    }
    if (existsSync(join3(targetDir, "src", "middleware.ts"))) {
      patterns.push(high("src/middleware.ts", "src/middleware.ts", "Route protection and request handling"));
    }
    if (existsSync(join3(targetDir, "app", "layout.tsx"))) {
      patterns.push(medium("app/layout.tsx", "app/layout.tsx", "Root layout affects all pages"));
    }
    if (existsSync(join3(targetDir, "src", "app", "layout.tsx"))) {
      patterns.push(medium("src/app/layout.tsx", "src/app/layout.tsx", "Root layout affects all pages"));
    }
    const nextConfigs = ["next.config.js", "next.config.mjs", "next.config.ts"];
    for (const config of nextConfigs) {
      if (existsSync(join3(targetDir, config))) {
        patterns.push(medium(config, config, "Build configuration affects entire application"));
        break;
      }
    }
  }
  const authPatterns = [
    { dir: "auth", pattern: "auth/**", reason: "Authentication logic" },
    { dir: "lib/auth", pattern: "lib/auth/**", reason: "Authentication logic" },
    { dir: "src/auth", pattern: "src/auth/**", reason: "Authentication logic" },
    { dir: "src/lib/auth", pattern: "src/lib/auth/**", reason: "Authentication logic" }
  ];
  for (const auth of authPatterns) {
    if (existsSync(join3(targetDir, auth.dir))) {
      patterns.push(high(auth.pattern, auth.dir, auth.reason));
      break;
    }
  }
  const securityFiles = [
    { file: "security.ts", reason: "Security configuration" },
    { file: "src/security.ts", reason: "Security configuration" },
    { file: "lib/security.ts", reason: "Security configuration" }
  ];
  for (const sec of securityFiles) {
    if (existsSync(join3(targetDir, sec.file))) {
      patterns.push(high(sec.file, sec.file, sec.reason));
    }
  }
  if (existsSync(join3(targetDir, "prisma", "schema.prisma"))) {
    patterns.push(medium("prisma/schema.prisma", "prisma/schema.prisma", "Database schema changes require careful review"));
  }
  if (existsSync(join3(targetDir, "drizzle"))) {
    patterns.push(medium("drizzle/schema.ts", "drizzle/", "Database schema changes require careful review"));
  }
  if (existsSync(join3(targetDir, "app", "api"))) {
    patterns.push(medium("app/api/**/route.ts", "app/api/", "API routes handle external requests"));
  }
  if (existsSync(join3(targetDir, "src", "app", "api"))) {
    patterns.push(medium("src/app/api/**/route.ts", "src/app/api/", "API routes handle external requests"));
  }
  if (existsSync(join3(targetDir, "pages", "api"))) {
    patterns.push(medium("pages/api/**/*.ts", "pages/api/", "API routes handle external requests"));
  }
  return patterns;
}
function detectBoundaries(targetDir, pkg) {
  return {
    never_touch: detectNeverTouch(targetDir, pkg),
    require_review: detectRequireReview(targetDir, pkg)
  };
}
var ALWAYS_NEVER_TOUCH;
var init_boundaries = __esm(() => {
  ALWAYS_NEVER_TOUCH = [
    { pattern: "*.lock", source: "lockfiles" },
    { pattern: "*.lockb", source: "lockfiles" },
    { pattern: ".env", source: "environment files" },
    { pattern: ".env.*", source: "environment files" },
    { pattern: ".karimo/config.yaml", source: "KARIMO config" }
  ];
});

// src/config/detect/commands.ts
import { existsSync as existsSync2 } from "fs";
import { join as join4 } from "path";
function detectPackageManager(targetDir, pkg) {
  if (existsSync2(join4(targetDir, "bun.lockb")) || existsSync2(join4(targetDir, "bun.lock"))) {
    return "bun";
  }
  if (existsSync2(join4(targetDir, "pnpm-lock.yaml"))) {
    return "pnpm";
  }
  if (existsSync2(join4(targetDir, "yarn.lock"))) {
    return "yarn";
  }
  if (existsSync2(join4(targetDir, "deno.json")) || existsSync2(join4(targetDir, "deno.jsonc"))) {
    return "deno";
  }
  if (pkg?.packageManager) {
    const pm = pkg.packageManager.toLowerCase();
    if (pm.startsWith("bun"))
      return "bun";
    if (pm.startsWith("pnpm"))
      return "pnpm";
    if (pm.startsWith("yarn"))
      return "yarn";
  }
  if (pkg?.engines?.["bun"])
    return "bun";
  return "npm";
}
function getRunPrefix(pm) {
  switch (pm) {
    case "bun":
      return "bun run";
    case "pnpm":
      return "pnpm run";
    case "yarn":
      return "yarn";
    case "deno":
      return "deno task";
    default:
      return "npm run";
  }
}
function getTestCommand(pm) {
  switch (pm) {
    case "bun":
      return "bun test";
    case "deno":
      return "deno test";
    case "pnpm":
      return "pnpm test";
    case "yarn":
      return "yarn test";
    default:
      return "npm test";
  }
}
function detectBuildCommand(targetDir, pkg, pm) {
  const scripts = pkg?.scripts ?? {};
  const prefix = getRunPrefix(pm);
  if (scripts["build"]) {
    return high(`${prefix} build`, "package.json scripts.build");
  }
  if (existsSync2(join4(targetDir, "next.config.js")) || existsSync2(join4(targetDir, "next.config.mjs")) || existsSync2(join4(targetDir, "next.config.ts"))) {
    return medium(pm === "bun" ? "bun run next build" : "npx next build", "next.config.*", "Next.js project detected");
  }
  if (existsSync2(join4(targetDir, "tsconfig.json"))) {
    return medium(`${prefix === "bun run" ? "bun" : prefix} tsc`, "tsconfig.json", "TypeScript project");
  }
  return null;
}
function detectLintCommand(targetDir, pkg, pm) {
  const scripts = pkg?.scripts ?? {};
  const prefix = getRunPrefix(pm);
  if (scripts["lint"]) {
    return high(`${prefix} lint`, "package.json scripts.lint");
  }
  if (existsSync2(join4(targetDir, "biome.json")) || existsSync2(join4(targetDir, "biome.jsonc"))) {
    const biomeCmd = pm === "bun" ? "bunx @biomejs/biome check ." : "npx @biomejs/biome check .";
    return medium(biomeCmd, "biome.json", "Biome config found");
  }
  const eslintConfigs = [
    ".eslintrc",
    ".eslintrc.js",
    ".eslintrc.cjs",
    ".eslintrc.json",
    ".eslintrc.yaml",
    ".eslintrc.yml",
    "eslint.config.js",
    "eslint.config.mjs",
    "eslint.config.cjs"
  ];
  for (const config of eslintConfigs) {
    if (existsSync2(join4(targetDir, config))) {
      const eslintCmd = pm === "bun" ? "bunx eslint ." : "npx eslint .";
      return medium(eslintCmd, config, "ESLint config found");
    }
  }
  if (pm === "deno") {
    return medium("deno lint", "deno runtime", "Deno built-in linter");
  }
  return null;
}
function detectTestCommand(targetDir, pkg, pm) {
  const scripts = pkg?.scripts ?? {};
  const deps = { ...pkg?.dependencies, ...pkg?.devDependencies };
  if (scripts["test"] && scripts["test"] !== 'echo "Error: no test specified" && exit 1') {
    return high(getTestCommand(pm), "package.json scripts.test");
  }
  if (deps["vitest"]) {
    const vitestCmd = pm === "bun" ? "bunx vitest run" : "npx vitest run";
    return high(vitestCmd, "package.json", "Vitest in dependencies");
  }
  if (deps["jest"]) {
    const jestCmd = pm === "bun" ? "bunx jest" : "npx jest";
    return high(jestCmd, "package.json", "Jest in dependencies");
  }
  if (pm === "bun") {
    const testPatterns = ["**/*.test.ts", "**/*.test.tsx", "**/*.spec.ts", "**/*.test.js"];
    for (const pattern of testPatterns) {
      try {
        const glob = new Bun.Glob(pattern);
        for (const _file of glob.scanSync({
          cwd: targetDir,
          onlyFiles: true,
          absolute: false
        })) {
          return medium("bun test", "test files", "Test files found, Bun runtime");
        }
      } catch {}
    }
  }
  if (pm === "deno") {
    return medium("deno test", "deno runtime", "Deno built-in test runner");
  }
  return null;
}
function detectTypecheckCommand(targetDir, pkg, pm) {
  const scripts = pkg?.scripts ?? {};
  const prefix = getRunPrefix(pm);
  if (scripts["typecheck"]) {
    return high(`${prefix} typecheck`, "package.json scripts.typecheck");
  }
  if (scripts["type-check"]) {
    return high(`${prefix} type-check`, "package.json scripts.type-check");
  }
  if (existsSync2(join4(targetDir, "tsconfig.json"))) {
    const tscCmd = pm === "bun" ? "bunx tsc --noEmit" : "npx tsc --noEmit";
    return medium(tscCmd, "tsconfig.json", "TypeScript project");
  }
  if (pm === "deno") {
    return medium("deno check .", "deno runtime", "Deno type checker");
  }
  return null;
}
function detectCommands(targetDir, pkg) {
  const pm = detectPackageManager(targetDir, pkg);
  return {
    build: detectBuildCommand(targetDir, pkg, pm),
    lint: detectLintCommand(targetDir, pkg, pm),
    test: detectTestCommand(targetDir, pkg, pm),
    typecheck: detectTypecheckCommand(targetDir, pkg, pm)
  };
}
var init_commands = () => {};

// src/config/detect/project.ts
import { existsSync as existsSync3 } from "fs";
import { basename, join as join5 } from "path";
function detectName(targetDir, pkg) {
  if (pkg?.name && typeof pkg.name === "string" && pkg.name.trim()) {
    return high(pkg.name, "package.json", "Name field in package.json");
  }
  const dirName = basename(targetDir);
  if (dirName && dirName !== "." && dirName !== "/") {
    return medium(dirName, "directory name", "Inferred from project directory");
  }
  return null;
}
async function detectLanguage(targetDir, pkg) {
  if (existsSync3(join5(targetDir, "tsconfig.json"))) {
    return high("typescript", "tsconfig.json", "TypeScript config found");
  }
  if (pkg?.devDependencies?.["typescript"]) {
    return high("typescript", "package.json", "TypeScript in devDependencies");
  }
  if (existsSync3(join5(targetDir, "pyproject.toml"))) {
    return high("python", "pyproject.toml", "Python project config found");
  }
  if (existsSync3(join5(targetDir, "setup.py"))) {
    return high("python", "setup.py", "Python setup file found");
  }
  if (existsSync3(join5(targetDir, "requirements.txt"))) {
    return high("python", "requirements.txt", "Python requirements found");
  }
  if (existsSync3(join5(targetDir, "go.mod"))) {
    return high("go", "go.mod", "Go module file found");
  }
  if (existsSync3(join5(targetDir, "Cargo.toml"))) {
    return high("rust", "Cargo.toml", "Rust manifest found");
  }
  if (pkg) {
    const srcDir = join5(targetDir, "src");
    if (existsSync3(srcDir)) {
      try {
        const glob = new Bun.Glob("**/*.{ts,tsx}");
        for await (const _file of glob.scan({ cwd: srcDir, onlyFiles: true })) {
          return high("typescript", "src/**/*.ts", "TypeScript files found in src/");
        }
      } catch {}
    }
    return medium("javascript", "package.json", "Node.js project without TypeScript");
  }
  return null;
}
function detectFramework(pkg) {
  if (!pkg)
    return null;
  const deps = { ...pkg.dependencies, ...pkg.devDependencies };
  if (deps["next"]) {
    return high("next.js", "package.json", "Next.js in dependencies");
  }
  if (deps["nuxt"]) {
    return high("nuxt", "package.json", "Nuxt in dependencies");
  }
  if (deps["@remix-run/react"] || deps["@remix-run/node"]) {
    return high("remix", "package.json", "Remix in dependencies");
  }
  if (deps["astro"]) {
    return high("astro", "package.json", "Astro in dependencies");
  }
  if (deps["@sveltejs/kit"]) {
    return high("sveltekit", "package.json", "SvelteKit in dependencies");
  }
  if (deps["svelte"] && !deps["@sveltejs/kit"]) {
    return high("svelte", "package.json", "Svelte in dependencies");
  }
  if (deps["vue"]) {
    return high("vue", "package.json", "Vue in dependencies");
  }
  if (deps["express"]) {
    return high("express", "package.json", "Express in dependencies");
  }
  if (deps["fastify"]) {
    return high("fastify", "package.json", "Fastify in dependencies");
  }
  if (deps["hono"]) {
    return high("hono", "package.json", "Hono in dependencies");
  }
  if (deps["elysia"]) {
    return high("elysia", "package.json", "Elysia in dependencies");
  }
  if (deps["react"] && !deps["next"] && !deps["@remix-run/react"]) {
    return medium("react", "package.json", "React in dependencies");
  }
  return null;
}
function detectRuntime(targetDir, pkg) {
  if (existsSync3(join5(targetDir, "bun.lockb"))) {
    return high("bun", "bun.lockb", "Bun lockfile found");
  }
  if (existsSync3(join5(targetDir, "bun.lock"))) {
    return high("bun", "bun.lock", "Bun lockfile found");
  }
  if (pkg?.packageManager) {
    const pm = pkg.packageManager.toLowerCase();
    if (pm.startsWith("bun")) {
      return high("bun", "package.json", "packageManager field specifies Bun");
    }
    if (pm.startsWith("pnpm")) {
      return high("node", "package.json", "packageManager field specifies pnpm");
    }
    if (pm.startsWith("yarn")) {
      return high("node", "package.json", "packageManager field specifies Yarn");
    }
    if (pm.startsWith("npm")) {
      return high("node", "package.json", "packageManager field specifies npm");
    }
  }
  if (pkg?.engines) {
    if (pkg.engines["bun"]) {
      return high("bun", "package.json", "engines.bun specified");
    }
    if (pkg.engines["node"]) {
      return high("node", "package.json", "engines.node specified");
    }
  }
  if (existsSync3(join5(targetDir, "pnpm-lock.yaml"))) {
    return high("node", "pnpm-lock.yaml", "pnpm lockfile found");
  }
  if (existsSync3(join5(targetDir, "yarn.lock"))) {
    return high("node", "yarn.lock", "Yarn lockfile found");
  }
  if (existsSync3(join5(targetDir, "package-lock.json"))) {
    return high("node", "package-lock.json", "npm lockfile found");
  }
  if (existsSync3(join5(targetDir, "deno.json")) || existsSync3(join5(targetDir, "deno.jsonc"))) {
    return high("deno", "deno.json", "Deno config found");
  }
  if (existsSync3(join5(targetDir, "pyproject.toml")) || existsSync3(join5(targetDir, "setup.py")) || existsSync3(join5(targetDir, "requirements.txt"))) {
    return high("python", "python files", "Python project files found");
  }
  if (existsSync3(join5(targetDir, "go.mod"))) {
    return high("go", "go.mod", "Go module found");
  }
  if (existsSync3(join5(targetDir, "Cargo.toml"))) {
    return high("cargo", "Cargo.toml", "Rust project found");
  }
  if (pkg) {
    return medium("node", "package.json", "Node.js project (no lockfile)");
  }
  return null;
}
function detectDatabase(targetDir, pkg) {
  const deps = pkg ? { ...pkg.dependencies, ...pkg.devDependencies } : {};
  if (deps["@supabase/supabase-js"] || deps["supabase"]) {
    return high("supabase", "package.json", "Supabase client in dependencies");
  }
  if (existsSync3(join5(targetDir, "supabase"))) {
    return high("supabase", "supabase/", "Supabase directory found");
  }
  if (deps["prisma"] || deps["@prisma/client"]) {
    return high("prisma", "package.json", "Prisma in dependencies");
  }
  if (existsSync3(join5(targetDir, "prisma"))) {
    return high("prisma", "prisma/", "Prisma directory found");
  }
  if (deps["drizzle-orm"] || deps["drizzle-kit"]) {
    return high("drizzle", "package.json", "Drizzle ORM in dependencies");
  }
  if (deps["mongodb"] || deps["mongoose"]) {
    return high("mongodb", "package.json", "MongoDB driver in dependencies");
  }
  if (deps["pg"] || deps["postgres"]) {
    return high("postgresql", "package.json", "PostgreSQL driver in dependencies");
  }
  if (deps["mysql"] || deps["mysql2"]) {
    return high("mysql", "package.json", "MySQL driver in dependencies");
  }
  if (deps["better-sqlite3"] || deps["sql.js"]) {
    return high("sqlite", "package.json", "SQLite in dependencies");
  }
  if (deps["redis"] || deps["ioredis"]) {
    return medium("redis", "package.json", "Redis client in dependencies");
  }
  return null;
}
async function detectProjectInfo(targetDir, pkg) {
  const [language] = await Promise.all([detectLanguage(targetDir, pkg)]);
  return {
    name: detectName(targetDir, pkg),
    language,
    framework: detectFramework(pkg),
    runtime: detectRuntime(targetDir, pkg),
    database: detectDatabase(targetDir, pkg)
  };
}
var init_project = () => {};

// src/config/detect/rules.ts
import { existsSync as existsSync4, readFileSync as readFileSync2 } from "fs";
import { join as join6 } from "path";
function parseJsonFile(filePath) {
  try {
    if (!existsSync4(filePath))
      return null;
    const content = readFileSync2(filePath, "utf-8");
    return JSON.parse(content);
  } catch {
    return null;
  }
}
function detectTsConfigRules(targetDir) {
  const rules = [];
  const tsconfig = parseJsonFile(join6(targetDir, "tsconfig.json"));
  if (!tsconfig?.compilerOptions)
    return rules;
  const opts = tsconfig.compilerOptions;
  if (opts.strict === true) {
    rules.push(high("TypeScript strict mode \u2014 no `any` types, explicit null checks", "tsconfig.json", "compilerOptions.strict: true"));
  } else {
    if (opts.noImplicitAny === true) {
      rules.push(high("No implicit `any` types", "tsconfig.json", "compilerOptions.noImplicitAny: true"));
    }
    if (opts.strictNullChecks === true) {
      rules.push(high("Explicit null/undefined handling required", "tsconfig.json", "compilerOptions.strictNullChecks: true"));
    }
  }
  return rules;
}
function detectDependencyRules(pkg) {
  const rules = [];
  if (!pkg)
    return rules;
  const deps = { ...pkg.dependencies, ...pkg.devDependencies };
  if (deps["zod"]) {
    rules.push(medium("Use Zod validation for API inputs and external data", "package.json", "Zod in dependencies"));
  }
  if (deps["tailwindcss"]) {
    rules.push(medium("Use Tailwind utility classes for styling", "package.json", "Tailwind CSS in dependencies"));
  }
  if (deps["vitest"] || deps["jest"] || deps["@testing-library/react"]) {
    rules.push(medium("Write tests for new functionality", "package.json", "Testing library in dependencies"));
  }
  if (deps["@tanstack/react-query"] || deps["react-query"]) {
    rules.push(medium("Use React Query for server state management", "package.json", "React Query in dependencies"));
  }
  if (deps["prettier"]) {
    rules.push(medium("Format code with Prettier before committing", "package.json", "Prettier in dependencies"));
  }
  return rules;
}
function detectConfigRules(targetDir) {
  const rules = [];
  if (existsSync4(join6(targetDir, "biome.json")) || existsSync4(join6(targetDir, "biome.jsonc"))) {
    rules.push(high("Follow Biome linting and formatting rules", "biome.json", "Biome config found"));
  }
  const eslintConfigs = [
    ".eslintrc",
    ".eslintrc.js",
    ".eslintrc.cjs",
    ".eslintrc.json",
    "eslint.config.js",
    "eslint.config.mjs"
  ];
  if (!existsSync4(join6(targetDir, "biome.json"))) {
    for (const config of eslintConfigs) {
      if (existsSync4(join6(targetDir, config))) {
        rules.push(high("Follow ESLint rules", config, "ESLint config found"));
        break;
      }
    }
  }
  return rules;
}
function detectStructureRules(targetDir) {
  const rules = [];
  if (existsSync4(join6(targetDir, "supabase", "migrations"))) {
    rules.push(high("Database migrations are append-only \u2014 never modify existing migrations", "supabase/migrations/", "Supabase migrations directory found"));
  }
  if (existsSync4(join6(targetDir, "prisma", "migrations"))) {
    rules.push(high("Prisma migrations are append-only \u2014 never modify existing migrations", "prisma/migrations/", "Prisma migrations directory found"));
  }
  if (existsSync4(join6(targetDir, ".github", "workflows"))) {
    rules.push(medium("Ensure CI passes before merging \u2014 check GitHub Actions", ".github/workflows/", "GitHub Actions found"));
  }
  return rules;
}
function detectNextJsRules(targetDir, pkg) {
  const rules = [];
  const deps = { ...pkg?.dependencies, ...pkg?.devDependencies };
  if (!deps["next"])
    return rules;
  if (existsSync4(join6(targetDir, "app"))) {
    rules.push(medium("Use Next.js App Router conventions \u2014 server components by default", "app/", "Next.js App Router detected"));
  }
  if (existsSync4(join6(targetDir, "middleware.ts")) || existsSync4(join6(targetDir, "src", "middleware.ts"))) {
    rules.push(medium("Route protection via middleware \u2014 ensure auth checks are complete", "middleware.ts", "Next.js middleware found"));
  }
  return rules;
}
function detectRules(targetDir, pkg) {
  const allRules = [];
  allRules.push(...detectTsConfigRules(targetDir));
  allRules.push(...detectDependencyRules(pkg));
  allRules.push(...detectConfigRules(targetDir));
  allRules.push(...detectStructureRules(targetDir));
  allRules.push(...detectNextJsRules(targetDir, pkg));
  const sorted = allRules.sort((a, b) => {
    const order = { high: 0, medium: 1, low: 2 };
    return order[a.confidence] - order[b.confidence];
  });
  return sorted.slice(0, MAX_RULES);
}
var MAX_RULES = 10;
var init_rules = () => {};

// src/config/detect/sandbox.ts
import { existsSync as existsSync5, readFileSync as readFileSync3 } from "fs";
import { join as join7 } from "path";
function isSafeVariable(name) {
  const upper = name.toUpperCase();
  for (const prefix of SAFE_PREFIXES) {
    if (upper.startsWith(prefix)) {
      return true;
    }
  }
  for (const keyword of SECRET_KEYWORDS) {
    if (upper.includes(keyword)) {
      const hasSafePrefix = SAFE_PREFIXES.some((p) => upper.startsWith(p));
      if (!hasSafePrefix) {
        return false;
      }
    }
  }
  for (const keyword of SAFE_KEYWORDS) {
    if (upper.includes(keyword)) {
      return true;
    }
  }
  return false;
}
function parseEnvFile(content) {
  const vars = [];
  const lines = content.split(`
`);
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) {
      continue;
    }
    const match = trimmed.match(/^([A-Z_][A-Z0-9_]*)=/i);
    if (match?.[1]) {
      vars.push(match[1]);
    }
  }
  return vars;
}
function readExampleEnvFile(targetDir) {
  for (const file of EXAMPLE_FILES) {
    const filePath = join7(targetDir, file);
    if (existsSync5(filePath)) {
      try {
        const content = readFileSync3(filePath, "utf-8");
        const vars = parseEnvFile(content);
        return { vars, source: file };
      } catch {}
    }
  }
  return null;
}
function detectSandbox(targetDir) {
  const allowed = [];
  for (const envVar of ALWAYS_ALLOWED) {
    allowed.push(high(envVar, "system", "Standard system environment variable"));
  }
  const envFile = readExampleEnvFile(targetDir);
  if (envFile) {
    for (const varName of envFile.vars) {
      if (ALWAYS_ALLOWED.includes(varName)) {
        continue;
      }
      if (isSafeVariable(varName)) {
        allowed.push(medium(varName, envFile.source, `Found in ${envFile.source}, appears safe`));
      }
    }
  }
  const frameworkVars = [
    {
      prefix: "NEXT_PUBLIC_",
      source: "Next.js convention",
      reason: "Client-exposed by Next.js"
    },
    {
      prefix: "VITE_",
      source: "Vite convention",
      reason: "Client-exposed by Vite"
    },
    {
      prefix: "NUXT_PUBLIC_",
      source: "Nuxt convention",
      reason: "Client-exposed by Nuxt"
    }
  ];
  if (envFile) {
    for (const framework of frameworkVars) {
      const hasPrefix = envFile.vars.some((v) => v.toUpperCase().startsWith(framework.prefix));
      if (hasPrefix) {
        const alreadyAdded = allowed.some((a) => a.source === framework.source);
        if (!alreadyAdded) {
          allowed.push(medium(`${framework.prefix}*`, framework.source, framework.reason));
        }
      }
    }
  }
  return { allowed_env: allowed };
}
var ALWAYS_ALLOWED, SAFE_PREFIXES, SAFE_KEYWORDS, SECRET_KEYWORDS, EXAMPLE_FILES;
var init_sandbox2 = __esm(() => {
  ALWAYS_ALLOWED = ["PATH", "HOME", "USER", "SHELL", "TERM", "LANG", "NODE_ENV", "CI"];
  SAFE_PREFIXES = [
    "NEXT_PUBLIC_",
    "VITE_",
    "NUXT_PUBLIC_",
    "REACT_APP_",
    "VUE_APP_",
    "EXPO_PUBLIC_"
  ];
  SAFE_KEYWORDS = ["PUBLIC", "ANON", "URL", "HOST", "PORT", "DOMAIN"];
  SECRET_KEYWORDS = [
    "SECRET",
    "PRIVATE",
    "PASSWORD",
    "PASSWD",
    "TOKEN",
    "KEY",
    "API_KEY",
    "APIKEY",
    "SERVICE_KEY",
    "SERVICE_ROLE",
    "AUTH_SECRET",
    "JWT_SECRET",
    "ENCRYPTION",
    "CREDENTIAL"
  ];
  EXAMPLE_FILES = [
    ".env.example",
    ".env.sample",
    ".env.template",
    ".env.development.example",
    ".env.local.example",
    "env.example",
    "env.sample"
  ];
});

// src/config/detect/recommendations.ts
function getCommandRecommendations(runtime, language) {
  const normalizedRuntime = runtime?.toLowerCase() ?? null;
  const normalizedLanguage = language?.toLowerCase() ?? null;
  if (normalizedRuntime === "bun" && normalizedLanguage === "typescript") {
    return {
      test: [
        { command: "bun test", suggestion: "Bun has a built-in test runner" },
        { command: "bunx vitest", suggestion: "Vitest is fast and Vite-native" }
      ],
      typecheck: [
        { command: "bunx tsc --noEmit", suggestion: "TypeScript compiler check" },
        { command: "bun run typecheck", suggestion: "If you have a typecheck script" }
      ]
    };
  }
  if (normalizedRuntime === "node" && normalizedLanguage === "typescript") {
    return {
      test: [
        { command: "npx vitest", suggestion: "Vitest is fast and Vite-native" },
        { command: "npx jest", suggestion: "Jest is widely used" },
        { command: "npm test", suggestion: "If you have a test script" }
      ],
      typecheck: [
        { command: "npx tsc --noEmit", suggestion: "TypeScript compiler check" },
        { command: "npm run typecheck", suggestion: "If you have a typecheck script" }
      ]
    };
  }
  if (normalizedRuntime === "node" && normalizedLanguage === "javascript") {
    return {
      test: [
        { command: "npx vitest", suggestion: "Vitest is fast and Vite-native" },
        { command: "npx jest", suggestion: "Jest is widely used" },
        { command: "npm test", suggestion: "If you have a test script" }
      ],
      typecheck: [
        { command: "npx tsc --noEmit --allowJs", suggestion: "TypeScript can check JS files" }
      ]
    };
  }
  if (normalizedRuntime === "deno") {
    return {
      test: [{ command: "deno test", suggestion: "Deno has a built-in test runner" }],
      typecheck: [{ command: "deno check .", suggestion: "Deno has built-in type checking" }]
    };
  }
  if (normalizedRuntime === "python" || normalizedLanguage === "python") {
    return {
      test: [
        { command: "pytest", suggestion: "pytest is the standard Python test framework" },
        { command: "python -m pytest", suggestion: "Module-based pytest invocation" },
        { command: "python -m unittest discover", suggestion: "Built-in unittest" }
      ],
      typecheck: [
        { command: "mypy .", suggestion: "mypy is the standard Python type checker" },
        { command: "pyright", suggestion: "pyright is fast and VS Code native" },
        { command: "python -m mypy .", suggestion: "Module-based mypy invocation" }
      ]
    };
  }
  if (normalizedRuntime === "go" || normalizedLanguage === "go") {
    return {
      test: [{ command: "go test ./...", suggestion: "Go has a built-in test runner" }],
      typecheck: [{ command: "go vet ./...", suggestion: "Go has built-in static analysis" }]
    };
  }
  if (normalizedRuntime === "rust" || normalizedLanguage === "rust") {
    return {
      test: [{ command: "cargo test", suggestion: "Cargo has a built-in test runner" }],
      typecheck: [{ command: "cargo check", suggestion: "Cargo check is faster than build" }]
    };
  }
  return {
    test: [
      { command: "npm test", suggestion: "Common npm test script" },
      { command: "npx vitest", suggestion: "Vitest works with most projects" }
    ],
    typecheck: [{ command: "npx tsc --noEmit", suggestion: "TypeScript compiler check" }]
  };
}
function formatRecommendations(recommendations) {
  return recommendations.map((r) => `  ${r.command} \u2014 ${r.suggestion}`).join(`
`);
}

// src/config/detect/index.ts
import { existsSync as existsSync6, readFileSync as readFileSync4 } from "fs";
import { join as join8 } from "path";
function readPackageJsonSafe(targetDir) {
  const packagePath = join8(targetDir, "package.json");
  if (!existsSync6(packagePath)) {
    return null;
  }
  try {
    const content = readFileSync4(packagePath, "utf-8");
    return JSON.parse(content);
  } catch {
    return null;
  }
}
async function detectProject(targetDir = process.cwd()) {
  const start = performance.now();
  const warnings = [];
  let pkg = null;
  try {
    pkg = readPackageJsonSafe(targetDir);
  } catch (error) {
    warnings.push(`Failed to read package.json: ${error.message}`);
  }
  const [projectInfo, commands, rules, boundaries, sandbox] = await Promise.all([
    detectProjectInfo(targetDir, pkg).catch((error) => {
      warnings.push(`Project detection failed: ${error.message}`);
      return {
        name: null,
        language: null,
        framework: null,
        runtime: null,
        database: null
      };
    }),
    Promise.resolve(detectCommands(targetDir, pkg)).catch((error) => {
      warnings.push(`Commands detection failed: ${error.message}`);
      return { build: null, lint: null, test: null, typecheck: null };
    }),
    Promise.resolve(detectRules(targetDir, pkg)).catch((error) => {
      warnings.push(`Rules detection failed: ${error.message}`);
      return [];
    }),
    Promise.resolve(detectBoundaries(targetDir, pkg)).catch((error) => {
      warnings.push(`Boundaries detection failed: ${error.message}`);
      return { never_touch: [], require_review: [] };
    }),
    Promise.resolve(detectSandbox(targetDir)).catch((error) => {
      warnings.push(`Sandbox detection failed: ${error.message}`);
      return { allowed_env: [] };
    })
  ]);
  if (pkg?.workspaces) {
    const workspaceDef = pkg.workspaces;
    const hasWorkspaces = Array.isArray(workspaceDef) ? workspaceDef.length > 0 : Array.isArray(workspaceDef.packages) && workspaceDef.packages.length > 0;
    if (hasWorkspaces) {
      warnings.push("Monorepo detected. Consider running karimo init in individual packages.");
    }
  }
  const scanDurationMs = Math.round(performance.now() - start);
  return {
    ...projectInfo,
    commands,
    rules,
    boundaries,
    sandbox,
    scanDurationMs,
    warnings
  };
}
function hasMinimalDetection(result) {
  return result.name !== null || result.language !== null;
}
function getDetectionSummary(result) {
  const parts = [];
  if (result.name) {
    parts.push(`Project: ${result.name.value}`);
  }
  if (result.language) {
    parts.push(`Language: ${result.language.value}`);
  }
  if (result.framework) {
    parts.push(`Framework: ${result.framework.value}`);
  }
  if (result.runtime) {
    parts.push(`Runtime: ${result.runtime.value}`);
  }
  if (result.database) {
    parts.push(`Database: ${result.database.value}`);
  }
  const commandCount = [
    result.commands.build,
    result.commands.lint,
    result.commands.test,
    result.commands.typecheck
  ].filter(Boolean).length;
  parts.push(`Commands: ${commandCount}/4 detected`);
  parts.push(`Rules: ${result.rules.length} inferred`);
  parts.push(`Boundaries: ${result.boundaries.never_touch.length + result.boundaries.require_review.length} patterns`);
  parts.push(`Env vars: ${result.sandbox.allowed_env.length} allowed`);
  parts.push(`Scan time: ${result.scanDurationMs}ms`);
  return parts.join(`
`);
}
var init_detect = __esm(() => {
  init_boundaries();
  init_commands();
  init_project();
  init_rules();
  init_sandbox2();
  init_boundaries();
  init_commands();
  init_project();
  init_rules();
  init_sandbox2();
});

// node_modules/sisteransi/src/index.js
var require_src = __commonJS((exports, module) => {
  var ESC = "\x1B";
  var CSI = `${ESC}[`;
  var beep = "\x07";
  var cursor = {
    to(x, y) {
      if (!y)
        return `${CSI}${x + 1}G`;
      return `${CSI}${y + 1};${x + 1}H`;
    },
    move(x, y) {
      let ret = "";
      if (x < 0)
        ret += `${CSI}${-x}D`;
      else if (x > 0)
        ret += `${CSI}${x}C`;
      if (y < 0)
        ret += `${CSI}${-y}A`;
      else if (y > 0)
        ret += `${CSI}${y}B`;
      return ret;
    },
    up: (count = 1) => `${CSI}${count}A`,
    down: (count = 1) => `${CSI}${count}B`,
    forward: (count = 1) => `${CSI}${count}C`,
    backward: (count = 1) => `${CSI}${count}D`,
    nextLine: (count = 1) => `${CSI}E`.repeat(count),
    prevLine: (count = 1) => `${CSI}F`.repeat(count),
    left: `${CSI}G`,
    hide: `${CSI}?25l`,
    show: `${CSI}?25h`,
    save: `${ESC}7`,
    restore: `${ESC}8`
  };
  var scroll = {
    up: (count = 1) => `${CSI}S`.repeat(count),
    down: (count = 1) => `${CSI}T`.repeat(count)
  };
  var erase = {
    screen: `${CSI}2J`,
    up: (count = 1) => `${CSI}1J`.repeat(count),
    down: (count = 1) => `${CSI}J`.repeat(count),
    line: `${CSI}2K`,
    lineEnd: `${CSI}K`,
    lineStart: `${CSI}1K`,
    lines(count) {
      let clear = "";
      for (let i = 0;i < count; i++)
        clear += this.line + (i < count - 1 ? cursor.up() : "");
      if (count)
        clear += cursor.left;
      return clear;
    }
  };
  module.exports = { cursor, scroll, erase, beep };
});

// node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS((exports, module) => {
  var p = process || {};
  var argv = p.argv || [];
  var env = p.env || {};
  var isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
  var formatter = (open, close, replace = open) => (input) => {
    let string = "" + input, index = string.indexOf(close, open.length);
    return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
  };
  var replaceClose = (string, close, replace, index) => {
    let result = "", cursor = 0;
    do {
      result += string.substring(cursor, index) + replace;
      cursor = index + close.length;
      index = string.indexOf(close, cursor);
    } while (~index);
    return result + string.substring(cursor);
  };
  var createColors = (enabled = isColorSupported) => {
    let f = enabled ? formatter : () => String;
    return {
      isColorSupported: enabled,
      reset: f("\x1B[0m", "\x1B[0m"),
      bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: f("\x1B[3m", "\x1B[23m"),
      underline: f("\x1B[4m", "\x1B[24m"),
      inverse: f("\x1B[7m", "\x1B[27m"),
      hidden: f("\x1B[8m", "\x1B[28m"),
      strikethrough: f("\x1B[9m", "\x1B[29m"),
      black: f("\x1B[30m", "\x1B[39m"),
      red: f("\x1B[31m", "\x1B[39m"),
      green: f("\x1B[32m", "\x1B[39m"),
      yellow: f("\x1B[33m", "\x1B[39m"),
      blue: f("\x1B[34m", "\x1B[39m"),
      magenta: f("\x1B[35m", "\x1B[39m"),
      cyan: f("\x1B[36m", "\x1B[39m"),
      white: f("\x1B[37m", "\x1B[39m"),
      gray: f("\x1B[90m", "\x1B[39m"),
      bgBlack: f("\x1B[40m", "\x1B[49m"),
      bgRed: f("\x1B[41m", "\x1B[49m"),
      bgGreen: f("\x1B[42m", "\x1B[49m"),
      bgYellow: f("\x1B[43m", "\x1B[49m"),
      bgBlue: f("\x1B[44m", "\x1B[49m"),
      bgMagenta: f("\x1B[45m", "\x1B[49m"),
      bgCyan: f("\x1B[46m", "\x1B[49m"),
      bgWhite: f("\x1B[47m", "\x1B[49m"),
      blackBright: f("\x1B[90m", "\x1B[39m"),
      redBright: f("\x1B[91m", "\x1B[39m"),
      greenBright: f("\x1B[92m", "\x1B[39m"),
      yellowBright: f("\x1B[93m", "\x1B[39m"),
      blueBright: f("\x1B[94m", "\x1B[39m"),
      magentaBright: f("\x1B[95m", "\x1B[39m"),
      cyanBright: f("\x1B[96m", "\x1B[39m"),
      whiteBright: f("\x1B[97m", "\x1B[39m"),
      bgBlackBright: f("\x1B[100m", "\x1B[49m"),
      bgRedBright: f("\x1B[101m", "\x1B[49m"),
      bgGreenBright: f("\x1B[102m", "\x1B[49m"),
      bgYellowBright: f("\x1B[103m", "\x1B[49m"),
      bgBlueBright: f("\x1B[104m", "\x1B[49m"),
      bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
      bgCyanBright: f("\x1B[106m", "\x1B[49m"),
      bgWhiteBright: f("\x1B[107m", "\x1B[49m")
    };
  };
  module.exports = createColors();
  module.exports.createColors = createColors;
});

// node_modules/@clack/core/dist/index.mjs
import { stdin as $, stdout as k } from "process";
import * as f from "readline";
import _ from "readline";
import { WriteStream as U } from "tty";
function q({ onlyFirst: e = false } = {}) {
  const F = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
  return new RegExp(F, e ? undefined : "g");
}
function S(e) {
  if (typeof e != "string")
    throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
  return e.replace(J, "");
}
function T(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function A(e, u = {}) {
  if (typeof e != "string" || e.length === 0 || (u = { ambiguousIsNarrow: true, ...u }, e = S(e), e.length === 0))
    return 0;
  e = e.replace(uD(), "  ");
  const F = u.ambiguousIsNarrow ? 1 : 2;
  let t = 0;
  for (const s of e) {
    const C = s.codePointAt(0);
    if (C <= 31 || C >= 127 && C <= 159 || C >= 768 && C <= 879)
      continue;
    switch (X.eastAsianWidth(s)) {
      case "F":
      case "W":
        t += 2;
        break;
      case "A":
        t += F;
        break;
      default:
        t += 1;
    }
  }
  return t;
}
function tD() {
  const e = new Map;
  for (const [u, F] of Object.entries(r)) {
    for (const [t, s] of Object.entries(F))
      r[t] = { open: `\x1B[${s[0]}m`, close: `\x1B[${s[1]}m` }, F[t] = r[t], e.set(s[0], s[1]);
    Object.defineProperty(r, u, { value: F, enumerable: false });
  }
  return Object.defineProperty(r, "codes", { value: e, enumerable: false }), r.color.close = "\x1B[39m", r.bgColor.close = "\x1B[49m", r.color.ansi = M(), r.color.ansi256 = P(), r.color.ansi16m = W(), r.bgColor.ansi = M(d), r.bgColor.ansi256 = P(d), r.bgColor.ansi16m = W(d), Object.defineProperties(r, { rgbToAnsi256: { value: (u, F, t) => u === F && F === t ? u < 8 ? 16 : u > 248 ? 231 : Math.round((u - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(u / 255 * 5) + 6 * Math.round(F / 255 * 5) + Math.round(t / 255 * 5), enumerable: false }, hexToRgb: { value: (u) => {
    const F = /[a-f\d]{6}|[a-f\d]{3}/i.exec(u.toString(16));
    if (!F)
      return [0, 0, 0];
    let [t] = F;
    t.length === 3 && (t = [...t].map((C) => C + C).join(""));
    const s = Number.parseInt(t, 16);
    return [s >> 16 & 255, s >> 8 & 255, s & 255];
  }, enumerable: false }, hexToAnsi256: { value: (u) => r.rgbToAnsi256(...r.hexToRgb(u)), enumerable: false }, ansi256ToAnsi: { value: (u) => {
    if (u < 8)
      return 30 + u;
    if (u < 16)
      return 90 + (u - 8);
    let F, t, s;
    if (u >= 232)
      F = ((u - 232) * 10 + 8) / 255, t = F, s = F;
    else {
      u -= 16;
      const i = u % 36;
      F = Math.floor(u / 36) / 5, t = Math.floor(i / 6) / 5, s = i % 6 / 5;
    }
    const C = Math.max(F, t, s) * 2;
    if (C === 0)
      return 30;
    let D = 30 + (Math.round(s) << 2 | Math.round(t) << 1 | Math.round(F));
    return C === 2 && (D += 60), D;
  }, enumerable: false }, rgbToAnsi: { value: (u, F, t) => r.ansi256ToAnsi(r.rgbToAnsi256(u, F, t)), enumerable: false }, hexToAnsi: { value: (u) => r.ansi256ToAnsi(r.hexToAnsi256(u)), enumerable: false } }), r;
}
function R(e, u, F) {
  return String(e).normalize().replace(/\r\n/g, `
`).split(`
`).map((t) => oD(t, u, F)).join(`
`);
}
function hD(e, u) {
  if (e === u)
    return;
  const F = e.split(`
`), t = u.split(`
`), s = [];
  for (let C = 0;C < Math.max(F.length, t.length); C++)
    F[C] !== t[C] && s.push(C);
  return s;
}
function lD(e) {
  return e === V;
}
function v(e, u) {
  e.isTTY && e.setRawMode(u);
}

class x {
  constructor({ render: u, input: F = $, output: t = k, ...s }, C = true) {
    a(this, "input"), a(this, "output"), a(this, "rl"), a(this, "opts"), a(this, "_track", false), a(this, "_render"), a(this, "_cursor", 0), a(this, "state", "initial"), a(this, "value"), a(this, "error", ""), a(this, "subscribers", new Map), a(this, "_prevFrame", ""), this.opts = s, this.onKeypress = this.onKeypress.bind(this), this.close = this.close.bind(this), this.render = this.render.bind(this), this._render = u.bind(this), this._track = C, this.input = F, this.output = t;
  }
  prompt() {
    const u = new U(0);
    return u._write = (F, t, s) => {
      this._track && (this.value = this.rl.line.replace(/\t/g, ""), this._cursor = this.rl.cursor, this.emit("value", this.value)), s();
    }, this.input.pipe(u), this.rl = _.createInterface({ input: this.input, output: u, tabSize: 2, prompt: "", escapeCodeTimeout: 50 }), _.emitKeypressEvents(this.input, this.rl), this.rl.prompt(), this.opts.initialValue !== undefined && this._track && this.rl.write(this.opts.initialValue), this.input.on("keypress", this.onKeypress), v(this.input, true), this.output.on("resize", this.render), this.render(), new Promise((F, t) => {
      this.once("submit", () => {
        this.output.write(import_sisteransi.cursor.show), this.output.off("resize", this.render), v(this.input, false), F(this.value);
      }), this.once("cancel", () => {
        this.output.write(import_sisteransi.cursor.show), this.output.off("resize", this.render), v(this.input, false), F(V);
      });
    });
  }
  on(u, F) {
    const t = this.subscribers.get(u) ?? [];
    t.push({ cb: F }), this.subscribers.set(u, t);
  }
  once(u, F) {
    const t = this.subscribers.get(u) ?? [];
    t.push({ cb: F, once: true }), this.subscribers.set(u, t);
  }
  emit(u, ...F) {
    const t = this.subscribers.get(u) ?? [], s = [];
    for (const C of t)
      C.cb(...F), C.once && s.push(() => t.splice(t.indexOf(C), 1));
    for (const C of s)
      C();
  }
  unsubscribe() {
    this.subscribers.clear();
  }
  onKeypress(u, F) {
    if (this.state === "error" && (this.state = "active"), F?.name && !this._track && z.has(F.name) && this.emit("cursor", z.get(F.name)), F?.name && xD.has(F.name) && this.emit("cursor", F.name), u && (u.toLowerCase() === "y" || u.toLowerCase() === "n") && this.emit("confirm", u.toLowerCase() === "y"), u === "\t" && this.opts.placeholder && (this.value || (this.rl.write(this.opts.placeholder), this.emit("value", this.opts.placeholder))), u && this.emit("key", u.toLowerCase()), F?.name === "return") {
      if (this.opts.validate) {
        const t = this.opts.validate(this.value);
        t && (this.error = t, this.state = "error", this.rl.write(this.value));
      }
      this.state !== "error" && (this.state = "submit");
    }
    u === "\x03" && (this.state = "cancel"), (this.state === "submit" || this.state === "cancel") && this.emit("finalize"), this.render(), (this.state === "submit" || this.state === "cancel") && this.close();
  }
  close() {
    this.input.unpipe(), this.input.removeListener("keypress", this.onKeypress), this.output.write(`
`), v(this.input, false), this.rl.close(), this.emit(`${this.state}`, this.value), this.unsubscribe();
  }
  restoreCursor() {
    const u = R(this._prevFrame, process.stdout.columns, { hard: true }).split(`
`).length - 1;
    this.output.write(import_sisteransi.cursor.move(-999, u * -1));
  }
  render() {
    const u = R(this._render(this) ?? "", process.stdout.columns, { hard: true });
    if (u !== this._prevFrame) {
      if (this.state === "initial")
        this.output.write(import_sisteransi.cursor.hide);
      else {
        const F = hD(this._prevFrame, u);
        if (this.restoreCursor(), F && F?.length === 1) {
          const t = F[0];
          this.output.write(import_sisteransi.cursor.move(0, t)), this.output.write(import_sisteransi.erase.lines(1));
          const s = u.split(`
`);
          this.output.write(s[t]), this._prevFrame = u, this.output.write(import_sisteransi.cursor.move(0, s.length - t - 1));
          return;
        } else if (F && F?.length > 1) {
          const t = F[0];
          this.output.write(import_sisteransi.cursor.move(0, t)), this.output.write(import_sisteransi.erase.down());
          const s = u.split(`
`).slice(t);
          this.output.write(s.join(`
`)), this._prevFrame = u;
          return;
        }
        this.output.write(import_sisteransi.erase.down());
      }
      this.output.write(u), this.state === "initial" && (this.state = "active"), this._prevFrame = u;
    }
  }
}
function OD({ input: e = $, output: u = k, overwrite: F = true, hideCursor: t = true } = {}) {
  const s = f.createInterface({ input: e, output: u, prompt: "", tabSize: 1 });
  f.emitKeypressEvents(e, s), e.isTTY && e.setRawMode(true);
  const C = (D, { name: i }) => {
    if (String(D) === "\x03") {
      t && u.write(import_sisteransi.cursor.show), process.exit(0);
      return;
    }
    if (!F)
      return;
    let n = i === "return" ? 0 : -1, E = i === "return" ? -1 : 0;
    f.moveCursor(u, n, E, () => {
      f.clearLine(u, 1, () => {
        e.once("keypress", C);
      });
    });
  };
  return t && u.write(import_sisteransi.cursor.hide), e.once("keypress", C), () => {
    e.off("keypress", C), t && u.write(import_sisteransi.cursor.show), e.isTTY && !WD && e.setRawMode(false), s.terminal = false, s.close();
  };
}
var import_sisteransi, import_picocolors, J, j, Q, X, DD = function() {
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
}, uD, d = 10, M = (e = 0) => (u) => `\x1B[${u + e}m`, P = (e = 0) => (u) => `\x1B[${38 + e};5;${u}m`, W = (e = 0) => (u, F, t) => `\x1B[${38 + e};2;${u};${F};${t}m`, r, FD, eD, sD, g, CD = 39, b = "\x07", O = "[", iD = "]", I = "m", w, N = (e) => `${g.values().next().value}${O}${e}${I}`, L = (e) => `${g.values().next().value}${w}${e}${b}`, rD = (e) => e.split(" ").map((u) => A(u)), y = (e, u, F) => {
  const t = [...u];
  let s = false, C = false, D = A(S(e[e.length - 1]));
  for (const [i, n] of t.entries()) {
    const E = A(n);
    if (D + E <= F ? e[e.length - 1] += n : (e.push(n), D = 0), g.has(n) && (s = true, C = t.slice(i + 1).join("").startsWith(w)), s) {
      C ? n === b && (s = false, C = false) : n === I && (s = false);
      continue;
    }
    D += E, D === F && i < t.length - 1 && (e.push(""), D = 0);
  }
  !D && e[e.length - 1].length > 0 && e.length > 1 && (e[e.length - 2] += e.pop());
}, ED = (e) => {
  const u = e.split(" ");
  let F = u.length;
  for (;F > 0 && !(A(u[F - 1]) > 0); )
    F--;
  return F === u.length ? e : u.slice(0, F).join(" ") + u.slice(F).join("");
}, oD = (e, u, F = {}) => {
  if (F.trim !== false && e.trim() === "")
    return "";
  let t = "", s, C;
  const D = rD(e);
  let i = [""];
  for (const [E, h] of e.split(" ").entries()) {
    F.trim !== false && (i[i.length - 1] = i[i.length - 1].trimStart());
    let o = A(i[i.length - 1]);
    if (E !== 0 && (o >= u && (F.wordWrap === false || F.trim === false) && (i.push(""), o = 0), (o > 0 || F.trim === false) && (i[i.length - 1] += " ", o++)), F.hard && D[E] > u) {
      const B = u - o, p = 1 + Math.floor((D[E] - B - 1) / u);
      Math.floor((D[E] - 1) / u) < p && i.push(""), y(i, h, u);
      continue;
    }
    if (o + D[E] > u && o > 0 && D[E] > 0) {
      if (F.wordWrap === false && o < u) {
        y(i, h, u);
        continue;
      }
      i.push("");
    }
    if (o + D[E] > u && F.wordWrap === false) {
      y(i, h, u);
      continue;
    }
    i[i.length - 1] += h;
  }
  F.trim !== false && (i = i.map((E) => ED(E)));
  const n = [...i.join(`
`)];
  for (const [E, h] of n.entries()) {
    if (t += h, g.has(h)) {
      const { groups: B } = new RegExp(`(?:\\${O}(?<code>\\d+)m|\\${w}(?<uri>.*)${b})`).exec(n.slice(E).join("")) || { groups: {} };
      if (B.code !== undefined) {
        const p = Number.parseFloat(B.code);
        s = p === CD ? undefined : p;
      } else
        B.uri !== undefined && (C = B.uri.length === 0 ? undefined : B.uri);
    }
    const o = sD.codes.get(Number(s));
    n[E + 1] === `
` ? (C && (t += L("")), s && o && (t += N(o))) : h === `
` && (s && o && (t += N(s)), C && (t += L(C)));
  }
  return t;
}, nD, aD = (e, u, F) => (u in e) ? nD(e, u, { enumerable: true, configurable: true, writable: true, value: F }) : e[u] = F, a = (e, u, F) => (aD(e, typeof u != "symbol" ? u + "" : u, F), F), V, z, xD, BD, fD, gD = (e, u, F) => (u in e) ? fD(e, u, { enumerable: true, configurable: true, writable: true, value: F }) : e[u] = F, K = (e, u, F) => (gD(e, typeof u != "symbol" ? u + "" : u, F), F), vD, wD, yD = (e, u, F) => (u in e) ? wD(e, u, { enumerable: true, configurable: true, writable: true, value: F }) : e[u] = F, Z = (e, u, F) => (yD(e, typeof u != "symbol" ? u + "" : u, F), F), $D, TD, jD = (e, u, F) => (u in e) ? TD(e, u, { enumerable: true, configurable: true, writable: true, value: F }) : e[u] = F, MD = (e, u, F) => (jD(e, typeof u != "symbol" ? u + "" : u, F), F), PD, WD;
var init_dist2 = __esm(() => {
  import_sisteransi = __toESM(require_src(), 1);
  import_picocolors = __toESM(require_picocolors(), 1);
  J = q();
  j = { exports: {} };
  (function(e) {
    var u = {};
    e.exports = u, u.eastAsianWidth = function(t) {
      var s = t.charCodeAt(0), C = t.length == 2 ? t.charCodeAt(1) : 0, D = s;
      return 55296 <= s && s <= 56319 && 56320 <= C && C <= 57343 && (s &= 1023, C &= 1023, D = s << 10 | C, D += 65536), D == 12288 || 65281 <= D && D <= 65376 || 65504 <= D && D <= 65510 ? "F" : D == 8361 || 65377 <= D && D <= 65470 || 65474 <= D && D <= 65479 || 65482 <= D && D <= 65487 || 65490 <= D && D <= 65495 || 65498 <= D && D <= 65500 || 65512 <= D && D <= 65518 ? "H" : 4352 <= D && D <= 4447 || 4515 <= D && D <= 4519 || 4602 <= D && D <= 4607 || 9001 <= D && D <= 9002 || 11904 <= D && D <= 11929 || 11931 <= D && D <= 12019 || 12032 <= D && D <= 12245 || 12272 <= D && D <= 12283 || 12289 <= D && D <= 12350 || 12353 <= D && D <= 12438 || 12441 <= D && D <= 12543 || 12549 <= D && D <= 12589 || 12593 <= D && D <= 12686 || 12688 <= D && D <= 12730 || 12736 <= D && D <= 12771 || 12784 <= D && D <= 12830 || 12832 <= D && D <= 12871 || 12880 <= D && D <= 13054 || 13056 <= D && D <= 19903 || 19968 <= D && D <= 42124 || 42128 <= D && D <= 42182 || 43360 <= D && D <= 43388 || 44032 <= D && D <= 55203 || 55216 <= D && D <= 55238 || 55243 <= D && D <= 55291 || 63744 <= D && D <= 64255 || 65040 <= D && D <= 65049 || 65072 <= D && D <= 65106 || 65108 <= D && D <= 65126 || 65128 <= D && D <= 65131 || 110592 <= D && D <= 110593 || 127488 <= D && D <= 127490 || 127504 <= D && D <= 127546 || 127552 <= D && D <= 127560 || 127568 <= D && D <= 127569 || 131072 <= D && D <= 194367 || 177984 <= D && D <= 196605 || 196608 <= D && D <= 262141 ? "W" : 32 <= D && D <= 126 || 162 <= D && D <= 163 || 165 <= D && D <= 166 || D == 172 || D == 175 || 10214 <= D && D <= 10221 || 10629 <= D && D <= 10630 ? "Na" : D == 161 || D == 164 || 167 <= D && D <= 168 || D == 170 || 173 <= D && D <= 174 || 176 <= D && D <= 180 || 182 <= D && D <= 186 || 188 <= D && D <= 191 || D == 198 || D == 208 || 215 <= D && D <= 216 || 222 <= D && D <= 225 || D == 230 || 232 <= D && D <= 234 || 236 <= D && D <= 237 || D == 240 || 242 <= D && D <= 243 || 247 <= D && D <= 250 || D == 252 || D == 254 || D == 257 || D == 273 || D == 275 || D == 283 || 294 <= D && D <= 295 || D == 299 || 305 <= D && D <= 307 || D == 312 || 319 <= D && D <= 322 || D == 324 || 328 <= D && D <= 331 || D == 333 || 338 <= D && D <= 339 || 358 <= D && D <= 359 || D == 363 || D == 462 || D == 464 || D == 466 || D == 468 || D == 470 || D == 472 || D == 474 || D == 476 || D == 593 || D == 609 || D == 708 || D == 711 || 713 <= D && D <= 715 || D == 717 || D == 720 || 728 <= D && D <= 731 || D == 733 || D == 735 || 768 <= D && D <= 879 || 913 <= D && D <= 929 || 931 <= D && D <= 937 || 945 <= D && D <= 961 || 963 <= D && D <= 969 || D == 1025 || 1040 <= D && D <= 1103 || D == 1105 || D == 8208 || 8211 <= D && D <= 8214 || 8216 <= D && D <= 8217 || 8220 <= D && D <= 8221 || 8224 <= D && D <= 8226 || 8228 <= D && D <= 8231 || D == 8240 || 8242 <= D && D <= 8243 || D == 8245 || D == 8251 || D == 8254 || D == 8308 || D == 8319 || 8321 <= D && D <= 8324 || D == 8364 || D == 8451 || D == 8453 || D == 8457 || D == 8467 || D == 8470 || 8481 <= D && D <= 8482 || D == 8486 || D == 8491 || 8531 <= D && D <= 8532 || 8539 <= D && D <= 8542 || 8544 <= D && D <= 8555 || 8560 <= D && D <= 8569 || D == 8585 || 8592 <= D && D <= 8601 || 8632 <= D && D <= 8633 || D == 8658 || D == 8660 || D == 8679 || D == 8704 || 8706 <= D && D <= 8707 || 8711 <= D && D <= 8712 || D == 8715 || D == 8719 || D == 8721 || D == 8725 || D == 8730 || 8733 <= D && D <= 8736 || D == 8739 || D == 8741 || 8743 <= D && D <= 8748 || D == 8750 || 8756 <= D && D <= 8759 || 8764 <= D && D <= 8765 || D == 8776 || D == 8780 || D == 8786 || 8800 <= D && D <= 8801 || 8804 <= D && D <= 8807 || 8810 <= D && D <= 8811 || 8814 <= D && D <= 8815 || 8834 <= D && D <= 8835 || 8838 <= D && D <= 8839 || D == 8853 || D == 8857 || D == 8869 || D == 8895 || D == 8978 || 9312 <= D && D <= 9449 || 9451 <= D && D <= 9547 || 9552 <= D && D <= 9587 || 9600 <= D && D <= 9615 || 9618 <= D && D <= 9621 || 9632 <= D && D <= 9633 || 9635 <= D && D <= 9641 || 9650 <= D && D <= 9651 || 9654 <= D && D <= 9655 || 9660 <= D && D <= 9661 || 9664 <= D && D <= 9665 || 9670 <= D && D <= 9672 || D == 9675 || 9678 <= D && D <= 9681 || 9698 <= D && D <= 9701 || D == 9711 || 9733 <= D && D <= 9734 || D == 9737 || 9742 <= D && D <= 9743 || 9748 <= D && D <= 9749 || D == 9756 || D == 9758 || D == 9792 || D == 9794 || 9824 <= D && D <= 9825 || 9827 <= D && D <= 9829 || 9831 <= D && D <= 9834 || 9836 <= D && D <= 9837 || D == 9839 || 9886 <= D && D <= 9887 || 9918 <= D && D <= 9919 || 9924 <= D && D <= 9933 || 9935 <= D && D <= 9953 || D == 9955 || 9960 <= D && D <= 9983 || D == 10045 || D == 10071 || 10102 <= D && D <= 10111 || 11093 <= D && D <= 11097 || 12872 <= D && D <= 12879 || 57344 <= D && D <= 63743 || 65024 <= D && D <= 65039 || D == 65533 || 127232 <= D && D <= 127242 || 127248 <= D && D <= 127277 || 127280 <= D && D <= 127337 || 127344 <= D && D <= 127386 || 917760 <= D && D <= 917999 || 983040 <= D && D <= 1048573 || 1048576 <= D && D <= 1114109 ? "A" : "N";
    }, u.characterLength = function(t) {
      var s = this.eastAsianWidth(t);
      return s == "F" || s == "W" || s == "A" ? 2 : 1;
    };
    function F(t) {
      return t.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
    }
    u.length = function(t) {
      for (var s = F(t), C = 0, D = 0;D < s.length; D++)
        C = C + this.characterLength(s[D]);
      return C;
    }, u.slice = function(t, s, C) {
      textLen = u.length(t), s = s || 0, C = C || 1, s < 0 && (s = textLen + s), C < 0 && (C = textLen + C);
      for (var D = "", i = 0, n = F(t), E = 0;E < n.length; E++) {
        var h = n[E], o = u.length(h);
        if (i >= s - (o == 2 ? 1 : 0))
          if (i + o <= C)
            D += h;
          else
            break;
        i += o;
      }
      return D;
    };
  })(j);
  Q = j.exports;
  X = T(Q);
  uD = T(DD);
  r = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], overline: [53, 55], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], gray: [90, 39], grey: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgGray: [100, 49], bgGrey: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
  Object.keys(r.modifier);
  FD = Object.keys(r.color);
  eD = Object.keys(r.bgColor);
  [...FD, ...eD];
  sD = tD();
  g = new Set(["\x1B", "\x9B"]);
  w = `${iD}8;;`;
  nD = Object.defineProperty;
  V = Symbol("clack:cancel");
  z = new Map([["k", "up"], ["j", "down"], ["h", "left"], ["l", "right"]]);
  xD = new Set(["up", "down", "left", "right", "space", "enter"]);
  BD = class BD extends x {
    get cursor() {
      return this.value ? 0 : 1;
    }
    get _value() {
      return this.cursor === 0;
    }
    constructor(u) {
      super(u, false), this.value = !!u.initialValue, this.on("value", () => {
        this.value = this._value;
      }), this.on("confirm", (F) => {
        this.output.write(import_sisteransi.cursor.move(0, -1)), this.value = F, this.state = "submit", this.close();
      }), this.on("cursor", () => {
        this.value = !this.value;
      });
    }
  };
  fD = Object.defineProperty;
  vD = class extends x {
    constructor(u) {
      super(u, false), K(this, "options"), K(this, "cursor", 0), this.options = u.options, this.value = [...u.initialValues ?? []], this.cursor = Math.max(this.options.findIndex(({ value: F }) => F === u.cursorAt), 0), this.on("key", (F) => {
        F === "a" && this.toggleAll();
      }), this.on("cursor", (F) => {
        switch (F) {
          case "left":
          case "up":
            this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1;
            break;
          case "down":
          case "right":
            this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
            break;
          case "space":
            this.toggleValue();
            break;
        }
      });
    }
    get _value() {
      return this.options[this.cursor].value;
    }
    toggleAll() {
      const u = this.value.length === this.options.length;
      this.value = u ? [] : this.options.map((F) => F.value);
    }
    toggleValue() {
      const u = this.value.includes(this._value);
      this.value = u ? this.value.filter((F) => F !== this._value) : [...this.value, this._value];
    }
  };
  wD = Object.defineProperty;
  $D = class extends x {
    constructor(u) {
      super(u, false), Z(this, "options"), Z(this, "cursor", 0), this.options = u.options, this.cursor = this.options.findIndex(({ value: F }) => F === u.initialValue), this.cursor === -1 && (this.cursor = 0), this.changeValue(), this.on("cursor", (F) => {
        switch (F) {
          case "left":
          case "up":
            this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1;
            break;
          case "down":
          case "right":
            this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
            break;
        }
        this.changeValue();
      });
    }
    get _value() {
      return this.options[this.cursor];
    }
    changeValue() {
      this.value = this._value.value;
    }
  };
  TD = Object.defineProperty;
  PD = class PD extends x {
    constructor(u) {
      super(u), MD(this, "valueWithCursor", ""), this.on("finalize", () => {
        this.value || (this.value = u.defaultValue), this.valueWithCursor = this.value;
      }), this.on("value", () => {
        if (this.cursor >= this.value.length)
          this.valueWithCursor = `${this.value}${import_picocolors.default.inverse(import_picocolors.default.hidden("_"))}`;
        else {
          const F = this.value.slice(0, this.cursor), t = this.value.slice(this.cursor);
          this.valueWithCursor = `${F}${import_picocolors.default.inverse(t[0])}${t.slice(1)}`;
        }
      });
    }
    get cursor() {
      return this._cursor;
    }
  };
  WD = globalThis.process.platform.startsWith("win");
});

// node_modules/@clack/prompts/dist/index.mjs
import h from "process";
function K2() {
  return h.platform !== "win32" ? h.env.TERM !== "linux" : !!h.env.CI || !!h.env.WT_SESSION || !!h.env.TERMINUS_SUBLIME || h.env.ConEmuTask === "{cmd::Cmder}" || h.env.TERM_PROGRAM === "Terminus-Sublime" || h.env.TERM_PROGRAM === "vscode" || h.env.TERM === "xterm-256color" || h.env.TERM === "alacritty" || h.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
function ye() {
  const s = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
  return new RegExp(s, "g");
}
var import_picocolors2, import_sisteransi2, C, u = (s, n) => C ? s : n, Y, P2, V2, M2, Q2, a2, $2, I2, T2, j2, b2, B, X2, G, H, ee, te, se, re, ie, ne, y2 = (s) => {
  switch (s) {
    case "initial":
    case "active":
      return import_picocolors2.default.cyan(Y);
    case "cancel":
      return import_picocolors2.default.red(P2);
    case "error":
      return import_picocolors2.default.yellow(V2);
    case "submit":
      return import_picocolors2.default.green(M2);
  }
}, E = (s) => {
  const { cursor: n, options: t, style: i } = s, r2 = s.maxItems ?? 1 / 0, o = Math.max(process.stdout.rows - 4, 0), c2 = Math.min(o, Math.max(r2, 5));
  let l2 = 0;
  n >= l2 + c2 - 3 ? l2 = Math.max(Math.min(n - c2 + 3, t.length - c2), 0) : n < l2 + 2 && (l2 = Math.max(n - 2, 0));
  const d2 = c2 < t.length && l2 > 0, p = c2 < t.length && l2 + c2 < t.length;
  return t.slice(l2, l2 + c2).map((S2, f2, x2) => {
    const g2 = f2 === 0 && d2, m2 = f2 === x2.length - 1 && p;
    return g2 || m2 ? import_picocolors2.default.dim("...") : i(S2, f2 + l2 === n);
  });
}, ae = (s) => new PD({ validate: s.validate, placeholder: s.placeholder, defaultValue: s.defaultValue, initialValue: s.initialValue, render() {
  const n = `${import_picocolors2.default.gray(a2)}
${y2(this.state)}  ${s.message}
`, t = s.placeholder ? import_picocolors2.default.inverse(s.placeholder[0]) + import_picocolors2.default.dim(s.placeholder.slice(1)) : import_picocolors2.default.inverse(import_picocolors2.default.hidden("_")), i = this.value ? this.valueWithCursor : t;
  switch (this.state) {
    case "error":
      return `${n.trim()}
${import_picocolors2.default.yellow(a2)}  ${i}
${import_picocolors2.default.yellow($2)}  ${import_picocolors2.default.yellow(this.error)}
`;
    case "submit":
      return `${n}${import_picocolors2.default.gray(a2)}  ${import_picocolors2.default.dim(this.value || s.placeholder)}`;
    case "cancel":
      return `${n}${import_picocolors2.default.gray(a2)}  ${import_picocolors2.default.strikethrough(import_picocolors2.default.dim(this.value ?? ""))}${this.value?.trim() ? `
` + import_picocolors2.default.gray(a2) : ""}`;
    default:
      return `${n}${import_picocolors2.default.cyan(a2)}  ${i}
${import_picocolors2.default.cyan($2)}
`;
  }
} }).prompt(), ce = (s) => {
  const n = s.active ?? "Yes", t = s.inactive ?? "No";
  return new BD({ active: n, inactive: t, initialValue: s.initialValue ?? true, render() {
    const i = `${import_picocolors2.default.gray(a2)}
${y2(this.state)}  ${s.message}
`, r2 = this.value ? n : t;
    switch (this.state) {
      case "submit":
        return `${i}${import_picocolors2.default.gray(a2)}  ${import_picocolors2.default.dim(r2)}`;
      case "cancel":
        return `${i}${import_picocolors2.default.gray(a2)}  ${import_picocolors2.default.strikethrough(import_picocolors2.default.dim(r2))}
${import_picocolors2.default.gray(a2)}`;
      default:
        return `${i}${import_picocolors2.default.cyan(a2)}  ${this.value ? `${import_picocolors2.default.green(I2)} ${n}` : `${import_picocolors2.default.dim(T2)} ${import_picocolors2.default.dim(n)}`} ${import_picocolors2.default.dim("/")} ${this.value ? `${import_picocolors2.default.dim(T2)} ${import_picocolors2.default.dim(t)}` : `${import_picocolors2.default.green(I2)} ${t}`}
${import_picocolors2.default.cyan($2)}
`;
    }
  } }).prompt();
}, le = (s) => {
  const n = (t, i) => {
    const r2 = t.label ?? String(t.value);
    switch (i) {
      case "selected":
        return `${import_picocolors2.default.dim(r2)}`;
      case "active":
        return `${import_picocolors2.default.green(I2)} ${r2} ${t.hint ? import_picocolors2.default.dim(`(${t.hint})`) : ""}`;
      case "cancelled":
        return `${import_picocolors2.default.strikethrough(import_picocolors2.default.dim(r2))}`;
      default:
        return `${import_picocolors2.default.dim(T2)} ${import_picocolors2.default.dim(r2)}`;
    }
  };
  return new $D({ options: s.options, initialValue: s.initialValue, render() {
    const t = `${import_picocolors2.default.gray(a2)}
${y2(this.state)}  ${s.message}
`;
    switch (this.state) {
      case "submit":
        return `${t}${import_picocolors2.default.gray(a2)}  ${n(this.options[this.cursor], "selected")}`;
      case "cancel":
        return `${t}${import_picocolors2.default.gray(a2)}  ${n(this.options[this.cursor], "cancelled")}
${import_picocolors2.default.gray(a2)}`;
      default:
        return `${t}${import_picocolors2.default.cyan(a2)}  ${E({ cursor: this.cursor, options: this.options, maxItems: s.maxItems, style: (i, r2) => n(i, r2 ? "active" : "inactive") }).join(`
${import_picocolors2.default.cyan(a2)}  `)}
${import_picocolors2.default.cyan($2)}
`;
    }
  } }).prompt();
}, $e = (s) => {
  const n = (t, i) => {
    const r2 = t.label ?? String(t.value);
    return i === "active" ? `${import_picocolors2.default.cyan(j2)} ${r2} ${t.hint ? import_picocolors2.default.dim(`(${t.hint})`) : ""}` : i === "selected" ? `${import_picocolors2.default.green(b2)} ${import_picocolors2.default.dim(r2)}` : i === "cancelled" ? `${import_picocolors2.default.strikethrough(import_picocolors2.default.dim(r2))}` : i === "active-selected" ? `${import_picocolors2.default.green(b2)} ${r2} ${t.hint ? import_picocolors2.default.dim(`(${t.hint})`) : ""}` : i === "submitted" ? `${import_picocolors2.default.dim(r2)}` : `${import_picocolors2.default.dim(B)} ${import_picocolors2.default.dim(r2)}`;
  };
  return new vD({ options: s.options, initialValues: s.initialValues, required: s.required ?? true, cursorAt: s.cursorAt, validate(t) {
    if (this.required && t.length === 0)
      return `Please select at least one option.
${import_picocolors2.default.reset(import_picocolors2.default.dim(`Press ${import_picocolors2.default.gray(import_picocolors2.default.bgWhite(import_picocolors2.default.inverse(" space ")))} to select, ${import_picocolors2.default.gray(import_picocolors2.default.bgWhite(import_picocolors2.default.inverse(" enter ")))} to submit`))}`;
  }, render() {
    let t = `${import_picocolors2.default.gray(a2)}
${y2(this.state)}  ${s.message}
`;
    const i = (r2, o) => {
      const c2 = this.value.includes(r2.value);
      return o && c2 ? n(r2, "active-selected") : c2 ? n(r2, "selected") : n(r2, o ? "active" : "inactive");
    };
    switch (this.state) {
      case "submit":
        return `${t}${import_picocolors2.default.gray(a2)}  ${this.options.filter(({ value: r2 }) => this.value.includes(r2)).map((r2) => n(r2, "submitted")).join(import_picocolors2.default.dim(", ")) || import_picocolors2.default.dim("none")}`;
      case "cancel": {
        const r2 = this.options.filter(({ value: o }) => this.value.includes(o)).map((o) => n(o, "cancelled")).join(import_picocolors2.default.dim(", "));
        return `${t}${import_picocolors2.default.gray(a2)}  ${r2.trim() ? `${r2}
${import_picocolors2.default.gray(a2)}` : ""}`;
      }
      case "error": {
        const r2 = this.error.split(`
`).map((o, c2) => c2 === 0 ? `${import_picocolors2.default.yellow($2)}  ${import_picocolors2.default.yellow(o)}` : `   ${o}`).join(`
`);
        return t + import_picocolors2.default.yellow(a2) + "  " + E({ options: this.options, cursor: this.cursor, maxItems: s.maxItems, style: i }).join(`
${import_picocolors2.default.yellow(a2)}  `) + `
` + r2 + `
`;
      }
      default:
        return `${t}${import_picocolors2.default.cyan(a2)}  ${E({ options: this.options, cursor: this.cursor, maxItems: s.maxItems, style: i }).join(`
${import_picocolors2.default.cyan(a2)}  `)}
${import_picocolors2.default.cyan($2)}
`;
    }
  } }).prompt();
}, R2 = (s) => s.replace(ye(), ""), me = (s = "", n = "") => {
  const t = `
${s}
`.split(`
`), i = R2(n).length, r2 = Math.max(t.reduce((c2, l2) => (l2 = R2(l2), l2.length > c2 ? l2.length : c2), 0), i) + 2, o = t.map((c2) => `${import_picocolors2.default.gray(a2)}  ${import_picocolors2.default.dim(c2)}${" ".repeat(r2 - R2(c2).length)}${import_picocolors2.default.gray(a2)}`).join(`
`);
  process.stdout.write(`${import_picocolors2.default.gray(a2)}
${import_picocolors2.default.green(M2)}  ${import_picocolors2.default.reset(n)} ${import_picocolors2.default.gray(G.repeat(Math.max(r2 - i - 1, 1)) + H)}
${o}
${import_picocolors2.default.gray(ee + G.repeat(r2 + 2) + te)}
`);
}, he = (s = "") => {
  process.stdout.write(`${import_picocolors2.default.gray($2)}  ${import_picocolors2.default.red(s)}

`);
}, pe = (s = "") => {
  process.stdout.write(`${import_picocolors2.default.gray(Q2)}  ${s}
`);
}, ge = (s = "") => {
  process.stdout.write(`${import_picocolors2.default.gray(a2)}
${import_picocolors2.default.gray($2)}  ${s}

`);
}, v2, _2 = () => {
  const s = C ? ["\u25D2", "\u25D0", "\u25D3", "\u25D1"] : ["\u2022", "o", "O", "0"], n = C ? 80 : 120;
  let t, i, r2 = false, o = "";
  const c2 = (g2) => {
    const m2 = g2 > 1 ? "Something went wrong" : "Canceled";
    r2 && x2(m2, g2);
  }, l2 = () => c2(2), d2 = () => c2(1), p = () => {
    process.on("uncaughtExceptionMonitor", l2), process.on("unhandledRejection", l2), process.on("SIGINT", d2), process.on("SIGTERM", d2), process.on("exit", c2);
  }, S2 = () => {
    process.removeListener("uncaughtExceptionMonitor", l2), process.removeListener("unhandledRejection", l2), process.removeListener("SIGINT", d2), process.removeListener("SIGTERM", d2), process.removeListener("exit", c2);
  }, f2 = (g2 = "") => {
    r2 = true, t = OD(), o = g2.replace(/\.+$/, ""), process.stdout.write(`${import_picocolors2.default.gray(a2)}
`);
    let m2 = 0, w2 = 0;
    p(), i = setInterval(() => {
      const L2 = import_picocolors2.default.magenta(s[m2]), O2 = ".".repeat(Math.floor(w2)).slice(0, 3);
      process.stdout.write(import_sisteransi2.cursor.move(-999, 0)), process.stdout.write(import_sisteransi2.erase.down(1)), process.stdout.write(`${L2}  ${o}${O2}`), m2 = m2 + 1 < s.length ? m2 + 1 : 0, w2 = w2 < s.length ? w2 + 0.125 : 0;
    }, n);
  }, x2 = (g2 = "", m2 = 0) => {
    o = g2 ?? o, r2 = false, clearInterval(i);
    const w2 = m2 === 0 ? import_picocolors2.default.green(M2) : m2 === 1 ? import_picocolors2.default.red(P2) : import_picocolors2.default.red(V2);
    process.stdout.write(import_sisteransi2.cursor.move(-999, 0)), process.stdout.write(import_sisteransi2.erase.down(1)), process.stdout.write(`${w2}  ${o}
`), S2(), t();
  };
  return { start: f2, stop: x2, message: (g2 = "") => {
    o = g2 ?? o;
  } };
}, ve = async (s, n) => {
  const t = {}, i = Object.keys(s);
  for (const r2 of i) {
    const o = s[r2], c2 = await o({ results: t })?.catch((l2) => {
      throw l2;
    });
    if (typeof n?.onCancel == "function" && lD(c2)) {
      t[r2] = "canceled", n.onCancel({ results: t });
      continue;
    }
    t[r2] = c2;
  }
  return t;
};
var init_dist3 = __esm(() => {
  init_dist2();
  init_dist2();
  import_picocolors2 = __toESM(require_picocolors(), 1);
  import_sisteransi2 = __toESM(require_src(), 1);
  C = K2();
  Y = u("\u25C6", "*");
  P2 = u("\u25A0", "x");
  V2 = u("\u25B2", "x");
  M2 = u("\u25C7", "o");
  Q2 = u("\u250C", "T");
  a2 = u("\u2502", "|");
  $2 = u("\u2514", "\u2014");
  I2 = u("\u25CF", ">");
  T2 = u("\u25CB", " ");
  j2 = u("\u25FB", "[\u2022]");
  b2 = u("\u25FC", "[+]");
  B = u("\u25FB", "[ ]");
  X2 = u("\u25AA", "\u2022");
  G = u("\u2500", "-");
  H = u("\u256E", "+");
  ee = u("\u251C", "+");
  te = u("\u256F", "+");
  se = u("\u25CF", "\u2022");
  re = u("\u25C6", "*");
  ie = u("\u25B2", "!");
  ne = u("\u25A0", "x");
  v2 = { message: (s = "", { symbol: n = import_picocolors2.default.gray(a2) } = {}) => {
    const t = [`${import_picocolors2.default.gray(a2)}`];
    if (s) {
      const [i, ...r2] = s.split(`
`);
      t.push(`${n}  ${i}`, ...r2.map((o) => `${import_picocolors2.default.gray(a2)}  ${o}`));
    }
    process.stdout.write(`${t.join(`
`)}
`);
  }, info: (s) => {
    v2.message(s, { symbol: import_picocolors2.default.blue(se) });
  }, success: (s) => {
    v2.message(s, { symbol: import_picocolors2.default.green(re) });
  }, step: (s) => {
    v2.message(s, { symbol: import_picocolors2.default.green(M2) });
  }, warn: (s) => {
    v2.message(s, { symbol: import_picocolors2.default.yellow(ie) });
  }, warning: (s) => {
    v2.warn(s);
  }, error: (s) => {
    v2.message(s, { symbol: import_picocolors2.default.red(ne) });
  } };
});

// node_modules/ansi-regex/index.js
function ansiRegex({ onlyFirst = false } = {}) {
  const ST = "(?:\\u0007|\\u001B\\u005C|\\u009C)";
  const osc = `(?:\\u001B\\][\\s\\S]*?${ST})`;
  const csi = "[\\u001B\\u009B][[\\]()#;?]*(?:\\d{1,4}(?:[;:]\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]";
  const pattern = `${osc}|${csi}`;
  return new RegExp(pattern, onlyFirst ? undefined : "g");
}

// node_modules/strip-ansi/index.js
function stripAnsi(string) {
  if (typeof string !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
  }
  return string.replace(regex, "");
}
var regex;
var init_strip_ansi = __esm(() => {
  regex = ansiRegex();
});

// node_modules/get-east-asian-width/lookup-data.js
var ambiguousRanges, fullwidthRanges, halfwidthRanges, narrowRanges, wideRanges;
var init_lookup_data = __esm(() => {
  ambiguousRanges = [161, 161, 164, 164, 167, 168, 170, 170, 173, 174, 176, 180, 182, 186, 188, 191, 198, 198, 208, 208, 215, 216, 222, 225, 230, 230, 232, 234, 236, 237, 240, 240, 242, 243, 247, 250, 252, 252, 254, 254, 257, 257, 273, 273, 275, 275, 283, 283, 294, 295, 299, 299, 305, 307, 312, 312, 319, 322, 324, 324, 328, 331, 333, 333, 338, 339, 358, 359, 363, 363, 462, 462, 464, 464, 466, 466, 468, 468, 470, 470, 472, 472, 474, 474, 476, 476, 593, 593, 609, 609, 708, 708, 711, 711, 713, 715, 717, 717, 720, 720, 728, 731, 733, 733, 735, 735, 768, 879, 913, 929, 931, 937, 945, 961, 963, 969, 1025, 1025, 1040, 1103, 1105, 1105, 8208, 8208, 8211, 8214, 8216, 8217, 8220, 8221, 8224, 8226, 8228, 8231, 8240, 8240, 8242, 8243, 8245, 8245, 8251, 8251, 8254, 8254, 8308, 8308, 8319, 8319, 8321, 8324, 8364, 8364, 8451, 8451, 8453, 8453, 8457, 8457, 8467, 8467, 8470, 8470, 8481, 8482, 8486, 8486, 8491, 8491, 8531, 8532, 8539, 8542, 8544, 8555, 8560, 8569, 8585, 8585, 8592, 8601, 8632, 8633, 8658, 8658, 8660, 8660, 8679, 8679, 8704, 8704, 8706, 8707, 8711, 8712, 8715, 8715, 8719, 8719, 8721, 8721, 8725, 8725, 8730, 8730, 8733, 8736, 8739, 8739, 8741, 8741, 8743, 8748, 8750, 8750, 8756, 8759, 8764, 8765, 8776, 8776, 8780, 8780, 8786, 8786, 8800, 8801, 8804, 8807, 8810, 8811, 8814, 8815, 8834, 8835, 8838, 8839, 8853, 8853, 8857, 8857, 8869, 8869, 8895, 8895, 8978, 8978, 9312, 9449, 9451, 9547, 9552, 9587, 9600, 9615, 9618, 9621, 9632, 9633, 9635, 9641, 9650, 9651, 9654, 9655, 9660, 9661, 9664, 9665, 9670, 9672, 9675, 9675, 9678, 9681, 9698, 9701, 9711, 9711, 9733, 9734, 9737, 9737, 9742, 9743, 9756, 9756, 9758, 9758, 9792, 9792, 9794, 9794, 9824, 9825, 9827, 9829, 9831, 9834, 9836, 9837, 9839, 9839, 9886, 9887, 9919, 9919, 9926, 9933, 9935, 9939, 9941, 9953, 9955, 9955, 9960, 9961, 9963, 9969, 9972, 9972, 9974, 9977, 9979, 9980, 9982, 9983, 10045, 10045, 10102, 10111, 11094, 11097, 12872, 12879, 57344, 63743, 65024, 65039, 65533, 65533, 127232, 127242, 127248, 127277, 127280, 127337, 127344, 127373, 127375, 127376, 127387, 127404, 917760, 917999, 983040, 1048573, 1048576, 1114109];
  fullwidthRanges = [12288, 12288, 65281, 65376, 65504, 65510];
  halfwidthRanges = [8361, 8361, 65377, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65512, 65518];
  narrowRanges = [32, 126, 162, 163, 165, 166, 172, 172, 175, 175, 10214, 10221, 10629, 10630];
  wideRanges = [4352, 4447, 8986, 8987, 9001, 9002, 9193, 9196, 9200, 9200, 9203, 9203, 9725, 9726, 9748, 9749, 9776, 9783, 9800, 9811, 9855, 9855, 9866, 9871, 9875, 9875, 9889, 9889, 9898, 9899, 9917, 9918, 9924, 9925, 9934, 9934, 9940, 9940, 9962, 9962, 9970, 9971, 9973, 9973, 9978, 9978, 9981, 9981, 9989, 9989, 9994, 9995, 10024, 10024, 10060, 10060, 10062, 10062, 10067, 10069, 10071, 10071, 10133, 10135, 10160, 10160, 10175, 10175, 11035, 11036, 11088, 11088, 11093, 11093, 11904, 11929, 11931, 12019, 12032, 12245, 12272, 12287, 12289, 12350, 12353, 12438, 12441, 12543, 12549, 12591, 12593, 12686, 12688, 12773, 12783, 12830, 12832, 12871, 12880, 42124, 42128, 42182, 43360, 43388, 44032, 55203, 63744, 64255, 65040, 65049, 65072, 65106, 65108, 65126, 65128, 65131, 94176, 94180, 94192, 94198, 94208, 101589, 101631, 101662, 101760, 101874, 110576, 110579, 110581, 110587, 110589, 110590, 110592, 110882, 110898, 110898, 110928, 110930, 110933, 110933, 110948, 110951, 110960, 111355, 119552, 119638, 119648, 119670, 126980, 126980, 127183, 127183, 127374, 127374, 127377, 127386, 127488, 127490, 127504, 127547, 127552, 127560, 127568, 127569, 127584, 127589, 127744, 127776, 127789, 127797, 127799, 127868, 127870, 127891, 127904, 127946, 127951, 127955, 127968, 127984, 127988, 127988, 127992, 128062, 128064, 128064, 128066, 128252, 128255, 128317, 128331, 128334, 128336, 128359, 128378, 128378, 128405, 128406, 128420, 128420, 128507, 128591, 128640, 128709, 128716, 128716, 128720, 128722, 128725, 128728, 128732, 128735, 128747, 128748, 128756, 128764, 128992, 129003, 129008, 129008, 129292, 129338, 129340, 129349, 129351, 129535, 129648, 129660, 129664, 129674, 129678, 129734, 129736, 129736, 129741, 129756, 129759, 129770, 129775, 129784, 131072, 196605, 196608, 262141];
});

// node_modules/get-east-asian-width/utilities.js
var isInRange = (ranges, codePoint) => {
  let low2 = 0;
  let high2 = Math.floor(ranges.length / 2) - 1;
  while (low2 <= high2) {
    const mid = Math.floor((low2 + high2) / 2);
    const i = mid * 2;
    if (codePoint < ranges[i]) {
      high2 = mid - 1;
    } else if (codePoint > ranges[i + 1]) {
      low2 = mid + 1;
    } else {
      return true;
    }
  }
  return false;
};

// node_modules/get-east-asian-width/lookup.js
function findWideFastPathRange(ranges) {
  let fastPathStart = ranges[0];
  let fastPathEnd = ranges[1];
  for (let index = 0;index < ranges.length; index += 2) {
    const start = ranges[index];
    const end = ranges[index + 1];
    if (commonCjkCodePoint >= start && commonCjkCodePoint <= end) {
      return [start, end];
    }
    if (end - start > fastPathEnd - fastPathStart) {
      fastPathStart = start;
      fastPathEnd = end;
    }
  }
  return [fastPathStart, fastPathEnd];
}
var minimumAmbiguousCodePoint, maximumAmbiguousCodePoint, minimumFullWidthCodePoint, maximumFullWidthCodePoint, minimumHalfWidthCodePoint, maximumHalfWidthCodePoint, minimumNarrowCodePoint, maximumNarrowCodePoint, minimumWideCodePoint, maximumWideCodePoint, commonCjkCodePoint = 19968, wideFastPathStart, wideFastPathEnd, isAmbiguous = (codePoint) => {
  if (codePoint < minimumAmbiguousCodePoint || codePoint > maximumAmbiguousCodePoint) {
    return false;
  }
  return isInRange(ambiguousRanges, codePoint);
}, isFullWidth = (codePoint) => {
  if (codePoint < minimumFullWidthCodePoint || codePoint > maximumFullWidthCodePoint) {
    return false;
  }
  return isInRange(fullwidthRanges, codePoint);
}, isWide = (codePoint) => {
  if (codePoint >= wideFastPathStart && codePoint <= wideFastPathEnd) {
    return true;
  }
  if (codePoint < minimumWideCodePoint || codePoint > maximumWideCodePoint) {
    return false;
  }
  return isInRange(wideRanges, codePoint);
};
var init_lookup = __esm(() => {
  init_lookup_data();
  minimumAmbiguousCodePoint = ambiguousRanges[0];
  maximumAmbiguousCodePoint = ambiguousRanges.at(-1);
  minimumFullWidthCodePoint = fullwidthRanges[0];
  maximumFullWidthCodePoint = fullwidthRanges.at(-1);
  minimumHalfWidthCodePoint = halfwidthRanges[0];
  maximumHalfWidthCodePoint = halfwidthRanges.at(-1);
  minimumNarrowCodePoint = narrowRanges[0];
  maximumNarrowCodePoint = narrowRanges.at(-1);
  minimumWideCodePoint = wideRanges[0];
  maximumWideCodePoint = wideRanges.at(-1);
  [wideFastPathStart, wideFastPathEnd] = findWideFastPathRange(wideRanges);
});

// node_modules/get-east-asian-width/index.js
function validate(codePoint) {
  if (!Number.isSafeInteger(codePoint)) {
    throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
  }
}
function eastAsianWidth(codePoint, { ambiguousAsWide = false } = {}) {
  validate(codePoint);
  if (isFullWidth(codePoint) || isWide(codePoint) || ambiguousAsWide && isAmbiguous(codePoint)) {
    return 2;
  }
  return 1;
}
var init_get_east_asian_width = __esm(() => {
  init_lookup();
});

// node_modules/string-width/index.js
function isDoubleWidthNonRgiEmojiSequence(segment) {
  if (segment.length > 50) {
    return false;
  }
  if (unqualifiedKeycapRegex.test(segment)) {
    return true;
  }
  if (segment.includes("\u200D")) {
    const pictographics = segment.match(extendedPictographicRegex);
    return pictographics !== null && pictographics.length >= 2;
  }
  return false;
}
function baseVisible(segment) {
  return segment.replace(leadingNonPrintingRegex, "");
}
function isZeroWidthCluster(segment) {
  return zeroWidthClusterRegex.test(segment);
}
function trailingHalfwidthWidth(segment, eastAsianWidthOptions) {
  let extra = 0;
  if (segment.length > 1) {
    for (const char of segment.slice(1)) {
      if (char >= "\uFF00" && char <= "\uFFEF") {
        extra += eastAsianWidth(char.codePointAt(0), eastAsianWidthOptions);
      }
    }
  }
  return extra;
}
function stringWidth(input, options = {}) {
  if (typeof input !== "string" || input.length === 0) {
    return 0;
  }
  const {
    ambiguousIsNarrow = true,
    countAnsiEscapeCodes = false
  } = options;
  let string = input;
  if (!countAnsiEscapeCodes && (string.includes("\x1B") || string.includes("\x9B"))) {
    string = stripAnsi(string);
  }
  if (string.length === 0) {
    return 0;
  }
  if (/^[\u0020-\u007E]*$/.test(string)) {
    return string.length;
  }
  let width = 0;
  const eastAsianWidthOptions = { ambiguousAsWide: !ambiguousIsNarrow };
  for (const { segment } of segmenter.segment(string)) {
    if (isZeroWidthCluster(segment)) {
      continue;
    }
    if (rgiEmojiRegex.test(segment) || isDoubleWidthNonRgiEmojiSequence(segment)) {
      width += 2;
      continue;
    }
    const codePoint = baseVisible(segment).codePointAt(0);
    width += eastAsianWidth(codePoint, eastAsianWidthOptions);
    width += trailingHalfwidthWidth(segment, eastAsianWidthOptions);
  }
  return width;
}
var segmenter, zeroWidthClusterRegex, leadingNonPrintingRegex, rgiEmojiRegex, unqualifiedKeycapRegex, extendedPictographicRegex;
var init_string_width = __esm(() => {
  init_strip_ansi();
  init_get_east_asian_width();
  segmenter = new Intl.Segmenter;
  zeroWidthClusterRegex = /^(?:\p{Default_Ignorable_Code_Point}|\p{Control}|\p{Format}|\p{Mark}|\p{Surrogate})+$/v;
  leadingNonPrintingRegex = /^[\p{Default_Ignorable_Code_Point}\p{Control}\p{Format}\p{Mark}\p{Surrogate}]+/v;
  rgiEmojiRegex = /^\p{RGI_Emoji}$/v;
  unqualifiedKeycapRegex = /^[\d#*]\u20E3$/;
  extendedPictographicRegex = /\p{Extended_Pictographic}/gu;
});

// node_modules/emoji-regex/index.mjs
var emoji_regex_default = () => {
  return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED8\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])))?))?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE8A\uDE8E-\uDEC2\uDEC6\uDEC8\uDECD-\uDEDC\uDEDF-\uDEEA\uDEEF]|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
};

// node_modules/wrap-ansi/node_modules/string-width/index.js
function stringWidth2(string, options = {}) {
  if (typeof string !== "string" || string.length === 0) {
    return 0;
  }
  const {
    ambiguousIsNarrow = true,
    countAnsiEscapeCodes = false
  } = options;
  if (!countAnsiEscapeCodes) {
    string = stripAnsi(string);
  }
  if (string.length === 0) {
    return 0;
  }
  let width = 0;
  const eastAsianWidthOptions = { ambiguousAsWide: !ambiguousIsNarrow };
  for (const { segment: character } of segmenter2.segment(string)) {
    const codePoint = character.codePointAt(0);
    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {
      continue;
    }
    if (codePoint >= 8203 && codePoint <= 8207 || codePoint === 65279) {
      continue;
    }
    if (codePoint >= 768 && codePoint <= 879 || codePoint >= 6832 && codePoint <= 6911 || codePoint >= 7616 && codePoint <= 7679 || codePoint >= 8400 && codePoint <= 8447 || codePoint >= 65056 && codePoint <= 65071) {
      continue;
    }
    if (codePoint >= 55296 && codePoint <= 57343) {
      continue;
    }
    if (codePoint >= 65024 && codePoint <= 65039) {
      continue;
    }
    if (defaultIgnorableCodePointRegex.test(character)) {
      continue;
    }
    if (emoji_regex_default().test(character)) {
      width += 2;
      continue;
    }
    width += eastAsianWidth(codePoint, eastAsianWidthOptions);
  }
  return width;
}
var segmenter2, defaultIgnorableCodePointRegex;
var init_string_width2 = __esm(() => {
  init_strip_ansi();
  init_get_east_asian_width();
  segmenter2 = new Intl.Segmenter;
  defaultIgnorableCodePointRegex = /^\p{Default_Ignorable_Code_Point}$/u;
});

// node_modules/ansi-styles/index.js
function assembleStyles() {
  const codes = new Map;
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ANSI_BACKGROUND_OFFSET = 10, wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`, wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`, wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`, styles, modifierNames, foregroundColorNames, backgroundColorNames, colorNames, ansiStyles, ansi_styles_default;
var init_ansi_styles = __esm(() => {
  styles = {
    modifier: {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      overline: [53, 55],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29]
    },
    color: {
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      blackBright: [90, 39],
      gray: [90, 39],
      grey: [90, 39],
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39]
    },
    bgColor: {
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgBlackBright: [100, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    }
  };
  modifierNames = Object.keys(styles.modifier);
  foregroundColorNames = Object.keys(styles.color);
  backgroundColorNames = Object.keys(styles.bgColor);
  colorNames = [...foregroundColorNames, ...backgroundColorNames];
  ansiStyles = assembleStyles();
  ansi_styles_default = ansiStyles;
});

// node_modules/wrap-ansi/index.js
function wrapAnsi(string, columns, options) {
  return String(string).normalize().replaceAll(`\r
`, `
`).split(`
`).map((line) => exec(line, columns, options)).join(`
`);
}
var ESCAPES, END_CODE = 39, ANSI_ESCAPE_BELL = "\x07", ANSI_CSI = "[", ANSI_OSC = "]", ANSI_SGR_TERMINATOR = "m", ANSI_ESCAPE_LINK, wrapAnsiCode = (code) => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`, wrapAnsiHyperlink = (url) => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${url}${ANSI_ESCAPE_BELL}`, wordLengths = (string) => string.split(" ").map((character) => stringWidth2(character)), wrapWord = (rows, word, columns) => {
  const characters = [...word];
  let isInsideEscape = false;
  let isInsideLinkEscape = false;
  let visible = stringWidth2(stripAnsi(rows.at(-1)));
  for (const [index, character] of characters.entries()) {
    const characterLength = stringWidth2(character);
    if (visible + characterLength <= columns) {
      rows[rows.length - 1] += character;
    } else {
      rows.push(character);
      visible = 0;
    }
    if (ESCAPES.has(character)) {
      isInsideEscape = true;
      const ansiEscapeLinkCandidate = characters.slice(index + 1, index + 1 + ANSI_ESCAPE_LINK.length).join("");
      isInsideLinkEscape = ansiEscapeLinkCandidate === ANSI_ESCAPE_LINK;
    }
    if (isInsideEscape) {
      if (isInsideLinkEscape) {
        if (character === ANSI_ESCAPE_BELL) {
          isInsideEscape = false;
          isInsideLinkEscape = false;
        }
      } else if (character === ANSI_SGR_TERMINATOR) {
        isInsideEscape = false;
      }
      continue;
    }
    visible += characterLength;
    if (visible === columns && index < characters.length - 1) {
      rows.push("");
      visible = 0;
    }
  }
  if (!visible && rows.at(-1).length > 0 && rows.length > 1) {
    rows[rows.length - 2] += rows.pop();
  }
}, stringVisibleTrimSpacesRight = (string) => {
  const words = string.split(" ");
  let last = words.length;
  while (last > 0) {
    if (stringWidth2(words[last - 1]) > 0) {
      break;
    }
    last--;
  }
  if (last === words.length) {
    return string;
  }
  return words.slice(0, last).join(" ") + words.slice(last).join("");
}, exec = (string, columns, options = {}) => {
  if (options.trim !== false && string.trim() === "") {
    return "";
  }
  let returnValue = "";
  let escapeCode;
  let escapeUrl;
  const lengths = wordLengths(string);
  let rows = [""];
  for (const [index, word] of string.split(" ").entries()) {
    if (options.trim !== false) {
      rows[rows.length - 1] = rows.at(-1).trimStart();
    }
    let rowLength = stringWidth2(rows.at(-1));
    if (index !== 0) {
      if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
        rows.push("");
        rowLength = 0;
      }
      if (rowLength > 0 || options.trim === false) {
        rows[rows.length - 1] += " ";
        rowLength++;
      }
    }
    if (options.hard && lengths[index] > columns) {
      const remainingColumns = columns - rowLength;
      const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
      const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
      if (breaksStartingNextLine < breaksStartingThisLine) {
        rows.push("");
      }
      wrapWord(rows, word, columns);
      continue;
    }
    if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
      if (options.wordWrap === false && rowLength < columns) {
        wrapWord(rows, word, columns);
        continue;
      }
      rows.push("");
    }
    if (rowLength + lengths[index] > columns && options.wordWrap === false) {
      wrapWord(rows, word, columns);
      continue;
    }
    rows[rows.length - 1] += word;
  }
  if (options.trim !== false) {
    rows = rows.map((row) => stringVisibleTrimSpacesRight(row));
  }
  const preString = rows.join(`
`);
  const pre = [...preString];
  let preStringIndex = 0;
  for (const [index, character] of pre.entries()) {
    returnValue += character;
    if (ESCAPES.has(character)) {
      const { groups } = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(preString.slice(preStringIndex)) || { groups: {} };
      if (groups.code !== undefined) {
        const code2 = Number.parseFloat(groups.code);
        escapeCode = code2 === END_CODE ? undefined : code2;
      } else if (groups.uri !== undefined) {
        escapeUrl = groups.uri.length === 0 ? undefined : groups.uri;
      }
    }
    const code = ansi_styles_default.codes.get(Number(escapeCode));
    if (pre[index + 1] === `
`) {
      if (escapeUrl) {
        returnValue += wrapAnsiHyperlink("");
      }
      if (escapeCode && code) {
        returnValue += wrapAnsiCode(code);
      }
    } else if (character === `
`) {
      if (escapeCode && code) {
        returnValue += wrapAnsiCode(escapeCode);
      }
      if (escapeUrl) {
        returnValue += wrapAnsiHyperlink(escapeUrl);
      }
    }
    preStringIndex += character.length;
  }
  return returnValue;
};
var init_wrap_ansi = __esm(() => {
  init_string_width2();
  init_strip_ansi();
  init_ansi_styles();
  ESCAPES = new Set([
    "\x1B",
    "\x9B"
  ]);
  ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;
});

// src/cli/ui/text-format.ts
function getTerminalWidth() {
  return process.stdout.columns || FALLBACK_WIDTH;
}
function getEffectiveWidth(margin = DEFAULT_MARGIN) {
  const totalMargin = margin * 2;
  const effectiveWidth = getTerminalWidth() - totalMargin;
  return Math.max(effectiveWidth, MIN_EFFECTIVE_WIDTH);
}
function wrapText(text, maxWidth) {
  const width = maxWidth ?? getEffectiveWidth();
  return wrapAnsi(text, width, {
    hard: true,
    wordWrap: true
  });
}
function wrapTextWithMargin(text, margin = DEFAULT_MARGIN) {
  const effectiveWidth = getEffectiveWidth(margin);
  const wrapped = wrapAnsi(text, effectiveWidth, {
    hard: true,
    wordWrap: true
  });
  const marginPad = " ".repeat(margin);
  return wrapped.split(`
`).map((line) => `${marginPad}${line}`).join(`
`);
}
function getVisualWidth(text) {
  return stringWidth(text);
}
function createStreamRenderer(options = {}) {
  const {
    margin = DEFAULT_MARGIN,
    maxWidth,
    output = (text) => process.stdout.write(text)
  } = options;
  const effectiveWidth = maxWidth ?? getEffectiveWidth(margin);
  const marginPad = " ".repeat(margin);
  let buffer = "";
  const outputLine = (line) => {
    if (line === "") {
      output(`
`);
      return;
    }
    const wrapped = wrapAnsi(line, effectiveWidth, {
      hard: true,
      wordWrap: true
    });
    const wrappedLines = wrapped.split(`
`);
    for (let i = 0;i < wrappedLines.length; i++) {
      const wrappedLine = wrappedLines[i] ?? "";
      output(`${marginPad}${wrappedLine}
`);
    }
  };
  const handler = (chunk) => {
    buffer += chunk;
    let newlineIndex = buffer.indexOf(`
`);
    while (newlineIndex !== -1) {
      const line = buffer.slice(0, newlineIndex);
      buffer = buffer.slice(newlineIndex + 1);
      outputLine(line);
      newlineIndex = buffer.indexOf(`
`);
    }
  };
  const flush = () => {
    if (buffer.length > 0) {
      const wrapped = wrapAnsi(buffer, effectiveWidth, {
        hard: true,
        wordWrap: true
      });
      const wrappedLines = wrapped.split(`
`);
      for (let i = 0;i < wrappedLines.length; i++) {
        const line = wrappedLines[i] ?? "";
        if (i === wrappedLines.length - 1) {
          output(`${marginPad}${line}`);
        } else {
          output(`${marginPad}${line}
`);
        }
      }
      buffer = "";
    }
  };
  const reset = () => {
    buffer = "";
  };
  return { handler, flush, reset };
}
function truncateText(text, maxWidth, suffix = "...") {
  const textWidth = getVisualWidth(text);
  if (textWidth <= maxWidth) {
    return text;
  }
  const suffixWidth = getVisualWidth(suffix);
  const targetWidth = maxWidth - suffixWidth;
  if (targetWidth <= 0) {
    return suffix.slice(0, maxWidth);
  }
  let result = "";
  let currentWidth = 0;
  for (const char of text) {
    const charWidth = getVisualWidth(char);
    if (currentWidth + charWidth > targetWidth) {
      break;
    }
    result += char;
    currentWidth += charWidth;
  }
  return result + suffix;
}
function centerText(text, width) {
  const targetWidth = width ?? getTerminalWidth();
  const textWidth = getVisualWidth(text);
  if (textWidth >= targetWidth) {
    return text;
  }
  const totalPadding = targetWidth - textWidth;
  const leftPad = Math.floor(totalPadding / 2);
  const rightPad = totalPadding - leftPad;
  return " ".repeat(leftPad) + text + " ".repeat(rightPad);
}
function createDivider(char = "\u2500", width) {
  const targetWidth = width ?? getEffectiveWidth();
  return char.repeat(targetWidth);
}
var DEFAULT_MARGIN = 2, FALLBACK_WIDTH = 80, MIN_EFFECTIVE_WIDTH = 40;
var init_text_format = __esm(() => {
  init_string_width();
  init_wrap_ansi();
});

// src/cli/ui/boundaries-display.ts
function formatBoundaryList(patterns, options = {}) {
  const { maxItems = DEFAULT_MAX_ITEMS, wrapIndent = DEFAULT_WRAP_INDENT } = options;
  if (patterns.length === 0) {
    return "none";
  }
  const useVertical = options.useVerticalList !== undefined ? options.useVerticalList : patterns.length > VERTICAL_LIST_THRESHOLD;
  const maxWidth = options.maxWidth ?? getEffectiveWidth(2);
  const displayPatterns = patterns.slice(0, maxItems);
  const truncatedCount = patterns.length - displayPatterns.length;
  if (useVertical) {
    return formatVerticalList(displayPatterns, truncatedCount, wrapIndent);
  }
  return formatInlineList(displayPatterns, truncatedCount, maxWidth, wrapIndent);
}
function formatVerticalList(patterns, truncatedCount, indent) {
  const indentStr = " ".repeat(indent);
  const lines = patterns.map((pattern) => `${indentStr}- ${pattern}`);
  if (truncatedCount > 0) {
    lines.push(`${indentStr}  ... and ${truncatedCount} more`);
  }
  return lines.join(`
`);
}
function formatInlineList(patterns, truncatedCount, maxWidth, indent) {
  const joined = patterns.join(", ");
  if (truncatedCount > 0) {
    const suffix = ` ... and ${truncatedCount} more`;
    const fullText = joined + suffix;
    if (getVisualWidth(fullText) <= maxWidth) {
      return fullText;
    }
    return wrapInlineList(patterns, truncatedCount, maxWidth, indent);
  }
  if (getVisualWidth(joined) <= maxWidth) {
    return joined;
  }
  return wrapInlineList(patterns, truncatedCount, maxWidth, indent);
}
function wrapInlineList(patterns, truncatedCount, maxWidth, indent) {
  const indentStr = " ".repeat(indent);
  const lines = [];
  let currentLine = "";
  for (let i = 0;i < patterns.length; i++) {
    const pattern = patterns[i] ?? "";
    const separator = i === 0 ? "" : ", ";
    const addition = separator + pattern;
    const testLine = currentLine + addition;
    const testWidth = getVisualWidth(testLine);
    if (testWidth > maxWidth && currentLine.length > 0) {
      lines.push(currentLine);
      currentLine = indentStr + pattern;
    } else {
      currentLine = testLine;
    }
  }
  if (currentLine) {
    if (truncatedCount > 0) {
      const suffix = `, ... and ${truncatedCount} more`;
      if (getVisualWidth(currentLine + suffix) > maxWidth) {
        lines.push(currentLine);
        lines.push(`${indentStr}... and ${truncatedCount} more`);
      } else {
        lines.push(currentLine + suffix);
      }
    } else {
      lines.push(currentLine);
    }
  }
  return lines.join(`
`);
}
function formatBoundariesDisplay(neverTouch, requireReview, options = {}) {
  const lines = ["Protect critical files from agent modifications."];
  if (neverTouch.length > 0) {
    const useVertical = neverTouch.length > VERTICAL_LIST_THRESHOLD;
    if (useVertical) {
      lines.push("");
      lines.push("never_touch:");
      lines.push(formatBoundaryList(neverTouch, { ...options, useVerticalList: true }));
    } else {
      lines.push(`never_touch: ${formatBoundaryList(neverTouch, options)}`);
    }
  } else {
    lines.push("never_touch: none");
  }
  if (requireReview.length > 0) {
    const useVertical = requireReview.length > VERTICAL_LIST_THRESHOLD;
    if (useVertical) {
      lines.push("");
      lines.push("require_review:");
      lines.push(formatBoundaryList(requireReview, { ...options, useVerticalList: true }));
    } else {
      lines.push(`require_review: ${formatBoundaryList(requireReview, options)}`);
    }
  } else {
    lines.push("require_review: none");
  }
  return lines.join(`
`);
}
function truncatePattern(pattern, maxWidth) {
  if (getVisualWidth(pattern) <= maxWidth) {
    return pattern;
  }
  const ellipsis = "...";
  const targetWidth = maxWidth - ellipsis.length;
  if (targetWidth <= 0) {
    return ellipsis.slice(0, maxWidth);
  }
  if (pattern.includes("/")) {
    const parts = pattern.split("/");
    let result2 = "";
    for (let i = parts.length - 1;i >= 0; i--) {
      const test = parts.slice(i).join("/");
      if (getVisualWidth(ellipsis + test) <= maxWidth) {
        result2 = ellipsis + test;
      } else {
        break;
      }
    }
    if (result2) {
      return result2;
    }
  }
  let result = "";
  for (const char of pattern) {
    if (getVisualWidth(result + char + ellipsis) > maxWidth) {
      break;
    }
    result += char;
  }
  return result + ellipsis;
}
var DEFAULT_MAX_ITEMS = 15, VERTICAL_LIST_THRESHOLD = 5, DEFAULT_WRAP_INDENT = 2;
var init_boundaries_display = __esm(() => {
  init_text_format();
});

// src/config/init.ts
var exports_init = {};
__export(exports_init, {
  runInit: () => runInit
});
import { existsSync as existsSync7, mkdirSync } from "fs";
import { join as join9 } from "path";
function getConfidenceIndicator(confidence) {
  switch (confidence) {
    case "high":
      return "\u25CF";
    case "medium":
      return "\u25D0";
    case "low":
      return "\u25CB";
    default:
      return "?";
  }
}
function formatDetected(label, detected, fallback = "not detected") {
  if (!detected) {
    return `${getConfidenceIndicator(null)} ${label}: ${fallback}`;
  }
  return `${getConfidenceIndicator(detected.confidence)} ${label}: ${detected.value}`;
}
function configExists(projectRoot) {
  const configPath = join9(projectRoot, CONFIG_DIR2, CONFIG_FILE2);
  return existsSync7(configPath);
}
async function writeConfig(projectRoot, config) {
  const configDir = join9(projectRoot, CONFIG_DIR2);
  const configPath = join9(configDir, CONFIG_FILE2);
  if (!existsSync7(configDir)) {
    mkdirSync(configDir, { recursive: true });
  }
  const yaml = $stringify(config, {
    indent: 2,
    lineWidth: 100,
    nullStr: "null"
  });
  await Bun.write(configPath, yaml);
  return configPath;
}
async function displayScanProgress(result) {
  const lines = [];
  lines.push(`\u2713 Project detected (${result.scanDurationMs}ms)`);
  const commandCount = [
    result.commands.build,
    result.commands.lint,
    result.commands.test,
    result.commands.typecheck
  ].filter(Boolean).length;
  lines.push(`\u2713 Commands detected: ${commandCount}/4`);
  lines.push(`\u2713 Rules inferred: ${result.rules.length}`);
  const boundaryCount = result.boundaries.never_touch.length + result.boundaries.require_review.length;
  lines.push(`\u2713 Boundaries detected: ${boundaryCount} patterns`);
  lines.push(`\u2713 Sandbox configured: ${result.sandbox.allowed_env.length} env vars`);
  me(lines.join(`
`), `Scan complete in ${result.scanDurationMs}ms`);
  if (result.warnings.length > 0) {
    for (const warning of result.warnings) {
      v2.warn(warning);
    }
  }
}
async function confirmProjectSection(result) {
  const projectNote = [
    formatDetected("Name", result.name),
    formatDetected("Language", result.language),
    formatDetected("Framework", result.framework),
    formatDetected("Runtime", result.runtime),
    formatDetected("Database", result.database)
  ].join(`
`);
  me(projectNote, "Project");
  const confirmed = await ce({
    message: "Everything look right?",
    initialValue: true
  });
  if (lD(confirmed))
    return confirmed;
  if (confirmed) {
    const project = {
      name: result.name?.value ?? "",
      language: result.language?.value ?? "typescript",
      runtime: result.runtime?.value ?? "node"
    };
    if (result.framework?.value) {
      project.framework = result.framework.value;
    }
    if (result.database?.value) {
      project.database = result.database.value;
    }
    return project;
  }
  let wasCancelled = false;
  const edited = await ve({
    name: () => ae({
      message: "Project name",
      initialValue: result.name?.value ?? "",
      validate: (value) => {
        if (!value.trim())
          return "Project name is required";
        return;
      }
    }),
    language: () => le({
      message: "Primary language",
      initialValue: result.language?.value ?? "typescript",
      options: [
        { value: "typescript", label: "TypeScript" },
        { value: "javascript", label: "JavaScript" },
        { value: "python", label: "Python" },
        { value: "go", label: "Go" },
        { value: "rust", label: "Rust" }
      ]
    }),
    framework: () => ae({
      message: "Framework (optional)",
      initialValue: result.framework?.value ?? "",
      placeholder: "e.g., react, nextjs, fastapi"
    }),
    runtime: () => le({
      message: "Runtime",
      initialValue: result.runtime?.value ?? "node",
      options: [
        { value: "bun", label: "Bun" },
        { value: "node", label: "Node.js" },
        { value: "deno", label: "Deno" },
        { value: "python", label: "Python" },
        { value: "go", label: "Go runtime" }
      ]
    }),
    database: () => ae({
      message: "Database (optional)",
      initialValue: result.database?.value ?? "",
      placeholder: "e.g., postgresql, mongodb, sqlite"
    })
  }, {
    onCancel: () => {
      wasCancelled = true;
      he("Init cancelled.");
    }
  });
  if (wasCancelled) {
    return Symbol.for("cancel");
  }
  const editedProject = {
    name: edited.name,
    language: edited.language,
    runtime: edited.runtime
  };
  const frameworkVal = edited.framework;
  if (frameworkVal) {
    editedProject.framework = frameworkVal;
  }
  const databaseVal = edited.database;
  if (databaseVal) {
    editedProject.database = databaseVal;
  }
  return editedProject;
}
async function confirmRequiredCommand(commandName, detected, placeholder, examples) {
  if (detected) {
    v2.info(`${getConfidenceIndicator(detected.confidence)} ${commandName}: ${detected.value}`);
    const confirmed = await ce({
      message: `Use this ${commandName.toLowerCase()} command?`,
      initialValue: true
    });
    if (lD(confirmed))
      return confirmed;
    if (confirmed) {
      return detected.value;
    }
  } else {
    const exampleLines = examples.map((e2) => `    ${e2}`).join(`
`);
    v2.warn(`${commandName} command is required.
  KARIMO runs ${commandName.toLowerCase()} after every PR to verify code integrity.

  Common examples:
${exampleLines}`);
  }
  const input = await ae({
    message: `${commandName} command`,
    placeholder,
    validate: (value) => {
      if (!value.trim())
        return `${commandName} command is required`;
      return;
    }
  });
  if (lD(input))
    return input;
  return input;
}
async function confirmRecommendedCommand(commandName, detected, placeholder, recommendations, usageDescription) {
  if (detected) {
    v2.info(`${getConfidenceIndicator(detected.confidence)} ${commandName}: ${detected.value}`);
    const confirmed = await ce({
      message: `Use this ${commandName.toLowerCase()} command?`,
      initialValue: true
    });
    if (lD(confirmed))
      return confirmed;
    if (confirmed) {
      return detected.value;
    }
    const input2 = await ae({
      message: `${commandName} command`,
      initialValue: detected.value,
      placeholder
    });
    if (lD(input2))
      return input2;
    const trimmed2 = input2.trim();
    if (!trimmed2) {
      v2.info(`${commandName} skipped \u2014 ${usageDescription}`);
      return null;
    }
    return trimmed2;
  }
  const suggestionLines = formatRecommendations(recommendations);
  v2.warn(`No ${commandName.toLowerCase()} command detected.

  ${usageDescription}

  Suggestions for your stack:
${suggestionLines}`);
  const action = await le({
    message: "What would you like to do?",
    options: [
      { value: "provide", label: `Provide a ${commandName.toLowerCase()} command` },
      { value: "skip", label: "Skip for now (you can add it later)" }
    ]
  });
  if (lD(action))
    return action;
  if (action === "skip") {
    v2.info(`${commandName} skipped \u2014 you can add this later by editing .karimo/config.yaml`);
    return null;
  }
  const input = await ae({
    message: `${commandName} command`,
    placeholder
  });
  if (lD(input))
    return input;
  const trimmed = input.trim();
  if (!trimmed) {
    v2.info(`${commandName} skipped \u2014 you can add this later by editing .karimo/config.yaml`);
    return null;
  }
  return trimmed;
}
async function confirmCommandsSection(result) {
  const commandsNote = [
    formatDetected("Build", result.commands.build, "required"),
    formatDetected("Lint", result.commands.lint, "required"),
    formatDetected("Test", result.commands.test, "recommended"),
    formatDetected("Typecheck", result.commands.typecheck, "recommended")
  ].join(`
`);
  me(commandsNote, "Commands");
  const allRequiredDetected = result.commands.build && result.commands.lint;
  const allRecommendedDetected = result.commands.test && result.commands.typecheck;
  if (allRequiredDetected && allRecommendedDetected) {
    const confirmed = await ce({
      message: "Everything look right?",
      initialValue: true
    });
    if (lD(confirmed))
      return confirmed;
    if (confirmed) {
      return {
        build: result.commands.build?.value ?? "",
        lint: result.commands.lint?.value ?? "",
        test: result.commands.test?.value ?? null,
        typecheck: result.commands.typecheck?.value ?? null
      };
    }
  }
  const recommendations = getCommandRecommendations(result.runtime?.value ?? null, result.language?.value ?? null);
  v2.step("Required commands");
  const build = await confirmRequiredCommand("Build", result.commands.build, "bun run build", [
    "Next.js:  bun run build / npm run build",
    "Python:   python -m build",
    "Go:       go build ./..."
  ]);
  if (lD(build))
    return build;
  const lint = await confirmRequiredCommand("Lint", result.commands.lint, "bun run lint", [
    "ESLint:   npx eslint . / bun run lint",
    "Biome:    bunx biome check .",
    "Ruff:     ruff check .",
    "golangci: golangci-lint run"
  ]);
  if (lD(lint))
    return lint;
  v2.step("Recommended commands (can be skipped)");
  const test = await confirmRecommendedCommand("Test", result.commands.test, "bun test", recommendations.test, "KARIMO uses test as part of post-merge integration checks.");
  if (lD(test))
    return test;
  const typecheck = await confirmRecommendedCommand("Typecheck", result.commands.typecheck, "bun run typecheck", recommendations.typecheck, "KARIMO runs typecheck in pre-PR checks to catch type errors.");
  if (lD(typecheck))
    return typecheck;
  return {
    build,
    lint,
    test,
    typecheck
  };
}
async function confirmRulesSection(result) {
  if (result.rules.length === 0) {
    const rulesInput = await ae({
      message: "Project rules (comma-separated)",
      placeholder: "No any types, Use Zod for validation, Prefer async/await",
      validate: (value) => {
        if (!value.trim())
          return "At least one rule is required";
        return;
      }
    });
    if (lD(rulesInput))
      return rulesInput;
    return rulesInput.split(",").map((r2) => r2.trim()).filter((r2) => r2.length > 0);
  }
  const rulesNote = result.rules.map((r2) => `${getConfidenceIndicator(r2.confidence)} ${r2.value}`).join(`
`);
  me(rulesNote, "Rules");
  const confirmed = await ce({
    message: "Use these rules? (You can add more afterward)",
    initialValue: true
  });
  if (lD(confirmed))
    return confirmed;
  if (confirmed) {
    return result.rules.map((r2) => r2.value);
  }
  const selected = await $e({
    message: "Select rules to include",
    options: result.rules.map((r2) => ({
      value: r2.value,
      label: r2.value,
      hint: r2.source
    })),
    initialValues: result.rules.map((r2) => r2.value),
    required: false
  });
  if (lD(selected))
    return selected;
  const addMore = await ce({
    message: "Add custom rules?",
    initialValue: false
  });
  if (lD(addMore))
    return addMore;
  let rules = selected;
  if (addMore) {
    const customRules = await ae({
      message: "Additional rules (comma-separated)",
      placeholder: "Rule 1, Rule 2, Rule 3"
    });
    if (lD(customRules))
      return customRules;
    if (customRules.trim()) {
      const custom2 = customRules.split(",").map((r2) => r2.trim()).filter((r2) => r2.length > 0);
      rules = [...rules, ...custom2];
    }
  }
  if (rules.length === 0) {
    const rulesInput = await ae({
      message: "At least one rule is required",
      placeholder: "No any types, Use Zod for validation",
      validate: (value) => {
        if (!value.trim())
          return "At least one rule is required";
        return;
      }
    });
    if (lD(rulesInput))
      return rulesInput;
    rules = rulesInput.split(",").map((r2) => r2.trim()).filter((r2) => r2.length > 0);
  }
  return rules;
}
async function confirmSandboxSection(result) {
  const detectedVars = result.sandbox.allowed_env.map((v3) => v3.value);
  const defaultVars = detectedVars.length > 0 ? detectedVars : COMMON_ALLOWED_ENV;
  const sandboxInput = await ae({
    message: "Allowed environment variables (comma-separated)",
    placeholder: defaultVars.join(", "),
    initialValue: defaultVars.join(", "),
    validate: (value) => {
      if (!value.trim())
        return "At least one environment variable is required";
      return;
    }
  });
  if (lD(sandboxInput))
    return sandboxInput;
  return sandboxInput.split(",").map((e2) => e2.trim()).filter((e2) => e2.length > 0);
}
function buildBoundaries(result) {
  return {
    never_touch: result.boundaries.never_touch.map((b3) => b3.value),
    require_review: result.boundaries.require_review.map((b3) => b3.value)
  };
}
function collectBoundariesSources(result) {
  const sources = new Set;
  for (const item of result.boundaries.never_touch) {
    sources.add(item.source);
  }
  for (const item of result.boundaries.require_review) {
    sources.add(item.source);
  }
  const sourceList = [...sources].slice(0, 3);
  return sources.size > 3 ? `${sourceList.join(", ")}, ...` : sourceList.join(", ") || "defaults";
}
function displaySummary(config) {
  const lines = [];
  lines.push(`Project: ${config.project.name}`);
  lines.push(`Language: ${config.project.language}`);
  if (config.project.framework) {
    lines.push(`Framework: ${config.project.framework}`);
  }
  lines.push(`Runtime: ${config.project.runtime}`);
  if (config.project.database) {
    lines.push(`Database: ${config.project.database}`);
  }
  lines.push("");
  lines.push(`Commands: ${Object.keys(config.commands).length}`);
  lines.push(`Rules: ${config.rules.length}`);
  lines.push(`Boundaries: ${config.boundaries.never_touch.length} never_touch, ${config.boundaries.require_review.length} require_review`);
  lines.push(`Allowed env vars: ${config.sandbox.allowed_env.length}`);
  me(lines.join(`
`), "Configuration Summary");
}
async function runInit(projectRoot = process.cwd()) {
  pe("KARIMO Configuration");
  if (configExists(projectRoot)) {
    const shouldOverwrite = await ce({
      message: "Configuration file already exists. Overwrite?",
      initialValue: false
    });
    if (lD(shouldOverwrite) || !shouldOverwrite) {
      he("Init cancelled.");
      return { success: false, cancelled: true };
    }
  }
  const scanSpinner = _2();
  scanSpinner.start("Scanning project...");
  let result;
  try {
    result = await detectProject(projectRoot);
    scanSpinner.stop("Scan complete");
  } catch (error) {
    scanSpinner.stop("Scan failed");
    he(`Detection error: ${error.message}`);
    return { success: false, cancelled: false };
  }
  await displayScanProgress(result);
  const project = await confirmProjectSection(result);
  if (lD(project)) {
    he("Init cancelled.");
    return { success: false, cancelled: true };
  }
  me(`These commands verify agent work after every task.
PRs are only created when all commands pass.`, "Verification Commands");
  const commands = await confirmCommandsSection(result);
  if (lD(commands)) {
    he("Init cancelled.");
    return { success: false, cancelled: true };
  }
  me(`Coding standards that guide agent behavior.
Agents follow these patterns and flag deviations.`, "Coding Standards");
  const rules = await confirmRulesSection(result);
  if (lD(rules)) {
    he("Init cancelled.");
    return { success: false, cancelled: true };
  }
  me(`Agents run in a sandboxed environment.
Only listed variables are exposed to prevent secret leakage.`, "Agent Environment");
  const allowedEnv = await confirmSandboxSection(result);
  if (lD(allowedEnv)) {
    he("Init cancelled.");
    return { success: false, cancelled: true };
  }
  const boundaries = buildBoundaries(result);
  const boundariesSources = collectBoundariesSources(result);
  if (boundaries.never_touch.length > 0 || boundaries.require_review.length > 0) {
    const boundariesContent = formatBoundariesDisplay(boundaries.never_touch, boundaries.require_review);
    me(boundariesContent, `File Boundaries (from ${boundariesSources})`);
  }
  const config = {
    project,
    commands,
    rules,
    boundaries: boundaries.never_touch.length > 0 || boundaries.require_review.length > 0 ? boundaries : DEFAULT_BOUNDARIES,
    cost: DEFAULT_COST,
    fallback_engine: DEFAULT_FALLBACK_ENGINE,
    sandbox: {
      allowed_env: allowedEnv
    }
  };
  displaySummary(config);
  const shouldWrite = await ce({
    message: "Write configuration?",
    initialValue: true
  });
  if (lD(shouldWrite) || !shouldWrite) {
    he("Init cancelled.");
    return { success: false, cancelled: true };
  }
  const writeSpinner = _2();
  writeSpinner.start("Writing configuration...");
  try {
    const configPath = await writeConfig(projectRoot, config);
    writeSpinner.stop("Configuration written successfully.");
    me(`Configuration saved to:
  ${configPath}

Next steps:
  1. Review and customize boundaries in config.yaml
  2. Adjust cost settings if needed
  3. Create your first PRD file`, "Success");
    ge("KARIMO is ready.");
    return { success: true, cancelled: false, configPath };
  } catch (error) {
    writeSpinner.stop("Failed to write configuration.");
    he(`Error: ${error.message}`);
    return { success: false, cancelled: false };
  }
}
var CONFIG_DIR2 = ".karimo", CONFIG_FILE2 = "config.yaml";
var init_init = __esm(() => {
  init_dist3();
  init_dist();
  init_boundaries_display();
  init_defaults();
  init_detect();
});

// src/config/index.ts
var exports_config = {};
__export(exports_config, {
  runInit: () => runInit,
  loadConfigSync: () => loadConfigSync,
  loadConfig: () => loadConfig,
  hasMinimalDetection: () => hasMinimalDetection,
  getDetectionSummary: () => getDetectionSummary,
  findConfigPath: () => findConfigPath,
  detectProject: () => detectProject,
  SandboxSchema: () => SandboxSchema,
  RulesSchema: () => RulesSchema,
  ProjectSchema: () => ProjectSchema,
  ModelPreferenceSchema: () => ModelPreferenceSchema,
  LOCAL_STATE_FILE: () => LOCAL_STATE_FILE,
  KarimoConfigSchema: () => KarimoConfigSchema,
  KarimoConfigError: () => KarimoConfigError,
  FallbackTriggerSchema: () => FallbackTriggerSchema,
  FallbackEngineSchema: () => FallbackEngineSchema,
  FallbackEngineItemSchema: () => FallbackEngineItemSchema,
  DEFAULT_REVISION_BUDGET_PERCENT: () => DEFAULT_REVISION_BUDGET_PERCENT,
  DEFAULT_PHASE_BUDGET_OVERFLOW: () => DEFAULT_PHASE_BUDGET_OVERFLOW,
  DEFAULT_MAX_REVISION_LOOPS: () => DEFAULT_MAX_REVISION_LOOPS,
  DEFAULT_ITERATION_MULTIPLIER: () => DEFAULT_ITERATION_MULTIPLIER,
  DEFAULT_FALLBACK_ENGINE: () => DEFAULT_FALLBACK_ENGINE,
  DEFAULT_FALLBACK_COST_PER_MINUTE: () => DEFAULT_FALLBACK_COST_PER_MINUTE,
  DEFAULT_COST_MULTIPLIER: () => DEFAULT_COST_MULTIPLIER,
  DEFAULT_COST: () => DEFAULT_COST,
  DEFAULT_BUDGET_WARNING_THRESHOLD: () => DEFAULT_BUDGET_WARNING_THRESHOLD,
  DEFAULT_BOUNDARIES: () => DEFAULT_BOUNDARIES,
  DEFAULT_BASE_ITERATIONS: () => DEFAULT_BASE_ITERATIONS,
  CostSchema: () => CostSchema,
  ConfigValidationError: () => ConfigValidationError,
  ConfigReadError: () => ConfigReadError,
  ConfigParseError: () => ConfigParseError,
  ConfigNotFoundError: () => ConfigNotFoundError,
  CommandsSchema: () => CommandsSchema,
  CONFIG_FILE: () => CONFIG_FILE3,
  CONFIG_DIR: () => CONFIG_DIR3,
  COMMON_ALLOWED_ENV: () => COMMON_ALLOWED_ENV,
  CHECKPOINTS_DIR: () => CHECKPOINTS_DIR,
  BoundariesSchema: () => BoundariesSchema
});
var CONFIG_DIR3 = ".karimo", CONFIG_FILE3 = "config.yaml", CHECKPOINTS_DIR = "checkpoints", LOCAL_STATE_FILE = "local-state.json", DEFAULT_COST_MULTIPLIER = 3, DEFAULT_BASE_ITERATIONS = 5, DEFAULT_ITERATION_MULTIPLIER = 3, DEFAULT_REVISION_BUDGET_PERCENT = 50, DEFAULT_MAX_REVISION_LOOPS = 3, DEFAULT_BUDGET_WARNING_THRESHOLD = 0.75, DEFAULT_PHASE_BUDGET_OVERFLOW = 0.1, DEFAULT_FALLBACK_COST_PER_MINUTE = 0.5;
var init_config = __esm(() => {
  init_schema();
  init_loader();
  init_defaults();
  init_errors5();
  init_detect();
  init_init();
});

// src/github/errors.ts
var KarimoGitHubError, GhCliNotFoundError, GhCommandError, PrCreateError, OctokitError;
var init_errors6 = __esm(() => {
  KarimoGitHubError = class KarimoGitHubError extends Error {
    constructor(message) {
      super(message);
      this.name = "KarimoGitHubError";
    }
  };
  GhCliNotFoundError = class GhCliNotFoundError extends KarimoGitHubError {
    constructor() {
      super(`GitHub CLI (gh) not found.

Install it from: https://cli.github.com

After installation, authenticate with: gh auth login`);
      this.name = "GhCliNotFoundError";
    }
  };
  GhCommandError = class GhCommandError extends KarimoGitHubError {
    args;
    exitCode;
    stderr;
    constructor(args, exitCode, stderr) {
      const cmd = `gh ${args.join(" ")}`;
      super(`GitHub CLI command failed.
  Command: ${cmd}
  Exit code: ${exitCode}
  Error: ${stderr.trim()}

Ensure you're authenticated and have the required permissions.`);
      this.args = args;
      this.exitCode = exitCode;
      this.stderr = stderr;
      this.name = "GhCommandError";
    }
  };
  PrCreateError = class PrCreateError extends KarimoGitHubError {
    head;
    base;
    reason;
    constructor(head, base, reason) {
      super(`Failed to create pull request.
  Head: ${head}
  Base: ${base}
  Reason: ${reason}

Ensure the branch exists and has commits not in the base branch.`);
      this.head = head;
      this.base = base;
      this.reason = reason;
      this.name = "PrCreateError";
    }
  };
  OctokitError = class OctokitError extends KarimoGitHubError {
    status;
    documentationUrl;
    constructor(status, message, documentationUrl) {
      const docsInfo = documentationUrl ? `
  Docs: ${documentationUrl}` : "";
      super(`GitHub API error.
  Status: ${status}
  Message: ${message}${docsInfo}

Check your token permissions and API rate limits.`);
      this.name = "OctokitError";
      this.status = status;
      if (documentationUrl !== undefined) {
        this.documentationUrl = documentationUrl;
      }
    }
  };
});

// src/github/exec.ts
async function isGhAvailable() {
  if (ghAvailable !== null) {
    return ghAvailable;
  }
  try {
    const proc = Bun.spawn(["gh", "--version"], {
      stdout: "pipe",
      stderr: "pipe"
    });
    await proc.exited;
    ghAvailable = proc.exitCode === 0;
    return ghAvailable;
  } catch {
    ghAvailable = false;
    return false;
  }
}
async function ensureGhAvailable() {
  if (!await isGhAvailable()) {
    throw new GhCliNotFoundError;
  }
}
async function ghExec(args, options = {}) {
  const { cwd, timeout = DEFAULT_TIMEOUT2, throwOnError = true, env = {} } = options;
  await ensureGhAvailable();
  const proc = Bun.spawn(["gh", ...args], {
    ...cwd !== undefined && { cwd },
    env: { ...process.env, ...env },
    stdout: "pipe",
    stderr: "pipe"
  });
  const timeoutPromise = new Promise((_3, reject) => {
    const id = setTimeout(() => {
      proc.kill();
      reject(new GhCommandError(args, -1, `Command timed out after ${timeout}ms`));
    }, timeout);
    proc.exited.then(() => clearTimeout(id)).catch(() => clearTimeout(id));
  });
  const exitCode = await Promise.race([proc.exited, timeoutPromise]);
  const stdout = await new Response(proc.stdout).text();
  const stderr = await new Response(proc.stderr).text();
  const success = exitCode === 0;
  if (!success && throwOnError) {
    throw new GhCommandError(args, exitCode, stderr);
  }
  return {
    exitCode,
    stdout,
    stderr,
    success
  };
}
async function getGhToken(hostname = "github.com") {
  try {
    const result = await ghExec(["auth", "token", "--hostname", hostname], {
      throwOnError: false
    });
    if (result.success) {
      return result.stdout.trim();
    }
    return null;
  } catch {
    return null;
  }
}
var DEFAULT_TIMEOUT2 = 30000, ghAvailable = null;
var init_exec2 = __esm(() => {
  init_errors6();
});

// src/github/cli-auth.ts
function parseAuthStatus(stdout, stderr, host) {
  if (stderr.includes("not logged in") || stderr.includes("gh auth login")) {
    return {
      authenticated: false,
      host
    };
  }
  const lines = stdout.split(`
`);
  let username;
  let protocol;
  const scopes = [];
  for (const line of lines) {
    const trimmed = line.trim();
    const accountMatch = trimmed.match(/Logged in to .+ account (\S+)/);
    if (accountMatch) {
      username = accountMatch[1];
    }
    if (trimmed.includes("Token:")) {}
    if (trimmed.includes("Git Operations Protocol: https")) {
      protocol = "https";
    } else if (trimmed.includes("Git Operations Protocol: ssh")) {
      protocol = "ssh";
    }
    const scopeMatch = trimmed.match(/Token scopes: (.+)/);
    if (scopeMatch?.[1]) {
      scopes.push(...scopeMatch[1].split(",").map((s) => s.trim()).filter((s) => s));
    }
  }
  const result = {
    authenticated: username !== undefined,
    host
  };
  if (username !== undefined) {
    result.username = username;
  }
  if (scopes.length > 0) {
    result.scopes = scopes;
  }
  if (protocol !== undefined) {
    result.protocol = protocol;
  }
  return result;
}
async function verifyGhAuth(hostname = "github.com", skipCache = false) {
  if (!skipCache && authCache) {
    const age = Date.now() - authCache.timestamp;
    if (age < AUTH_CACHE_TTL && authCache.status.host === hostname) {
      return authCache.status;
    }
  }
  if (!await isGhAvailable()) {
    return {
      authenticated: false,
      host: hostname
    };
  }
  const result = await ghExec(["auth", "status", "--hostname", hostname], {
    throwOnError: false
  });
  const status = parseAuthStatus(result.stdout, result.stderr, hostname);
  authCache = {
    status,
    timestamp: Date.now()
  };
  return status;
}
var AUTH_CACHE_TTL, authCache = null;
var init_cli_auth = __esm(() => {
  init_errors6();
  init_exec2();
  AUTH_CACHE_TTL = 5 * 60 * 1000;
});

// node_modules/universal-user-agent/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== undefined) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/endpoint/dist-bundle/index.js
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === undefined) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && defaults.mediaType.previews?.length) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
function removeNonChars(variableName) {
  return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a3, b3) => a3.concat(b3), []);
}
function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== undefined && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
          });
        } else {
          Object.keys(value).forEach(function(k3) {
            if (isDefined(value[k3])) {
              result.push(encodeValue(operator, value[k3], k3));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k3) {
            if (isDefined(value[k3])) {
              tmp.push(encodeUnreserved(k3));
              tmp.push(encodeValue(operator, value[k3].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_3, expression, literal) {
    if (expression) {
      let operator = "";
      const values = [];
      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }
      expression.split(/,/g).forEach(function(variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
      });
      if (operator && operator !== "+") {
        var separator = ",";
        if (operator === "?") {
          separator = "&";
        } else if (operator !== "#") {
          separator = operator;
        }
        return (values.length !== 0 ? operator : "") + values.join(separator);
      } else {
        return values.join(",");
      }
    } else {
      return encodeReserved(literal);
    }
  });
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse(options) {
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map((format) => format.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
    }
    if (url.endsWith("/graphql")) {
      if (options.mediaType.previews?.length) {
        const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign({ method, url, headers }, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var VERSION = "0.0.0-development", userAgent, DEFAULTS, urlVariableRegex, endpoint;
var init_dist_bundle = __esm(() => {
  userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent()}`;
  DEFAULTS = {
    method: "GET",
    baseUrl: "https://api.github.com",
    headers: {
      accept: "application/vnd.github.v3+json",
      "user-agent": userAgent
    },
    mediaType: {
      format: ""
    }
  };
  urlVariableRegex = /\{[^{}}]+\}/g;
  endpoint = withDefaults(null, DEFAULTS);
});

// node_modules/fast-content-type-parse/index.js
function safeParse(header) {
  if (typeof header !== "string") {
    return defaultContentType;
  }
  let index = header.indexOf(";");
  const type = index !== -1 ? header.slice(0, index).trim() : header.trim();
  if (mediaTypeRE.test(type) === false) {
    return defaultContentType;
  }
  const result = {
    type: type.toLowerCase(),
    parameters: new NullObject
  };
  if (index === -1) {
    return result;
  }
  let key;
  let match;
  let value;
  paramRE.lastIndex = index;
  while (match = paramRE.exec(header)) {
    if (match.index !== index) {
      return defaultContentType;
    }
    index += match[0].length;
    key = match[1].toLowerCase();
    value = match[2];
    if (value[0] === '"') {
      value = value.slice(1, value.length - 1);
      quotedPairRE.test(value) && (value = value.replace(quotedPairRE, "$1"));
    }
    result.parameters[key] = value;
  }
  if (index !== header.length) {
    return defaultContentType;
  }
  return result;
}
var NullObject = function NullObject2() {}, paramRE, quotedPairRE, mediaTypeRE, defaultContentType, $safeParse;
var init_fast_content_type_parse = __esm(() => {
  NullObject.prototype = Object.create(null);
  paramRE = /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu;
  quotedPairRE = /\\([\v\u0020-\u00ff])/gu;
  mediaTypeRE = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u;
  defaultContentType = { type: "", parameters: new NullObject };
  Object.freeze(defaultContentType.parameters);
  Object.freeze(defaultContentType);
  $safeParse = safeParse;
});

// node_modules/@octokit/request-error/dist-src/index.js
var RequestError;
var init_dist_src = __esm(() => {
  RequestError = class RequestError extends Error {
    name;
    status;
    request;
    response;
    constructor(message, statusCode, options) {
      super(message);
      this.name = "HttpError";
      this.status = Number.parseInt(statusCode);
      if (Number.isNaN(this.status)) {
        this.status = 0;
      }
      if ("response" in options) {
        this.response = options.response;
      }
      const requestCopy = Object.assign({}, options.request);
      if (options.request.headers.authorization) {
        requestCopy.headers = Object.assign({}, options.request.headers, {
          authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]")
        });
      }
      requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
      this.request = requestCopy;
    }
  };
});

// node_modules/@octokit/request/dist-bundle/index.js
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
async function fetchWrapper(requestOptions) {
  const fetch2 = requestOptions.request?.fetch || globalThis.fetch;
  if (!fetch2) {
    throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
  }
  const log = requestOptions.request?.log || console;
  const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
  const body = isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body) ? JSON.stringify(requestOptions.body) : requestOptions.body;
  const requestHeaders = Object.fromEntries(Object.entries(requestOptions.headers).map(([name, value]) => [
    name,
    String(value)
  ]));
  let fetchResponse;
  try {
    fetchResponse = await fetch2(requestOptions.url, {
      method: requestOptions.method,
      body,
      redirect: requestOptions.request?.redirect,
      headers: requestHeaders,
      signal: requestOptions.request?.signal,
      ...requestOptions.body && { duplex: "half" }
    });
  } catch (error) {
    let message = "Unknown Error";
    if (error instanceof Error) {
      if (error.name === "AbortError") {
        error.status = 500;
        throw error;
      }
      message = error.message;
      if (error.name === "TypeError" && "cause" in error) {
        if (error.cause instanceof Error) {
          message = error.cause.message;
        } else if (typeof error.cause === "string") {
          message = error.cause;
        }
      }
    }
    const requestError = new RequestError(message, 500, {
      request: requestOptions
    });
    requestError.cause = error;
    throw requestError;
  }
  const status = fetchResponse.status;
  const url = fetchResponse.url;
  const responseHeaders = {};
  for (const [key, value] of fetchResponse.headers) {
    responseHeaders[key] = value;
  }
  const octokitResponse = {
    url,
    status,
    headers: responseHeaders,
    data: ""
  };
  if ("deprecation" in responseHeaders) {
    const matches = responseHeaders.link && responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/);
    const deprecationLink = matches && matches.pop();
    log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
  }
  if (status === 204 || status === 205) {
    return octokitResponse;
  }
  if (requestOptions.method === "HEAD") {
    if (status < 400) {
      return octokitResponse;
    }
    throw new RequestError(fetchResponse.statusText, status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status === 304) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError("Not modified", status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status >= 400) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError(toErrorMessage(octokitResponse.data), status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  octokitResponse.data = parseSuccessResponseBody ? await getResponseData(fetchResponse) : fetchResponse.body;
  return octokitResponse;
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (!contentType) {
    return response.text().catch(() => "");
  }
  const mimetype = $safeParse(contentType);
  if (isJSONResponse(mimetype)) {
    let text = "";
    try {
      text = await response.text();
      return JSON.parse(text);
    } catch (err) {
      return text;
    }
  } else if (mimetype.type.startsWith("text/") || mimetype.parameters.charset?.toLowerCase() === "utf-8") {
    return response.text().catch(() => "");
  } else {
    return response.arrayBuffer().catch(() => new ArrayBuffer(0));
  }
}
function isJSONResponse(mimetype) {
  return mimetype.type === "application/json" || mimetype.type === "application/scim+json";
}
function toErrorMessage(data) {
  if (typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return "Unknown error";
  }
  if ("message" in data) {
    const suffix = "documentation_url" in data ? ` - ${data.documentation_url}` : "";
    return Array.isArray(data.errors) ? `${data.message}: ${data.errors.map((v3) => JSON.stringify(v3)).join(", ")}${suffix}` : `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var VERSION2 = "9.2.4", defaults_default, request;
var init_dist_bundle2 = __esm(() => {
  init_dist_bundle();
  init_fast_content_type_parse();
  init_dist_src();
  defaults_default = {
    headers: {
      "user-agent": `octokit-request.js/${VERSION2} ${getUserAgent()}`
    }
  };
  request = withDefaults2(endpoint, defaults_default);
});

// node_modules/@octokit/graphql/dist-bundle/index.js
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e2) => ` - ${e2.message}`).join(`
`);
}
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(requestOptions, headers, response.data);
    }
    return response.data.data;
  });
}
function withDefaults3(request2, newDefaults) {
  const newRequest = request2.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: newRequest.endpoint
  });
}
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}
var VERSION3 = "0.0.0-development", GraphqlResponseError, NON_VARIABLE_OPTIONS, FORBIDDEN_VARIABLE_OPTIONS, GHES_V3_SUFFIX_REGEX, graphql2;
var init_dist_bundle3 = __esm(() => {
  init_dist_bundle2();
  GraphqlResponseError = class extends Error {
    constructor(request2, headers, response) {
      super(_buildMessageForResponseErrors(response));
      this.request = request2;
      this.headers = headers;
      this.response = response;
      this.errors = response.errors;
      this.data = response.data;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    }
    name = "GraphqlResponseError";
    errors;
    data;
  };
  NON_VARIABLE_OPTIONS = [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "query",
    "mediaType",
    "operationName"
  ];
  FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
  GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
  graphql2 = withDefaults3(request, {
    headers: {
      "user-agent": `octokit-graphql.js/${VERSION3} ${getUserAgent()}`
    },
    method: "POST",
    url: "/graphql"
  });
});

// node_modules/before-after-hook/lib/register.js
function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }
  if (!options) {
    options = {};
  }
  if (Array.isArray(name)) {
    return name.reverse().reduce((callback, name2) => {
      return register.bind(null, state, name2, callback, options);
    }, method)();
  }
  return Promise.resolve().then(() => {
    if (!state.registry[name]) {
      return method(options);
    }
    return state.registry[name].reduce((method2, registered) => {
      return registered.hook.bind(null, method2, options);
    }, method)();
  });
}

// node_modules/before-after-hook/lib/add.js
function addHook(state, kind, name, hook) {
  const orig = hook;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }
  if (kind === "before") {
    hook = (method, options) => {
      return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
    };
  }
  if (kind === "after") {
    hook = (method, options) => {
      let result;
      return Promise.resolve().then(method.bind(null, options)).then((result_) => {
        result = result_;
        return orig(result, options);
      }).then(() => {
        return result;
      });
    };
  }
  if (kind === "error") {
    hook = (method, options) => {
      return Promise.resolve().then(method.bind(null, options)).catch((error) => {
        return orig(error, options);
      });
    };
  }
  state.registry[name].push({
    hook,
    orig
  });
}

// node_modules/before-after-hook/lib/remove.js
function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }
  const index = state.registry[name].map((registered) => {
    return registered.orig;
  }).indexOf(method);
  if (index === -1) {
    return;
  }
  state.registry[name].splice(index, 1);
}

// node_modules/before-after-hook/index.js
function bindApi(hook, state, name) {
  const removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
  hook.api = { remove: removeHookRef };
  hook.remove = removeHookRef;
  ["before", "error", "after", "wrap"].forEach((kind) => {
    const args = name ? [state, kind, name] : [state, kind];
    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);
  });
}
function Singular() {
  const singularHookName = Symbol("Singular");
  const singularHookState = {
    registry: {}
  };
  const singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}
function Collection() {
  const state = {
    registry: {}
  };
  const hook = register.bind(null, state);
  bindApi(hook, state);
  return hook;
}
var bind, bindable, before_after_hook_default;
var init_before_after_hook = __esm(() => {
  bind = Function.bind;
  bindable = bind.bind(bind);
  before_after_hook_default = { Singular, Collection };
});

// node_modules/@octokit/auth-token/dist-bundle/index.js
async function auth(token) {
  const isApp = isJWT(token);
  const isInstallation = token.startsWith("v1.") || token.startsWith("ghs_");
  const isUserToServer = token.startsWith("ghu_");
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
async function hook(token, request2, route, parameters) {
  const endpoint2 = request2.endpoint.merge(route, parameters);
  endpoint2.headers.authorization = withAuthorizationPrefix(token);
  return request2(endpoint2);
}
var b64url = "(?:[a-zA-Z0-9_-]+)", sep = "\\.", jwtRE, isJWT, createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};
var init_dist_bundle4 = __esm(() => {
  jwtRE = new RegExp(`^${b64url}${sep}${b64url}${sep}${b64url}$`);
  isJWT = jwtRE.test.bind(jwtRE);
});

// node_modules/@octokit/core/dist-src/version.js
var VERSION4 = "6.1.6";
var init_version = () => {};

// node_modules/@octokit/core/dist-src/index.js
function createLogger(logger = {}) {
  if (typeof logger.debug !== "function") {
    logger.debug = noop;
  }
  if (typeof logger.info !== "function") {
    logger.info = noop;
  }
  if (typeof logger.warn !== "function") {
    logger.warn = consoleWarn;
  }
  if (typeof logger.error !== "function") {
    logger.error = consoleError;
  }
  return logger;
}
var noop = () => {}, consoleWarn, consoleError, userAgentTrail, Octokit;
var init_dist_src2 = __esm(() => {
  init_before_after_hook();
  init_dist_bundle2();
  init_dist_bundle3();
  init_dist_bundle4();
  init_version();
  consoleWarn = console.warn.bind(console);
  consoleError = console.error.bind(console);
  userAgentTrail = `octokit-core.js/${VERSION4} ${getUserAgent()}`;
  Octokit = class Octokit {
    static VERSION = VERSION4;
    static defaults(defaults) {
      const OctokitWithDefaults = class extends this {
        constructor(...args) {
          const options = args[0] || {};
          if (typeof defaults === "function") {
            super(defaults(options));
            return;
          }
          super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
            userAgent: `${options.userAgent} ${defaults.userAgent}`
          } : null));
        }
      };
      return OctokitWithDefaults;
    }
    static plugins = [];
    static plugin(...newPlugins) {
      const currentPlugins = this.plugins;
      const NewOctokit = class extends this {
        static plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin)));
      };
      return NewOctokit;
    }
    constructor(options = {}) {
      const hook2 = new before_after_hook_default.Collection;
      const requestDefaults = {
        baseUrl: request.endpoint.DEFAULTS.baseUrl,
        headers: {},
        request: Object.assign({}, options.request, {
          hook: hook2.bind(null, "request")
        }),
        mediaType: {
          previews: [],
          format: ""
        }
      };
      requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
      if (options.baseUrl) {
        requestDefaults.baseUrl = options.baseUrl;
      }
      if (options.previews) {
        requestDefaults.mediaType.previews = options.previews;
      }
      if (options.timeZone) {
        requestDefaults.headers["time-zone"] = options.timeZone;
      }
      this.request = request.defaults(requestDefaults);
      this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
      this.log = createLogger(options.log);
      this.hook = hook2;
      if (!options.authStrategy) {
        if (!options.auth) {
          this.auth = async () => ({
            type: "unauthenticated"
          });
        } else {
          const auth2 = createTokenAuth(options.auth);
          hook2.wrap("request", auth2.hook);
          this.auth = auth2;
        }
      } else {
        const { authStrategy, ...otherOptions } = options;
        const auth2 = authStrategy(Object.assign({
          request: this.request,
          log: this.log,
          octokit: this,
          octokitOptions: otherOptions
        }, options.auth));
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
      const classConstructor = this.constructor;
      for (let i = 0;i < classConstructor.plugins.length; ++i) {
        Object.assign(this, classConstructor.plugins[i](this, options));
      }
    }
    request;
    graphql;
    log;
    hook;
    auth;
  };
});

// node_modules/@octokit/plugin-request-log/dist-src/version.js
var VERSION5 = "5.3.1";
var init_version2 = () => {};

// node_modules/@octokit/plugin-request-log/dist-src/index.js
function requestLog(octokit) {
  octokit.hook.wrap("request", (request2, options) => {
    octokit.log.debug("request", options);
    const start = Date.now();
    const requestOptions = octokit.request.endpoint.parse(options);
    const path = requestOptions.url.replace(options.baseUrl, "");
    return request2(options).then((response) => {
      const requestId = response.headers["x-github-request-id"];
      octokit.log.info(`${requestOptions.method} ${path} - ${response.status} with id ${requestId} in ${Date.now() - start}ms`);
      return response;
    }).catch((error) => {
      const requestId = error.response?.headers["x-github-request-id"] || "UNKNOWN";
      octokit.log.error(`${requestOptions.method} ${path} - ${error.status} with id ${requestId} in ${Date.now() - start}ms`);
      throw error;
    });
  });
}
var init_dist_src3 = __esm(() => {
  init_version2();
  requestLog.VERSION = VERSION5;
});

// node_modules/@octokit/plugin-paginate-rest/dist-bundle/index.js
function normalizePaginatedListResponse(response) {
  if (!response.data) {
    return {
      ...response,
      data: []
    };
  }
  const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
  if (!responseNeedsNormalization)
    return response;
  const incompleteResults = response.data.incomplete_results;
  const repositorySelection = response.data.repository_selection;
  const totalCount = response.data.total_count;
  delete response.data.incomplete_results;
  delete response.data.repository_selection;
  delete response.data.total_count;
  const namespaceKey = Object.keys(response.data)[0];
  const data = response.data[namespaceKey];
  response.data = data;
  if (typeof incompleteResults !== "undefined") {
    response.data.incomplete_results = incompleteResults;
  }
  if (typeof repositorySelection !== "undefined") {
    response.data.repository_selection = repositorySelection;
  }
  response.data.total_count = totalCount;
  return response;
}
function iterator(octokit, route, parameters) {
  const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
  const requestMethod = typeof route === "function" ? route : octokit.request;
  const method = options.method;
  const headers = options.headers;
  let url = options.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!url)
          return { done: true };
        try {
          const response = await requestMethod({ method, url, headers });
          const normalizedResponse = normalizePaginatedListResponse(response);
          url = ((normalizedResponse.headers.link || "").match(/<([^<>]+)>;\s*rel="next"/) || [])[1];
          return { value: normalizedResponse };
        } catch (error) {
          if (error.status !== 409)
            throw error;
          url = "";
          return {
            value: {
              status: 200,
              headers: {},
              data: []
            }
          };
        }
      }
    })
  };
}
function paginate(octokit, route, parameters, mapFn) {
  if (typeof parameters === "function") {
    mapFn = parameters;
    parameters = undefined;
  }
  return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
}
function gather(octokit, results, iterator2, mapFn) {
  return iterator2.next().then((result) => {
    if (result.done) {
      return results;
    }
    let earlyExit = false;
    function done() {
      earlyExit = true;
    }
    results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
    if (earlyExit) {
      return results;
    }
    return gather(octokit, results, iterator2, mapFn);
  });
}
function paginateRest(octokit) {
  return {
    paginate: Object.assign(paginate.bind(null, octokit), {
      iterator: iterator.bind(null, octokit)
    })
  };
}
var VERSION6 = "0.0.0-development", composePaginateRest;
var init_dist_bundle5 = __esm(() => {
  composePaginateRest = Object.assign(paginate, {
    iterator
  });
  paginateRest.VERSION = VERSION6;
});

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/version.js
var VERSION7 = "13.5.0";
var init_version3 = () => {};

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/generated/endpoints.js
var Endpoints, endpoints_default;
var init_endpoints = __esm(() => {
  Endpoints = {
    actions: {
      addCustomLabelsToSelfHostedRunnerForOrg: [
        "POST /orgs/{org}/actions/runners/{runner_id}/labels"
      ],
      addCustomLabelsToSelfHostedRunnerForRepo: [
        "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
      ],
      addRepoAccessToSelfHostedRunnerGroupInOrg: [
        "PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"
      ],
      addSelectedRepoToOrgSecret: [
        "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
      ],
      addSelectedRepoToOrgVariable: [
        "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
      ],
      approveWorkflowRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
      ],
      cancelWorkflowRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
      ],
      createEnvironmentVariable: [
        "POST /repos/{owner}/{repo}/environments/{environment_name}/variables"
      ],
      createHostedRunnerForOrg: ["POST /orgs/{org}/actions/hosted-runners"],
      createOrUpdateEnvironmentSecret: [
        "PUT /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
      ],
      createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
      createOrUpdateRepoSecret: [
        "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
      ],
      createOrgVariable: ["POST /orgs/{org}/actions/variables"],
      createRegistrationTokenForOrg: [
        "POST /orgs/{org}/actions/runners/registration-token"
      ],
      createRegistrationTokenForRepo: [
        "POST /repos/{owner}/{repo}/actions/runners/registration-token"
      ],
      createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
      createRemoveTokenForRepo: [
        "POST /repos/{owner}/{repo}/actions/runners/remove-token"
      ],
      createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
      createWorkflowDispatch: [
        "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
      ],
      deleteActionsCacheById: [
        "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
      ],
      deleteActionsCacheByKey: [
        "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
      ],
      deleteArtifact: [
        "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
      ],
      deleteEnvironmentSecret: [
        "DELETE /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
      ],
      deleteEnvironmentVariable: [
        "DELETE /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
      ],
      deleteHostedRunnerForOrg: [
        "DELETE /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
      ],
      deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
      deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
      deleteRepoSecret: [
        "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
      ],
      deleteRepoVariable: [
        "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
      ],
      deleteSelfHostedRunnerFromOrg: [
        "DELETE /orgs/{org}/actions/runners/{runner_id}"
      ],
      deleteSelfHostedRunnerFromRepo: [
        "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
      ],
      deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
      deleteWorkflowRunLogs: [
        "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
      ],
      disableSelectedRepositoryGithubActionsOrganization: [
        "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
      ],
      disableWorkflow: [
        "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
      ],
      downloadArtifact: [
        "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
      ],
      downloadJobLogsForWorkflowRun: [
        "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
      ],
      downloadWorkflowRunAttemptLogs: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
      ],
      downloadWorkflowRunLogs: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
      ],
      enableSelectedRepositoryGithubActionsOrganization: [
        "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
      ],
      enableWorkflow: [
        "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
      ],
      forceCancelWorkflowRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
      ],
      generateRunnerJitconfigForOrg: [
        "POST /orgs/{org}/actions/runners/generate-jitconfig"
      ],
      generateRunnerJitconfigForRepo: [
        "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
      ],
      getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
      getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
      getActionsCacheUsageByRepoForOrg: [
        "GET /orgs/{org}/actions/cache/usage-by-repository"
      ],
      getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
      getAllowedActionsOrganization: [
        "GET /orgs/{org}/actions/permissions/selected-actions"
      ],
      getAllowedActionsRepository: [
        "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
      ],
      getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
      getCustomOidcSubClaimForRepo: [
        "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
      ],
      getEnvironmentPublicKey: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key"
      ],
      getEnvironmentSecret: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
      ],
      getEnvironmentVariable: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
      ],
      getGithubActionsDefaultWorkflowPermissionsOrganization: [
        "GET /orgs/{org}/actions/permissions/workflow"
      ],
      getGithubActionsDefaultWorkflowPermissionsRepository: [
        "GET /repos/{owner}/{repo}/actions/permissions/workflow"
      ],
      getGithubActionsPermissionsOrganization: [
        "GET /orgs/{org}/actions/permissions"
      ],
      getGithubActionsPermissionsRepository: [
        "GET /repos/{owner}/{repo}/actions/permissions"
      ],
      getHostedRunnerForOrg: [
        "GET /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
      ],
      getHostedRunnersGithubOwnedImagesForOrg: [
        "GET /orgs/{org}/actions/hosted-runners/images/github-owned"
      ],
      getHostedRunnersLimitsForOrg: [
        "GET /orgs/{org}/actions/hosted-runners/limits"
      ],
      getHostedRunnersMachineSpecsForOrg: [
        "GET /orgs/{org}/actions/hosted-runners/machine-sizes"
      ],
      getHostedRunnersPartnerImagesForOrg: [
        "GET /orgs/{org}/actions/hosted-runners/images/partner"
      ],
      getHostedRunnersPlatformsForOrg: [
        "GET /orgs/{org}/actions/hosted-runners/platforms"
      ],
      getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
      getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
      getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
      getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
      getPendingDeploymentsForRun: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
      ],
      getRepoPermissions: [
        "GET /repos/{owner}/{repo}/actions/permissions",
        {},
        { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
      ],
      getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
      getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
      getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
      getReviewsForRun: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
      ],
      getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
      getSelfHostedRunnerForRepo: [
        "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
      ],
      getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
      getWorkflowAccessToRepository: [
        "GET /repos/{owner}/{repo}/actions/permissions/access"
      ],
      getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
      getWorkflowRunAttempt: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
      ],
      getWorkflowRunUsage: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
      ],
      getWorkflowUsage: [
        "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
      ],
      listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
      listEnvironmentSecrets: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets"
      ],
      listEnvironmentVariables: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/variables"
      ],
      listGithubHostedRunnersInGroupForOrg: [
        "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners"
      ],
      listHostedRunnersForOrg: ["GET /orgs/{org}/actions/hosted-runners"],
      listJobsForWorkflowRun: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
      ],
      listJobsForWorkflowRunAttempt: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
      ],
      listLabelsForSelfHostedRunnerForOrg: [
        "GET /orgs/{org}/actions/runners/{runner_id}/labels"
      ],
      listLabelsForSelfHostedRunnerForRepo: [
        "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
      ],
      listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
      listOrgVariables: ["GET /orgs/{org}/actions/variables"],
      listRepoOrganizationSecrets: [
        "GET /repos/{owner}/{repo}/actions/organization-secrets"
      ],
      listRepoOrganizationVariables: [
        "GET /repos/{owner}/{repo}/actions/organization-variables"
      ],
      listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
      listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
      listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
      listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
      listRunnerApplicationsForRepo: [
        "GET /repos/{owner}/{repo}/actions/runners/downloads"
      ],
      listSelectedReposForOrgSecret: [
        "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
      ],
      listSelectedReposForOrgVariable: [
        "GET /orgs/{org}/actions/variables/{name}/repositories"
      ],
      listSelectedRepositoriesEnabledGithubActionsOrganization: [
        "GET /orgs/{org}/actions/permissions/repositories"
      ],
      listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
      listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
      listWorkflowRunArtifacts: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
      ],
      listWorkflowRuns: [
        "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
      ],
      listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
      reRunJobForWorkflowRun: [
        "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
      ],
      reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
      reRunWorkflowFailedJobs: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
      ],
      removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
        "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
      ],
      removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
        "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
      ],
      removeCustomLabelFromSelfHostedRunnerForOrg: [
        "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
      ],
      removeCustomLabelFromSelfHostedRunnerForRepo: [
        "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
      ],
      removeSelectedRepoFromOrgSecret: [
        "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
      ],
      removeSelectedRepoFromOrgVariable: [
        "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
      ],
      reviewCustomGatesForRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
      ],
      reviewPendingDeploymentsForRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
      ],
      setAllowedActionsOrganization: [
        "PUT /orgs/{org}/actions/permissions/selected-actions"
      ],
      setAllowedActionsRepository: [
        "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
      ],
      setCustomLabelsForSelfHostedRunnerForOrg: [
        "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
      ],
      setCustomLabelsForSelfHostedRunnerForRepo: [
        "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
      ],
      setCustomOidcSubClaimForRepo: [
        "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
      ],
      setGithubActionsDefaultWorkflowPermissionsOrganization: [
        "PUT /orgs/{org}/actions/permissions/workflow"
      ],
      setGithubActionsDefaultWorkflowPermissionsRepository: [
        "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
      ],
      setGithubActionsPermissionsOrganization: [
        "PUT /orgs/{org}/actions/permissions"
      ],
      setGithubActionsPermissionsRepository: [
        "PUT /repos/{owner}/{repo}/actions/permissions"
      ],
      setSelectedReposForOrgSecret: [
        "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
      ],
      setSelectedReposForOrgVariable: [
        "PUT /orgs/{org}/actions/variables/{name}/repositories"
      ],
      setSelectedRepositoriesEnabledGithubActionsOrganization: [
        "PUT /orgs/{org}/actions/permissions/repositories"
      ],
      setWorkflowAccessToRepository: [
        "PUT /repos/{owner}/{repo}/actions/permissions/access"
      ],
      updateEnvironmentVariable: [
        "PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
      ],
      updateHostedRunnerForOrg: [
        "PATCH /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
      ],
      updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
      updateRepoVariable: [
        "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
      ]
    },
    activity: {
      checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
      deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
      deleteThreadSubscription: [
        "DELETE /notifications/threads/{thread_id}/subscription"
      ],
      getFeeds: ["GET /feeds"],
      getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
      getThread: ["GET /notifications/threads/{thread_id}"],
      getThreadSubscriptionForAuthenticatedUser: [
        "GET /notifications/threads/{thread_id}/subscription"
      ],
      listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
      listNotificationsForAuthenticatedUser: ["GET /notifications"],
      listOrgEventsForAuthenticatedUser: [
        "GET /users/{username}/events/orgs/{org}"
      ],
      listPublicEvents: ["GET /events"],
      listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
      listPublicEventsForUser: ["GET /users/{username}/events/public"],
      listPublicOrgEvents: ["GET /orgs/{org}/events"],
      listReceivedEventsForUser: ["GET /users/{username}/received_events"],
      listReceivedPublicEventsForUser: [
        "GET /users/{username}/received_events/public"
      ],
      listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
      listRepoNotificationsForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/notifications"
      ],
      listReposStarredByAuthenticatedUser: ["GET /user/starred"],
      listReposStarredByUser: ["GET /users/{username}/starred"],
      listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
      listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
      listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
      listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
      markNotificationsAsRead: ["PUT /notifications"],
      markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
      markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
      markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
      setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
      setThreadSubscription: [
        "PUT /notifications/threads/{thread_id}/subscription"
      ],
      starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
      unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
    },
    apps: {
      addRepoToInstallation: [
        "PUT /user/installations/{installation_id}/repositories/{repository_id}",
        {},
        { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
      ],
      addRepoToInstallationForAuthenticatedUser: [
        "PUT /user/installations/{installation_id}/repositories/{repository_id}"
      ],
      checkToken: ["POST /applications/{client_id}/token"],
      createFromManifest: ["POST /app-manifests/{code}/conversions"],
      createInstallationAccessToken: [
        "POST /app/installations/{installation_id}/access_tokens"
      ],
      deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
      deleteInstallation: ["DELETE /app/installations/{installation_id}"],
      deleteToken: ["DELETE /applications/{client_id}/token"],
      getAuthenticated: ["GET /app"],
      getBySlug: ["GET /apps/{app_slug}"],
      getInstallation: ["GET /app/installations/{installation_id}"],
      getOrgInstallation: ["GET /orgs/{org}/installation"],
      getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
      getSubscriptionPlanForAccount: [
        "GET /marketplace_listing/accounts/{account_id}"
      ],
      getSubscriptionPlanForAccountStubbed: [
        "GET /marketplace_listing/stubbed/accounts/{account_id}"
      ],
      getUserInstallation: ["GET /users/{username}/installation"],
      getWebhookConfigForApp: ["GET /app/hook/config"],
      getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
      listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
      listAccountsForPlanStubbed: [
        "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
      ],
      listInstallationReposForAuthenticatedUser: [
        "GET /user/installations/{installation_id}/repositories"
      ],
      listInstallationRequestsForAuthenticatedApp: [
        "GET /app/installation-requests"
      ],
      listInstallations: ["GET /app/installations"],
      listInstallationsForAuthenticatedUser: ["GET /user/installations"],
      listPlans: ["GET /marketplace_listing/plans"],
      listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
      listReposAccessibleToInstallation: ["GET /installation/repositories"],
      listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
      listSubscriptionsForAuthenticatedUserStubbed: [
        "GET /user/marketplace_purchases/stubbed"
      ],
      listWebhookDeliveries: ["GET /app/hook/deliveries"],
      redeliverWebhookDelivery: [
        "POST /app/hook/deliveries/{delivery_id}/attempts"
      ],
      removeRepoFromInstallation: [
        "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
        {},
        { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
      ],
      removeRepoFromInstallationForAuthenticatedUser: [
        "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
      ],
      resetToken: ["PATCH /applications/{client_id}/token"],
      revokeInstallationAccessToken: ["DELETE /installation/token"],
      scopeToken: ["POST /applications/{client_id}/token/scoped"],
      suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
      unsuspendInstallation: [
        "DELETE /app/installations/{installation_id}/suspended"
      ],
      updateWebhookConfigForApp: ["PATCH /app/hook/config"]
    },
    billing: {
      getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
      getGithubActionsBillingUser: [
        "GET /users/{username}/settings/billing/actions"
      ],
      getGithubBillingUsageReportOrg: [
        "GET /organizations/{org}/settings/billing/usage"
      ],
      getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
      getGithubPackagesBillingUser: [
        "GET /users/{username}/settings/billing/packages"
      ],
      getSharedStorageBillingOrg: [
        "GET /orgs/{org}/settings/billing/shared-storage"
      ],
      getSharedStorageBillingUser: [
        "GET /users/{username}/settings/billing/shared-storage"
      ]
    },
    checks: {
      create: ["POST /repos/{owner}/{repo}/check-runs"],
      createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
      get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
      getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
      listAnnotations: [
        "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
      ],
      listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
      listForSuite: [
        "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
      ],
      listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
      rerequestRun: [
        "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
      ],
      rerequestSuite: [
        "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
      ],
      setSuitesPreferences: [
        "PATCH /repos/{owner}/{repo}/check-suites/preferences"
      ],
      update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
    },
    codeScanning: {
      commitAutofix: [
        "POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix/commits"
      ],
      createAutofix: [
        "POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"
      ],
      createVariantAnalysis: [
        "POST /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses"
      ],
      deleteAnalysis: [
        "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
      ],
      deleteCodeqlDatabase: [
        "DELETE /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
      ],
      getAlert: [
        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
        {},
        { renamedParameters: { alert_id: "alert_number" } }
      ],
      getAnalysis: [
        "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
      ],
      getAutofix: [
        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"
      ],
      getCodeqlDatabase: [
        "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
      ],
      getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
      getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
      getVariantAnalysis: [
        "GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}"
      ],
      getVariantAnalysisRepoTask: [
        "GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}/repos/{repo_owner}/{repo_name}"
      ],
      listAlertInstances: [
        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
      ],
      listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
      listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
      listAlertsInstances: [
        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
        {},
        { renamed: ["codeScanning", "listAlertInstances"] }
      ],
      listCodeqlDatabases: [
        "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
      ],
      listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
      updateAlert: [
        "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
      ],
      updateDefaultSetup: [
        "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
      ],
      uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
    },
    codeSecurity: {
      attachConfiguration: [
        "POST /orgs/{org}/code-security/configurations/{configuration_id}/attach"
      ],
      attachEnterpriseConfiguration: [
        "POST /enterprises/{enterprise}/code-security/configurations/{configuration_id}/attach"
      ],
      createConfiguration: ["POST /orgs/{org}/code-security/configurations"],
      createConfigurationForEnterprise: [
        "POST /enterprises/{enterprise}/code-security/configurations"
      ],
      deleteConfiguration: [
        "DELETE /orgs/{org}/code-security/configurations/{configuration_id}"
      ],
      deleteConfigurationForEnterprise: [
        "DELETE /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
      ],
      detachConfiguration: [
        "DELETE /orgs/{org}/code-security/configurations/detach"
      ],
      getConfiguration: [
        "GET /orgs/{org}/code-security/configurations/{configuration_id}"
      ],
      getConfigurationForRepository: [
        "GET /repos/{owner}/{repo}/code-security-configuration"
      ],
      getConfigurationsForEnterprise: [
        "GET /enterprises/{enterprise}/code-security/configurations"
      ],
      getConfigurationsForOrg: ["GET /orgs/{org}/code-security/configurations"],
      getDefaultConfigurations: [
        "GET /orgs/{org}/code-security/configurations/defaults"
      ],
      getDefaultConfigurationsForEnterprise: [
        "GET /enterprises/{enterprise}/code-security/configurations/defaults"
      ],
      getRepositoriesForConfiguration: [
        "GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories"
      ],
      getRepositoriesForEnterpriseConfiguration: [
        "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories"
      ],
      getSingleConfigurationForEnterprise: [
        "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
      ],
      setConfigurationAsDefault: [
        "PUT /orgs/{org}/code-security/configurations/{configuration_id}/defaults"
      ],
      setConfigurationAsDefaultForEnterprise: [
        "PUT /enterprises/{enterprise}/code-security/configurations/{configuration_id}/defaults"
      ],
      updateConfiguration: [
        "PATCH /orgs/{org}/code-security/configurations/{configuration_id}"
      ],
      updateEnterpriseConfiguration: [
        "PATCH /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
      ]
    },
    codesOfConduct: {
      getAllCodesOfConduct: ["GET /codes_of_conduct"],
      getConductCode: ["GET /codes_of_conduct/{key}"]
    },
    codespaces: {
      addRepositoryForSecretForAuthenticatedUser: [
        "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
      ],
      addSelectedRepoToOrgSecret: [
        "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
      ],
      checkPermissionsForDevcontainer: [
        "GET /repos/{owner}/{repo}/codespaces/permissions_check"
      ],
      codespaceMachinesForAuthenticatedUser: [
        "GET /user/codespaces/{codespace_name}/machines"
      ],
      createForAuthenticatedUser: ["POST /user/codespaces"],
      createOrUpdateOrgSecret: [
        "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
      ],
      createOrUpdateRepoSecret: [
        "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
      ],
      createOrUpdateSecretForAuthenticatedUser: [
        "PUT /user/codespaces/secrets/{secret_name}"
      ],
      createWithPrForAuthenticatedUser: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
      ],
      createWithRepoForAuthenticatedUser: [
        "POST /repos/{owner}/{repo}/codespaces"
      ],
      deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
      deleteFromOrganization: [
        "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
      ],
      deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
      deleteRepoSecret: [
        "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
      ],
      deleteSecretForAuthenticatedUser: [
        "DELETE /user/codespaces/secrets/{secret_name}"
      ],
      exportForAuthenticatedUser: [
        "POST /user/codespaces/{codespace_name}/exports"
      ],
      getCodespacesForUserInOrg: [
        "GET /orgs/{org}/members/{username}/codespaces"
      ],
      getExportDetailsForAuthenticatedUser: [
        "GET /user/codespaces/{codespace_name}/exports/{export_id}"
      ],
      getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
      getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
      getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
      getPublicKeyForAuthenticatedUser: [
        "GET /user/codespaces/secrets/public-key"
      ],
      getRepoPublicKey: [
        "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
      ],
      getRepoSecret: [
        "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
      ],
      getSecretForAuthenticatedUser: [
        "GET /user/codespaces/secrets/{secret_name}"
      ],
      listDevcontainersInRepositoryForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/codespaces/devcontainers"
      ],
      listForAuthenticatedUser: ["GET /user/codespaces"],
      listInOrganization: [
        "GET /orgs/{org}/codespaces",
        {},
        { renamedParameters: { org_id: "org" } }
      ],
      listInRepositoryForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/codespaces"
      ],
      listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
      listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
      listRepositoriesForSecretForAuthenticatedUser: [
        "GET /user/codespaces/secrets/{secret_name}/repositories"
      ],
      listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
      listSelectedReposForOrgSecret: [
        "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
      ],
      preFlightWithRepoForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/codespaces/new"
      ],
      publishForAuthenticatedUser: [
        "POST /user/codespaces/{codespace_name}/publish"
      ],
      removeRepositoryForSecretForAuthenticatedUser: [
        "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
      ],
      removeSelectedRepoFromOrgSecret: [
        "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
      ],
      repoMachinesForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/codespaces/machines"
      ],
      setRepositoriesForSecretForAuthenticatedUser: [
        "PUT /user/codespaces/secrets/{secret_name}/repositories"
      ],
      setSelectedReposForOrgSecret: [
        "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
      ],
      startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
      stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
      stopInOrganization: [
        "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
      ],
      updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
    },
    copilot: {
      addCopilotSeatsForTeams: [
        "POST /orgs/{org}/copilot/billing/selected_teams"
      ],
      addCopilotSeatsForUsers: [
        "POST /orgs/{org}/copilot/billing/selected_users"
      ],
      cancelCopilotSeatAssignmentForTeams: [
        "DELETE /orgs/{org}/copilot/billing/selected_teams"
      ],
      cancelCopilotSeatAssignmentForUsers: [
        "DELETE /orgs/{org}/copilot/billing/selected_users"
      ],
      copilotMetricsForOrganization: ["GET /orgs/{org}/copilot/metrics"],
      copilotMetricsForTeam: ["GET /orgs/{org}/team/{team_slug}/copilot/metrics"],
      getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
      getCopilotSeatDetailsForUser: [
        "GET /orgs/{org}/members/{username}/copilot"
      ],
      listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"],
      usageMetricsForOrg: ["GET /orgs/{org}/copilot/usage"],
      usageMetricsForTeam: ["GET /orgs/{org}/team/{team_slug}/copilot/usage"]
    },
    dependabot: {
      addSelectedRepoToOrgSecret: [
        "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
      ],
      createOrUpdateOrgSecret: [
        "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
      ],
      createOrUpdateRepoSecret: [
        "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
      ],
      deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
      deleteRepoSecret: [
        "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
      ],
      getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
      getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
      getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
      getRepoPublicKey: [
        "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
      ],
      getRepoSecret: [
        "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
      ],
      listAlertsForEnterprise: [
        "GET /enterprises/{enterprise}/dependabot/alerts"
      ],
      listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
      listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
      listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
      listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
      listSelectedReposForOrgSecret: [
        "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
      ],
      removeSelectedRepoFromOrgSecret: [
        "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
      ],
      setSelectedReposForOrgSecret: [
        "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
      ],
      updateAlert: [
        "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
      ]
    },
    dependencyGraph: {
      createRepositorySnapshot: [
        "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
      ],
      diffRange: [
        "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
      ],
      exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
    },
    emojis: { get: ["GET /emojis"] },
    gists: {
      checkIsStarred: ["GET /gists/{gist_id}/star"],
      create: ["POST /gists"],
      createComment: ["POST /gists/{gist_id}/comments"],
      delete: ["DELETE /gists/{gist_id}"],
      deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
      fork: ["POST /gists/{gist_id}/forks"],
      get: ["GET /gists/{gist_id}"],
      getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
      getRevision: ["GET /gists/{gist_id}/{sha}"],
      list: ["GET /gists"],
      listComments: ["GET /gists/{gist_id}/comments"],
      listCommits: ["GET /gists/{gist_id}/commits"],
      listForUser: ["GET /users/{username}/gists"],
      listForks: ["GET /gists/{gist_id}/forks"],
      listPublic: ["GET /gists/public"],
      listStarred: ["GET /gists/starred"],
      star: ["PUT /gists/{gist_id}/star"],
      unstar: ["DELETE /gists/{gist_id}/star"],
      update: ["PATCH /gists/{gist_id}"],
      updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
    },
    git: {
      createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
      createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
      createRef: ["POST /repos/{owner}/{repo}/git/refs"],
      createTag: ["POST /repos/{owner}/{repo}/git/tags"],
      createTree: ["POST /repos/{owner}/{repo}/git/trees"],
      deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
      getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
      getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
      getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
      getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
      getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
      listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
      updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
    },
    gitignore: {
      getAllTemplates: ["GET /gitignore/templates"],
      getTemplate: ["GET /gitignore/templates/{name}"]
    },
    hostedCompute: {
      createNetworkConfigurationForOrg: [
        "POST /orgs/{org}/settings/network-configurations"
      ],
      deleteNetworkConfigurationFromOrg: [
        "DELETE /orgs/{org}/settings/network-configurations/{network_configuration_id}"
      ],
      getNetworkConfigurationForOrg: [
        "GET /orgs/{org}/settings/network-configurations/{network_configuration_id}"
      ],
      getNetworkSettingsForOrg: [
        "GET /orgs/{org}/settings/network-settings/{network_settings_id}"
      ],
      listNetworkConfigurationsForOrg: [
        "GET /orgs/{org}/settings/network-configurations"
      ],
      updateNetworkConfigurationForOrg: [
        "PATCH /orgs/{org}/settings/network-configurations/{network_configuration_id}"
      ]
    },
    interactions: {
      getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
      getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
      getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
      getRestrictionsForYourPublicRepos: [
        "GET /user/interaction-limits",
        {},
        { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
      ],
      removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
      removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
      removeRestrictionsForRepo: [
        "DELETE /repos/{owner}/{repo}/interaction-limits"
      ],
      removeRestrictionsForYourPublicRepos: [
        "DELETE /user/interaction-limits",
        {},
        { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
      ],
      setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
      setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
      setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
      setRestrictionsForYourPublicRepos: [
        "PUT /user/interaction-limits",
        {},
        { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
      ]
    },
    issues: {
      addAssignees: [
        "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
      ],
      addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
      addSubIssue: [
        "POST /repos/{owner}/{repo}/issues/{issue_number}/sub_issues"
      ],
      checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
      checkUserCanBeAssignedToIssue: [
        "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
      ],
      create: ["POST /repos/{owner}/{repo}/issues"],
      createComment: [
        "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
      ],
      createLabel: ["POST /repos/{owner}/{repo}/labels"],
      createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
      deleteComment: [
        "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
      ],
      deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
      deleteMilestone: [
        "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
      ],
      get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
      getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
      getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
      getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
      getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
      list: ["GET /issues"],
      listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
      listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
      listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
      listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
      listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
      listEventsForTimeline: [
        "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
      ],
      listForAuthenticatedUser: ["GET /user/issues"],
      listForOrg: ["GET /orgs/{org}/issues"],
      listForRepo: ["GET /repos/{owner}/{repo}/issues"],
      listLabelsForMilestone: [
        "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
      ],
      listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
      listLabelsOnIssue: [
        "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
      ],
      listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
      listSubIssues: [
        "GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues"
      ],
      lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
      removeAllLabels: [
        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
      ],
      removeAssignees: [
        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
      ],
      removeLabel: [
        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
      ],
      removeSubIssue: [
        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/sub_issue"
      ],
      reprioritizeSubIssue: [
        "PATCH /repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority"
      ],
      setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
      unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
      update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
      updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
      updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
      updateMilestone: [
        "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
      ]
    },
    licenses: {
      get: ["GET /licenses/{license}"],
      getAllCommonlyUsed: ["GET /licenses"],
      getForRepo: ["GET /repos/{owner}/{repo}/license"]
    },
    markdown: {
      render: ["POST /markdown"],
      renderRaw: [
        "POST /markdown/raw",
        { headers: { "content-type": "text/plain; charset=utf-8" } }
      ]
    },
    meta: {
      get: ["GET /meta"],
      getAllVersions: ["GET /versions"],
      getOctocat: ["GET /octocat"],
      getZen: ["GET /zen"],
      root: ["GET /"]
    },
    migrations: {
      deleteArchiveForAuthenticatedUser: [
        "DELETE /user/migrations/{migration_id}/archive"
      ],
      deleteArchiveForOrg: [
        "DELETE /orgs/{org}/migrations/{migration_id}/archive"
      ],
      downloadArchiveForOrg: [
        "GET /orgs/{org}/migrations/{migration_id}/archive"
      ],
      getArchiveForAuthenticatedUser: [
        "GET /user/migrations/{migration_id}/archive"
      ],
      getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
      getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
      listForAuthenticatedUser: ["GET /user/migrations"],
      listForOrg: ["GET /orgs/{org}/migrations"],
      listReposForAuthenticatedUser: [
        "GET /user/migrations/{migration_id}/repositories"
      ],
      listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
      listReposForUser: [
        "GET /user/migrations/{migration_id}/repositories",
        {},
        { renamed: ["migrations", "listReposForAuthenticatedUser"] }
      ],
      startForAuthenticatedUser: ["POST /user/migrations"],
      startForOrg: ["POST /orgs/{org}/migrations"],
      unlockRepoForAuthenticatedUser: [
        "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
      ],
      unlockRepoForOrg: [
        "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
      ]
    },
    oidc: {
      getOidcCustomSubTemplateForOrg: [
        "GET /orgs/{org}/actions/oidc/customization/sub"
      ],
      updateOidcCustomSubTemplateForOrg: [
        "PUT /orgs/{org}/actions/oidc/customization/sub"
      ]
    },
    orgs: {
      addSecurityManagerTeam: [
        "PUT /orgs/{org}/security-managers/teams/{team_slug}",
        {},
        {
          deprecated: "octokit.rest.orgs.addSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#add-a-security-manager-team"
        }
      ],
      assignTeamToOrgRole: [
        "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
      ],
      assignUserToOrgRole: [
        "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
      ],
      blockUser: ["PUT /orgs/{org}/blocks/{username}"],
      cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
      checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
      checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
      checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
      convertMemberToOutsideCollaborator: [
        "PUT /orgs/{org}/outside_collaborators/{username}"
      ],
      createInvitation: ["POST /orgs/{org}/invitations"],
      createIssueType: ["POST /orgs/{org}/issue-types"],
      createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
      createOrUpdateCustomPropertiesValuesForRepos: [
        "PATCH /orgs/{org}/properties/values"
      ],
      createOrUpdateCustomProperty: [
        "PUT /orgs/{org}/properties/schema/{custom_property_name}"
      ],
      createWebhook: ["POST /orgs/{org}/hooks"],
      delete: ["DELETE /orgs/{org}"],
      deleteIssueType: ["DELETE /orgs/{org}/issue-types/{issue_type_id}"],
      deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
      enableOrDisableSecurityProductOnAllOrgRepos: [
        "POST /orgs/{org}/{security_product}/{enablement}",
        {},
        {
          deprecated: "octokit.rest.orgs.enableOrDisableSecurityProductOnAllOrgRepos() is deprecated, see https://docs.github.com/rest/orgs/orgs#enable-or-disable-a-security-feature-for-an-organization"
        }
      ],
      get: ["GET /orgs/{org}"],
      getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
      getCustomProperty: [
        "GET /orgs/{org}/properties/schema/{custom_property_name}"
      ],
      getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
      getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
      getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
      getOrgRulesetHistory: ["GET /orgs/{org}/rulesets/{ruleset_id}/history"],
      getOrgRulesetVersion: [
        "GET /orgs/{org}/rulesets/{ruleset_id}/history/{version_id}"
      ],
      getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
      getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
      getWebhookDelivery: [
        "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
      ],
      list: ["GET /organizations"],
      listAppInstallations: ["GET /orgs/{org}/installations"],
      listAttestations: ["GET /orgs/{org}/attestations/{subject_digest}"],
      listBlockedUsers: ["GET /orgs/{org}/blocks"],
      listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
      listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
      listForAuthenticatedUser: ["GET /user/orgs"],
      listForUser: ["GET /users/{username}/orgs"],
      listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
      listIssueTypes: ["GET /orgs/{org}/issue-types"],
      listMembers: ["GET /orgs/{org}/members"],
      listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
      listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
      listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
      listOrgRoles: ["GET /orgs/{org}/organization-roles"],
      listOrganizationFineGrainedPermissions: [
        "GET /orgs/{org}/organization-fine-grained-permissions"
      ],
      listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
      listPatGrantRepositories: [
        "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
      ],
      listPatGrantRequestRepositories: [
        "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
      ],
      listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
      listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
      listPendingInvitations: ["GET /orgs/{org}/invitations"],
      listPublicMembers: ["GET /orgs/{org}/public_members"],
      listSecurityManagerTeams: [
        "GET /orgs/{org}/security-managers",
        {},
        {
          deprecated: "octokit.rest.orgs.listSecurityManagerTeams() is deprecated, see https://docs.github.com/rest/orgs/security-managers#list-security-manager-teams"
        }
      ],
      listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
      listWebhooks: ["GET /orgs/{org}/hooks"],
      pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
      redeliverWebhookDelivery: [
        "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
      ],
      removeCustomProperty: [
        "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
      ],
      removeMember: ["DELETE /orgs/{org}/members/{username}"],
      removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
      removeOutsideCollaborator: [
        "DELETE /orgs/{org}/outside_collaborators/{username}"
      ],
      removePublicMembershipForAuthenticatedUser: [
        "DELETE /orgs/{org}/public_members/{username}"
      ],
      removeSecurityManagerTeam: [
        "DELETE /orgs/{org}/security-managers/teams/{team_slug}",
        {},
        {
          deprecated: "octokit.rest.orgs.removeSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#remove-a-security-manager-team"
        }
      ],
      reviewPatGrantRequest: [
        "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
      ],
      reviewPatGrantRequestsInBulk: [
        "POST /orgs/{org}/personal-access-token-requests"
      ],
      revokeAllOrgRolesTeam: [
        "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
      ],
      revokeAllOrgRolesUser: [
        "DELETE /orgs/{org}/organization-roles/users/{username}"
      ],
      revokeOrgRoleTeam: [
        "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
      ],
      revokeOrgRoleUser: [
        "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
      ],
      setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
      setPublicMembershipForAuthenticatedUser: [
        "PUT /orgs/{org}/public_members/{username}"
      ],
      unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
      update: ["PATCH /orgs/{org}"],
      updateIssueType: ["PUT /orgs/{org}/issue-types/{issue_type_id}"],
      updateMembershipForAuthenticatedUser: [
        "PATCH /user/memberships/orgs/{org}"
      ],
      updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
      updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
      updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
      updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
    },
    packages: {
      deletePackageForAuthenticatedUser: [
        "DELETE /user/packages/{package_type}/{package_name}"
      ],
      deletePackageForOrg: [
        "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
      ],
      deletePackageForUser: [
        "DELETE /users/{username}/packages/{package_type}/{package_name}"
      ],
      deletePackageVersionForAuthenticatedUser: [
        "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      deletePackageVersionForOrg: [
        "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      deletePackageVersionForUser: [
        "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      getAllPackageVersionsForAPackageOwnedByAnOrg: [
        "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
        {},
        { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
      ],
      getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
        "GET /user/packages/{package_type}/{package_name}/versions",
        {},
        {
          renamed: [
            "packages",
            "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
          ]
        }
      ],
      getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
        "GET /user/packages/{package_type}/{package_name}/versions"
      ],
      getAllPackageVersionsForPackageOwnedByOrg: [
        "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
      ],
      getAllPackageVersionsForPackageOwnedByUser: [
        "GET /users/{username}/packages/{package_type}/{package_name}/versions"
      ],
      getPackageForAuthenticatedUser: [
        "GET /user/packages/{package_type}/{package_name}"
      ],
      getPackageForOrganization: [
        "GET /orgs/{org}/packages/{package_type}/{package_name}"
      ],
      getPackageForUser: [
        "GET /users/{username}/packages/{package_type}/{package_name}"
      ],
      getPackageVersionForAuthenticatedUser: [
        "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      getPackageVersionForOrganization: [
        "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      getPackageVersionForUser: [
        "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      listDockerMigrationConflictingPackagesForAuthenticatedUser: [
        "GET /user/docker/conflicts"
      ],
      listDockerMigrationConflictingPackagesForOrganization: [
        "GET /orgs/{org}/docker/conflicts"
      ],
      listDockerMigrationConflictingPackagesForUser: [
        "GET /users/{username}/docker/conflicts"
      ],
      listPackagesForAuthenticatedUser: ["GET /user/packages"],
      listPackagesForOrganization: ["GET /orgs/{org}/packages"],
      listPackagesForUser: ["GET /users/{username}/packages"],
      restorePackageForAuthenticatedUser: [
        "POST /user/packages/{package_type}/{package_name}/restore{?token}"
      ],
      restorePackageForOrg: [
        "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
      ],
      restorePackageForUser: [
        "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
      ],
      restorePackageVersionForAuthenticatedUser: [
        "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
      ],
      restorePackageVersionForOrg: [
        "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
      ],
      restorePackageVersionForUser: [
        "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
      ]
    },
    privateRegistries: {
      createOrgPrivateRegistry: ["POST /orgs/{org}/private-registries"],
      deleteOrgPrivateRegistry: [
        "DELETE /orgs/{org}/private-registries/{secret_name}"
      ],
      getOrgPrivateRegistry: ["GET /orgs/{org}/private-registries/{secret_name}"],
      getOrgPublicKey: ["GET /orgs/{org}/private-registries/public-key"],
      listOrgPrivateRegistries: ["GET /orgs/{org}/private-registries"],
      updateOrgPrivateRegistry: [
        "PATCH /orgs/{org}/private-registries/{secret_name}"
      ]
    },
    projects: {
      addCollaborator: [
        "PUT /projects/{project_id}/collaborators/{username}",
        {},
        {
          deprecated: "octokit.rest.projects.addCollaborator() is deprecated, see https://docs.github.com/rest/projects/collaborators#add-project-collaborator"
        }
      ],
      createCard: [
        "POST /projects/columns/{column_id}/cards",
        {},
        {
          deprecated: "octokit.rest.projects.createCard() is deprecated, see https://docs.github.com/rest/projects/cards#create-a-project-card"
        }
      ],
      createColumn: [
        "POST /projects/{project_id}/columns",
        {},
        {
          deprecated: "octokit.rest.projects.createColumn() is deprecated, see https://docs.github.com/rest/projects/columns#create-a-project-column"
        }
      ],
      createForAuthenticatedUser: [
        "POST /user/projects",
        {},
        {
          deprecated: "octokit.rest.projects.createForAuthenticatedUser() is deprecated, see https://docs.github.com/rest/projects/projects#create-a-user-project"
        }
      ],
      createForOrg: [
        "POST /orgs/{org}/projects",
        {},
        {
          deprecated: "octokit.rest.projects.createForOrg() is deprecated, see https://docs.github.com/rest/projects/projects#create-an-organization-project"
        }
      ],
      createForRepo: [
        "POST /repos/{owner}/{repo}/projects",
        {},
        {
          deprecated: "octokit.rest.projects.createForRepo() is deprecated, see https://docs.github.com/rest/projects/projects#create-a-repository-project"
        }
      ],
      delete: [
        "DELETE /projects/{project_id}",
        {},
        {
          deprecated: "octokit.rest.projects.delete() is deprecated, see https://docs.github.com/rest/projects/projects#delete-a-project"
        }
      ],
      deleteCard: [
        "DELETE /projects/columns/cards/{card_id}",
        {},
        {
          deprecated: "octokit.rest.projects.deleteCard() is deprecated, see https://docs.github.com/rest/projects/cards#delete-a-project-card"
        }
      ],
      deleteColumn: [
        "DELETE /projects/columns/{column_id}",
        {},
        {
          deprecated: "octokit.rest.projects.deleteColumn() is deprecated, see https://docs.github.com/rest/projects/columns#delete-a-project-column"
        }
      ],
      get: [
        "GET /projects/{project_id}",
        {},
        {
          deprecated: "octokit.rest.projects.get() is deprecated, see https://docs.github.com/rest/projects/projects#get-a-project"
        }
      ],
      getCard: [
        "GET /projects/columns/cards/{card_id}",
        {},
        {
          deprecated: "octokit.rest.projects.getCard() is deprecated, see https://docs.github.com/rest/projects/cards#get-a-project-card"
        }
      ],
      getColumn: [
        "GET /projects/columns/{column_id}",
        {},
        {
          deprecated: "octokit.rest.projects.getColumn() is deprecated, see https://docs.github.com/rest/projects/columns#get-a-project-column"
        }
      ],
      getPermissionForUser: [
        "GET /projects/{project_id}/collaborators/{username}/permission",
        {},
        {
          deprecated: "octokit.rest.projects.getPermissionForUser() is deprecated, see https://docs.github.com/rest/projects/collaborators#get-project-permission-for-a-user"
        }
      ],
      listCards: [
        "GET /projects/columns/{column_id}/cards",
        {},
        {
          deprecated: "octokit.rest.projects.listCards() is deprecated, see https://docs.github.com/rest/projects/cards#list-project-cards"
        }
      ],
      listCollaborators: [
        "GET /projects/{project_id}/collaborators",
        {},
        {
          deprecated: "octokit.rest.projects.listCollaborators() is deprecated, see https://docs.github.com/rest/projects/collaborators#list-project-collaborators"
        }
      ],
      listColumns: [
        "GET /projects/{project_id}/columns",
        {},
        {
          deprecated: "octokit.rest.projects.listColumns() is deprecated, see https://docs.github.com/rest/projects/columns#list-project-columns"
        }
      ],
      listForOrg: [
        "GET /orgs/{org}/projects",
        {},
        {
          deprecated: "octokit.rest.projects.listForOrg() is deprecated, see https://docs.github.com/rest/projects/projects#list-organization-projects"
        }
      ],
      listForRepo: [
        "GET /repos/{owner}/{repo}/projects",
        {},
        {
          deprecated: "octokit.rest.projects.listForRepo() is deprecated, see https://docs.github.com/rest/projects/projects#list-repository-projects"
        }
      ],
      listForUser: [
        "GET /users/{username}/projects",
        {},
        {
          deprecated: "octokit.rest.projects.listForUser() is deprecated, see https://docs.github.com/rest/projects/projects#list-user-projects"
        }
      ],
      moveCard: [
        "POST /projects/columns/cards/{card_id}/moves",
        {},
        {
          deprecated: "octokit.rest.projects.moveCard() is deprecated, see https://docs.github.com/rest/projects/cards#move-a-project-card"
        }
      ],
      moveColumn: [
        "POST /projects/columns/{column_id}/moves",
        {},
        {
          deprecated: "octokit.rest.projects.moveColumn() is deprecated, see https://docs.github.com/rest/projects/columns#move-a-project-column"
        }
      ],
      removeCollaborator: [
        "DELETE /projects/{project_id}/collaborators/{username}",
        {},
        {
          deprecated: "octokit.rest.projects.removeCollaborator() is deprecated, see https://docs.github.com/rest/projects/collaborators#remove-user-as-a-collaborator"
        }
      ],
      update: [
        "PATCH /projects/{project_id}",
        {},
        {
          deprecated: "octokit.rest.projects.update() is deprecated, see https://docs.github.com/rest/projects/projects#update-a-project"
        }
      ],
      updateCard: [
        "PATCH /projects/columns/cards/{card_id}",
        {},
        {
          deprecated: "octokit.rest.projects.updateCard() is deprecated, see https://docs.github.com/rest/projects/cards#update-an-existing-project-card"
        }
      ],
      updateColumn: [
        "PATCH /projects/columns/{column_id}",
        {},
        {
          deprecated: "octokit.rest.projects.updateColumn() is deprecated, see https://docs.github.com/rest/projects/columns#update-an-existing-project-column"
        }
      ]
    },
    pulls: {
      checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
      create: ["POST /repos/{owner}/{repo}/pulls"],
      createReplyForReviewComment: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
      ],
      createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
      createReviewComment: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
      ],
      deletePendingReview: [
        "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
      ],
      deleteReviewComment: [
        "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
      ],
      dismissReview: [
        "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
      ],
      get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
      getReview: [
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
      ],
      getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
      list: ["GET /repos/{owner}/{repo}/pulls"],
      listCommentsForReview: [
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
      ],
      listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
      listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
      listRequestedReviewers: [
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
      ],
      listReviewComments: [
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
      ],
      listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
      listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
      merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
      removeRequestedReviewers: [
        "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
      ],
      requestReviewers: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
      ],
      submitReview: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
      ],
      update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
      updateBranch: [
        "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
      ],
      updateReview: [
        "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
      ],
      updateReviewComment: [
        "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
      ]
    },
    rateLimit: { get: ["GET /rate_limit"] },
    reactions: {
      createForCommitComment: [
        "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
      ],
      createForIssue: [
        "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
      ],
      createForIssueComment: [
        "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
      ],
      createForPullRequestReviewComment: [
        "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
      ],
      createForRelease: [
        "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
      ],
      createForTeamDiscussionCommentInOrg: [
        "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
      ],
      createForTeamDiscussionInOrg: [
        "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
      ],
      deleteForCommitComment: [
        "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
      ],
      deleteForIssue: [
        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
      ],
      deleteForIssueComment: [
        "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
      ],
      deleteForPullRequestComment: [
        "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
      ],
      deleteForRelease: [
        "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
      ],
      deleteForTeamDiscussion: [
        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
      ],
      deleteForTeamDiscussionComment: [
        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
      ],
      listForCommitComment: [
        "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
      ],
      listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
      listForIssueComment: [
        "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
      ],
      listForPullRequestReviewComment: [
        "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
      ],
      listForRelease: [
        "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
      ],
      listForTeamDiscussionCommentInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
      ],
      listForTeamDiscussionInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
      ]
    },
    repos: {
      acceptInvitation: [
        "PATCH /user/repository_invitations/{invitation_id}",
        {},
        { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
      ],
      acceptInvitationForAuthenticatedUser: [
        "PATCH /user/repository_invitations/{invitation_id}"
      ],
      addAppAccessRestrictions: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
        {},
        { mapToData: "apps" }
      ],
      addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
      addStatusCheckContexts: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
        {},
        { mapToData: "contexts" }
      ],
      addTeamAccessRestrictions: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
        {},
        { mapToData: "teams" }
      ],
      addUserAccessRestrictions: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
        {},
        { mapToData: "users" }
      ],
      cancelPagesDeployment: [
        "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
      ],
      checkAutomatedSecurityFixes: [
        "GET /repos/{owner}/{repo}/automated-security-fixes"
      ],
      checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
      checkPrivateVulnerabilityReporting: [
        "GET /repos/{owner}/{repo}/private-vulnerability-reporting"
      ],
      checkVulnerabilityAlerts: [
        "GET /repos/{owner}/{repo}/vulnerability-alerts"
      ],
      codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
      compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
      compareCommitsWithBasehead: [
        "GET /repos/{owner}/{repo}/compare/{basehead}"
      ],
      createAttestation: ["POST /repos/{owner}/{repo}/attestations"],
      createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
      createCommitComment: [
        "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
      ],
      createCommitSignatureProtection: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
      ],
      createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
      createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
      createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
      createDeploymentBranchPolicy: [
        "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
      ],
      createDeploymentProtectionRule: [
        "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
      ],
      createDeploymentStatus: [
        "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
      ],
      createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
      createForAuthenticatedUser: ["POST /user/repos"],
      createFork: ["POST /repos/{owner}/{repo}/forks"],
      createInOrg: ["POST /orgs/{org}/repos"],
      createOrUpdateCustomPropertiesValues: [
        "PATCH /repos/{owner}/{repo}/properties/values"
      ],
      createOrUpdateEnvironment: [
        "PUT /repos/{owner}/{repo}/environments/{environment_name}"
      ],
      createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
      createOrgRuleset: ["POST /orgs/{org}/rulesets"],
      createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
      createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
      createRelease: ["POST /repos/{owner}/{repo}/releases"],
      createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
      createUsingTemplate: [
        "POST /repos/{template_owner}/{template_repo}/generate"
      ],
      createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
      declineInvitation: [
        "DELETE /user/repository_invitations/{invitation_id}",
        {},
        { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
      ],
      declineInvitationForAuthenticatedUser: [
        "DELETE /user/repository_invitations/{invitation_id}"
      ],
      delete: ["DELETE /repos/{owner}/{repo}"],
      deleteAccessRestrictions: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
      ],
      deleteAdminBranchProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
      ],
      deleteAnEnvironment: [
        "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
      ],
      deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
      deleteBranchProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
      ],
      deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
      deleteCommitSignatureProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
      ],
      deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
      deleteDeployment: [
        "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
      ],
      deleteDeploymentBranchPolicy: [
        "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
      ],
      deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
      deleteInvitation: [
        "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
      ],
      deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
      deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
      deletePullRequestReviewProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
      ],
      deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
      deleteReleaseAsset: [
        "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
      ],
      deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
      deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
      disableAutomatedSecurityFixes: [
        "DELETE /repos/{owner}/{repo}/automated-security-fixes"
      ],
      disableDeploymentProtectionRule: [
        "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
      ],
      disablePrivateVulnerabilityReporting: [
        "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
      ],
      disableVulnerabilityAlerts: [
        "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
      ],
      downloadArchive: [
        "GET /repos/{owner}/{repo}/zipball/{ref}",
        {},
        { renamed: ["repos", "downloadZipballArchive"] }
      ],
      downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
      downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
      enableAutomatedSecurityFixes: [
        "PUT /repos/{owner}/{repo}/automated-security-fixes"
      ],
      enablePrivateVulnerabilityReporting: [
        "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
      ],
      enableVulnerabilityAlerts: [
        "PUT /repos/{owner}/{repo}/vulnerability-alerts"
      ],
      generateReleaseNotes: [
        "POST /repos/{owner}/{repo}/releases/generate-notes"
      ],
      get: ["GET /repos/{owner}/{repo}"],
      getAccessRestrictions: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
      ],
      getAdminBranchProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
      ],
      getAllDeploymentProtectionRules: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
      ],
      getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
      getAllStatusCheckContexts: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
      ],
      getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
      getAppsWithAccessToProtectedBranch: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
      ],
      getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
      getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
      getBranchProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection"
      ],
      getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
      getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
      getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
      getCollaboratorPermissionLevel: [
        "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
      ],
      getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
      getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
      getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
      getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
      getCommitSignatureProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
      ],
      getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
      getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
      getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
      getCustomDeploymentProtectionRule: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
      ],
      getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
      getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
      getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
      getDeploymentBranchPolicy: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
      ],
      getDeploymentStatus: [
        "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
      ],
      getEnvironment: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}"
      ],
      getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
      getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
      getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
      getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
      getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
      getOrgRulesets: ["GET /orgs/{org}/rulesets"],
      getPages: ["GET /repos/{owner}/{repo}/pages"],
      getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
      getPagesDeployment: [
        "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
      ],
      getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
      getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
      getPullRequestReviewProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
      ],
      getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
      getReadme: ["GET /repos/{owner}/{repo}/readme"],
      getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
      getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
      getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
      getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
      getRepoRuleSuite: [
        "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
      ],
      getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
      getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
      getRepoRulesetHistory: [
        "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history"
      ],
      getRepoRulesetVersion: [
        "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}"
      ],
      getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
      getStatusChecksProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
      ],
      getTeamsWithAccessToProtectedBranch: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
      ],
      getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
      getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
      getUsersWithAccessToProtectedBranch: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
      ],
      getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
      getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
      getWebhookConfigForRepo: [
        "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
      ],
      getWebhookDelivery: [
        "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
      ],
      listActivities: ["GET /repos/{owner}/{repo}/activity"],
      listAttestations: [
        "GET /repos/{owner}/{repo}/attestations/{subject_digest}"
      ],
      listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
      listBranches: ["GET /repos/{owner}/{repo}/branches"],
      listBranchesForHeadCommit: [
        "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
      ],
      listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
      listCommentsForCommit: [
        "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
      ],
      listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
      listCommitStatusesForRef: [
        "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
      ],
      listCommits: ["GET /repos/{owner}/{repo}/commits"],
      listContributors: ["GET /repos/{owner}/{repo}/contributors"],
      listCustomDeploymentRuleIntegrations: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
      ],
      listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
      listDeploymentBranchPolicies: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
      ],
      listDeploymentStatuses: [
        "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
      ],
      listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
      listForAuthenticatedUser: ["GET /user/repos"],
      listForOrg: ["GET /orgs/{org}/repos"],
      listForUser: ["GET /users/{username}/repos"],
      listForks: ["GET /repos/{owner}/{repo}/forks"],
      listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
      listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
      listLanguages: ["GET /repos/{owner}/{repo}/languages"],
      listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
      listPublic: ["GET /repositories"],
      listPullRequestsAssociatedWithCommit: [
        "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
      ],
      listReleaseAssets: [
        "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
      ],
      listReleases: ["GET /repos/{owner}/{repo}/releases"],
      listTags: ["GET /repos/{owner}/{repo}/tags"],
      listTeams: ["GET /repos/{owner}/{repo}/teams"],
      listWebhookDeliveries: [
        "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
      ],
      listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
      merge: ["POST /repos/{owner}/{repo}/merges"],
      mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
      pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
      redeliverWebhookDelivery: [
        "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
      ],
      removeAppAccessRestrictions: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
        {},
        { mapToData: "apps" }
      ],
      removeCollaborator: [
        "DELETE /repos/{owner}/{repo}/collaborators/{username}"
      ],
      removeStatusCheckContexts: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
        {},
        { mapToData: "contexts" }
      ],
      removeStatusCheckProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
      ],
      removeTeamAccessRestrictions: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
        {},
        { mapToData: "teams" }
      ],
      removeUserAccessRestrictions: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
        {},
        { mapToData: "users" }
      ],
      renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
      replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
      requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
      setAdminBranchProtection: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
      ],
      setAppAccessRestrictions: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
        {},
        { mapToData: "apps" }
      ],
      setStatusCheckContexts: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
        {},
        { mapToData: "contexts" }
      ],
      setTeamAccessRestrictions: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
        {},
        { mapToData: "teams" }
      ],
      setUserAccessRestrictions: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
        {},
        { mapToData: "users" }
      ],
      testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
      transfer: ["POST /repos/{owner}/{repo}/transfer"],
      update: ["PATCH /repos/{owner}/{repo}"],
      updateBranchProtection: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
      ],
      updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
      updateDeploymentBranchPolicy: [
        "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
      ],
      updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
      updateInvitation: [
        "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
      ],
      updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
      updatePullRequestReviewProtection: [
        "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
      ],
      updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
      updateReleaseAsset: [
        "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
      ],
      updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
      updateStatusCheckPotection: [
        "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
        {},
        { renamed: ["repos", "updateStatusCheckProtection"] }
      ],
      updateStatusCheckProtection: [
        "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
      ],
      updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
      updateWebhookConfigForRepo: [
        "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
      ],
      uploadReleaseAsset: [
        "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
        { baseUrl: "https://uploads.github.com" }
      ]
    },
    search: {
      code: ["GET /search/code"],
      commits: ["GET /search/commits"],
      issuesAndPullRequests: [
        "GET /search/issues",
        {},
        {
          deprecated: "octokit.rest.search.issuesAndPullRequests() is deprecated, see https://docs.github.com/rest/search/search#search-issues-and-pull-requests"
        }
      ],
      labels: ["GET /search/labels"],
      repos: ["GET /search/repositories"],
      topics: ["GET /search/topics"],
      users: ["GET /search/users"]
    },
    secretScanning: {
      createPushProtectionBypass: [
        "POST /repos/{owner}/{repo}/secret-scanning/push-protection-bypasses"
      ],
      getAlert: [
        "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
      ],
      getScanHistory: ["GET /repos/{owner}/{repo}/secret-scanning/scan-history"],
      listAlertsForEnterprise: [
        "GET /enterprises/{enterprise}/secret-scanning/alerts"
      ],
      listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
      listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
      listLocationsForAlert: [
        "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
      ],
      updateAlert: [
        "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
      ]
    },
    securityAdvisories: {
      createFork: [
        "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
      ],
      createPrivateVulnerabilityReport: [
        "POST /repos/{owner}/{repo}/security-advisories/reports"
      ],
      createRepositoryAdvisory: [
        "POST /repos/{owner}/{repo}/security-advisories"
      ],
      createRepositoryAdvisoryCveRequest: [
        "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
      ],
      getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
      getRepositoryAdvisory: [
        "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
      ],
      listGlobalAdvisories: ["GET /advisories"],
      listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
      listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
      updateRepositoryAdvisory: [
        "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
      ]
    },
    teams: {
      addOrUpdateMembershipForUserInOrg: [
        "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
      ],
      addOrUpdateProjectPermissionsInOrg: [
        "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}",
        {},
        {
          deprecated: "octokit.rest.teams.addOrUpdateProjectPermissionsInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#add-or-update-team-project-permissions"
        }
      ],
      addOrUpdateProjectPermissionsLegacy: [
        "PUT /teams/{team_id}/projects/{project_id}",
        {},
        {
          deprecated: "octokit.rest.teams.addOrUpdateProjectPermissionsLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#add-or-update-team-project-permissions-legacy"
        }
      ],
      addOrUpdateRepoPermissionsInOrg: [
        "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
      ],
      checkPermissionsForProjectInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}",
        {},
        {
          deprecated: "octokit.rest.teams.checkPermissionsForProjectInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#check-team-permissions-for-a-project"
        }
      ],
      checkPermissionsForProjectLegacy: [
        "GET /teams/{team_id}/projects/{project_id}",
        {},
        {
          deprecated: "octokit.rest.teams.checkPermissionsForProjectLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#check-team-permissions-for-a-project-legacy"
        }
      ],
      checkPermissionsForRepoInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
      ],
      create: ["POST /orgs/{org}/teams"],
      createDiscussionCommentInOrg: [
        "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
      ],
      createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
      deleteDiscussionCommentInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
      ],
      deleteDiscussionInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
      ],
      deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
      getByName: ["GET /orgs/{org}/teams/{team_slug}"],
      getDiscussionCommentInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
      ],
      getDiscussionInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
      ],
      getMembershipForUserInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
      ],
      list: ["GET /orgs/{org}/teams"],
      listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
      listDiscussionCommentsInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
      ],
      listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
      listForAuthenticatedUser: ["GET /user/teams"],
      listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
      listPendingInvitationsInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/invitations"
      ],
      listProjectsInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/projects",
        {},
        {
          deprecated: "octokit.rest.teams.listProjectsInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#list-team-projects"
        }
      ],
      listProjectsLegacy: [
        "GET /teams/{team_id}/projects",
        {},
        {
          deprecated: "octokit.rest.teams.listProjectsLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#list-team-projects-legacy"
        }
      ],
      listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
      removeMembershipForUserInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
      ],
      removeProjectInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}",
        {},
        {
          deprecated: "octokit.rest.teams.removeProjectInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#remove-a-project-from-a-team"
        }
      ],
      removeProjectLegacy: [
        "DELETE /teams/{team_id}/projects/{project_id}",
        {},
        {
          deprecated: "octokit.rest.teams.removeProjectLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#remove-a-project-from-a-team-legacy"
        }
      ],
      removeRepoInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
      ],
      updateDiscussionCommentInOrg: [
        "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
      ],
      updateDiscussionInOrg: [
        "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
      ],
      updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
    },
    users: {
      addEmailForAuthenticated: [
        "POST /user/emails",
        {},
        { renamed: ["users", "addEmailForAuthenticatedUser"] }
      ],
      addEmailForAuthenticatedUser: ["POST /user/emails"],
      addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
      block: ["PUT /user/blocks/{username}"],
      checkBlocked: ["GET /user/blocks/{username}"],
      checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
      checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
      createGpgKeyForAuthenticated: [
        "POST /user/gpg_keys",
        {},
        { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
      ],
      createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
      createPublicSshKeyForAuthenticated: [
        "POST /user/keys",
        {},
        { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
      ],
      createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
      createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
      deleteEmailForAuthenticated: [
        "DELETE /user/emails",
        {},
        { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
      ],
      deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
      deleteGpgKeyForAuthenticated: [
        "DELETE /user/gpg_keys/{gpg_key_id}",
        {},
        { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
      ],
      deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
      deletePublicSshKeyForAuthenticated: [
        "DELETE /user/keys/{key_id}",
        {},
        { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
      ],
      deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
      deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
      deleteSshSigningKeyForAuthenticatedUser: [
        "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
      ],
      follow: ["PUT /user/following/{username}"],
      getAuthenticated: ["GET /user"],
      getById: ["GET /user/{account_id}"],
      getByUsername: ["GET /users/{username}"],
      getContextForUser: ["GET /users/{username}/hovercard"],
      getGpgKeyForAuthenticated: [
        "GET /user/gpg_keys/{gpg_key_id}",
        {},
        { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
      ],
      getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
      getPublicSshKeyForAuthenticated: [
        "GET /user/keys/{key_id}",
        {},
        { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
      ],
      getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
      getSshSigningKeyForAuthenticatedUser: [
        "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
      ],
      list: ["GET /users"],
      listAttestations: ["GET /users/{username}/attestations/{subject_digest}"],
      listBlockedByAuthenticated: [
        "GET /user/blocks",
        {},
        { renamed: ["users", "listBlockedByAuthenticatedUser"] }
      ],
      listBlockedByAuthenticatedUser: ["GET /user/blocks"],
      listEmailsForAuthenticated: [
        "GET /user/emails",
        {},
        { renamed: ["users", "listEmailsForAuthenticatedUser"] }
      ],
      listEmailsForAuthenticatedUser: ["GET /user/emails"],
      listFollowedByAuthenticated: [
        "GET /user/following",
        {},
        { renamed: ["users", "listFollowedByAuthenticatedUser"] }
      ],
      listFollowedByAuthenticatedUser: ["GET /user/following"],
      listFollowersForAuthenticatedUser: ["GET /user/followers"],
      listFollowersForUser: ["GET /users/{username}/followers"],
      listFollowingForUser: ["GET /users/{username}/following"],
      listGpgKeysForAuthenticated: [
        "GET /user/gpg_keys",
        {},
        { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
      ],
      listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
      listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
      listPublicEmailsForAuthenticated: [
        "GET /user/public_emails",
        {},
        { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
      ],
      listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
      listPublicKeysForUser: ["GET /users/{username}/keys"],
      listPublicSshKeysForAuthenticated: [
        "GET /user/keys",
        {},
        { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
      ],
      listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
      listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
      listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
      listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
      listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
      setPrimaryEmailVisibilityForAuthenticated: [
        "PATCH /user/email/visibility",
        {},
        { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
      ],
      setPrimaryEmailVisibilityForAuthenticatedUser: [
        "PATCH /user/email/visibility"
      ],
      unblock: ["DELETE /user/blocks/{username}"],
      unfollow: ["DELETE /user/following/{username}"],
      updateAuthenticated: ["PATCH /user"]
    }
  };
  endpoints_default = Endpoints;
});

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/endpoints-to-methods.js
function endpointsToMethods(octokit) {
  const newMethods = {};
  for (const scope of endpointMethodsMap.keys()) {
    newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);
  }
  return newMethods;
}
function decorate(octokit, scope, methodName, defaults, decorations) {
  const requestWithDefaults = octokit.request.defaults(defaults);
  function withDecorations(...args) {
    let options = requestWithDefaults.endpoint.merge(...args);
    if (decorations.mapToData) {
      options = Object.assign({}, options, {
        data: options[decorations.mapToData],
        [decorations.mapToData]: undefined
      });
      return requestWithDefaults(options);
    }
    if (decorations.renamed) {
      const [newScope, newMethodName] = decorations.renamed;
      octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
    }
    if (decorations.deprecated) {
      octokit.log.warn(decorations.deprecated);
    }
    if (decorations.renamedParameters) {
      const options2 = requestWithDefaults.endpoint.merge(...args);
      for (const [name, alias] of Object.entries(decorations.renamedParameters)) {
        if (name in options2) {
          octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);
          if (!(alias in options2)) {
            options2[alias] = options2[name];
          }
          delete options2[name];
        }
      }
      return requestWithDefaults(options2);
    }
    return requestWithDefaults(...args);
  }
  return Object.assign(withDecorations, requestWithDefaults);
}
var endpointMethodsMap, handler;
var init_endpoints_to_methods = __esm(() => {
  init_endpoints();
  endpointMethodsMap = /* @__PURE__ */ new Map;
  for (const [scope, endpoints] of Object.entries(endpoints_default)) {
    for (const [methodName, endpoint2] of Object.entries(endpoints)) {
      const [route, defaults, decorations] = endpoint2;
      const [method, url] = route.split(/ /);
      const endpointDefaults = Object.assign({
        method,
        url
      }, defaults);
      if (!endpointMethodsMap.has(scope)) {
        endpointMethodsMap.set(scope, /* @__PURE__ */ new Map);
      }
      endpointMethodsMap.get(scope).set(methodName, {
        scope,
        methodName,
        endpointDefaults,
        decorations
      });
    }
  }
  handler = {
    has({ scope }, methodName) {
      return endpointMethodsMap.get(scope).has(methodName);
    },
    getOwnPropertyDescriptor(target, methodName) {
      return {
        value: this.get(target, methodName),
        configurable: true,
        writable: true,
        enumerable: true
      };
    },
    defineProperty(target, methodName, descriptor) {
      Object.defineProperty(target.cache, methodName, descriptor);
      return true;
    },
    deleteProperty(target, methodName) {
      delete target.cache[methodName];
      return true;
    },
    ownKeys({ scope }) {
      return [...endpointMethodsMap.get(scope).keys()];
    },
    set(target, methodName, value) {
      return target.cache[methodName] = value;
    },
    get({ octokit, scope, cache }, methodName) {
      if (cache[methodName]) {
        return cache[methodName];
      }
      const method = endpointMethodsMap.get(scope).get(methodName);
      if (!method) {
        return;
      }
      const { endpointDefaults, decorations } = method;
      if (decorations) {
        cache[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
      } else {
        cache[methodName] = octokit.request.defaults(endpointDefaults);
      }
      return cache[methodName];
    }
  };
});

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/index.js
function restEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    rest: api
  };
}
function legacyRestEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    ...api,
    rest: api
  };
}
var init_dist_src4 = __esm(() => {
  init_version3();
  init_endpoints_to_methods();
  restEndpointMethods.VERSION = VERSION7;
  legacyRestEndpointMethods.VERSION = VERSION7;
});

// node_modules/@octokit/rest/dist-src/version.js
var VERSION8 = "21.1.1";
var init_version4 = () => {};

// node_modules/@octokit/rest/dist-src/index.js
var Octokit2;
var init_dist_src5 = __esm(() => {
  init_dist_src2();
  init_dist_src3();
  init_dist_bundle5();
  init_dist_src4();
  init_version4();
  Octokit2 = Octokit.plugin(requestLog, legacyRestEndpointMethods, paginateRest).defaults({
    userAgent: `octokit-rest.js/${VERSION8}`
  });
});

// src/github/client.ts
async function resolveToken(explicitToken) {
  const envToken = process.env["GITHUB_TOKEN"];
  if (envToken) {
    return envToken;
  }
  if (explicitToken) {
    return explicitToken;
  }
  return getGhToken();
}
async function createGitHubClient(options = {}) {
  const token = await resolveToken(options.token);
  if (!token) {
    throw new OctokitError(401, 'No GitHub token available. Set GITHUB_TOKEN environment variable or run "gh auth login".');
  }
  const octokit = new Octokit2({
    auth: token,
    ...options.baseUrl !== undefined && { baseUrl: options.baseUrl }
  });
  const graphqlWithAuth = graphql2.defaults({
    headers: {
      authorization: `token ${token}`
    }
  });
  return {
    async createPullRequest(prOptions) {
      try {
        const response = await octokit.rest.pulls.create({
          owner: prOptions.owner,
          repo: prOptions.repo,
          head: prOptions.head,
          base: prOptions.base,
          title: prOptions.title,
          body: prOptions.body,
          ...prOptions.draft !== undefined && { draft: prOptions.draft },
          ...prOptions.maintainerCanModify !== undefined && {
            maintainer_can_modify: prOptions.maintainerCanModify
          }
        });
        const pr = response.data;
        if (prOptions.labels && prOptions.labels.length > 0) {
          await octokit.rest.issues.addLabels({
            owner: prOptions.owner,
            repo: prOptions.repo,
            issue_number: pr.number,
            labels: prOptions.labels
          });
        }
        if (prOptions.reviewers && prOptions.reviewers.length > 0) {
          await octokit.rest.pulls.requestReviewers({
            owner: prOptions.owner,
            repo: prOptions.repo,
            pull_number: pr.number,
            reviewers: prOptions.reviewers
          });
        }
        return {
          number: pr.number,
          url: pr.html_url,
          nodeId: pr.node_id,
          state: pr.state,
          draft: pr.draft ?? false,
          head: pr.head.ref,
          base: pr.base.ref
        };
      } catch (error) {
        handleOctokitError(error);
      }
    },
    async getPullRequest(owner, repo, number) {
      try {
        const response = await octokit.rest.pulls.get({
          owner,
          repo,
          pull_number: number
        });
        const pr = response.data;
        return {
          number: pr.number,
          state: pr.state,
          merged: pr.merged,
          draft: pr.draft ?? false,
          mergeable: pr.mergeable,
          mergeableState: mapMergeableState(pr.mergeable_state),
          reviewDecision: null,
          statusCheckRollup: null,
          comments: pr.comments,
          commits: pr.commits,
          changedFiles: pr.changed_files,
          additions: pr.additions,
          deletions: pr.deletions
        };
      } catch (error) {
        handleOctokitError(error);
      }
    },
    async addLabels(owner, repo, number, labels) {
      try {
        await octokit.rest.issues.addLabels({
          owner,
          repo,
          issue_number: number,
          labels
        });
      } catch (error) {
        handleOctokitError(error);
      }
    },
    async removeLabels(owner, repo, number, labels) {
      try {
        for (const label of labels) {
          await octokit.rest.issues.removeLabel({
            owner,
            repo,
            issue_number: number,
            name: label
          }).catch(() => {});
        }
      } catch (error) {
        handleOctokitError(error);
      }
    },
    async graphql(query, variables) {
      try {
        return await graphqlWithAuth(query, variables);
      } catch (error) {
        handleOctokitError(error);
      }
    },
    async getAuthenticatedUser() {
      try {
        const response = await octokit.rest.users.getAuthenticated();
        return {
          login: response.data.login,
          id: response.data.id
        };
      } catch (error) {
        handleOctokitError(error);
      }
    }
  };
}
function mapMergeableState(state) {
  switch (state) {
    case "clean":
      return "clean";
    case "dirty":
    case "unstable":
      return "dirty";
    case "blocked":
      return "blocked";
    case "behind":
      return "behind";
    default:
      return "unknown";
  }
}
function handleOctokitError(error) {
  if (error && typeof error === "object" && "status" in error) {
    const octokitErr = error;
    throw new OctokitError(octokitErr.status, octokitErr.message ?? "Unknown error", octokitErr.documentation_url);
  }
  if (error instanceof Error) {
    throw new OctokitError(500, error.message);
  }
  throw new OctokitError(500, String(error));
}
async function hasGitHubToken() {
  const token = await resolveToken();
  return token !== null;
}
var init_client = __esm(() => {
  init_dist_bundle3();
  init_dist_src5();
  init_errors6();
  init_exec2();
});

// src/github/pr.ts
function buildPrBody(context) {
  const {
    taskId,
    phaseId,
    complexity,
    costCeiling,
    description,
    files,
    cautionFiles = [],
    successCriteria = []
  } = context;
  const sections = [];
  sections.push("## :robot: KARIMO Automated PR");
  sections.push("");
  sections.push(`**Task:** ${taskId}`);
  sections.push(`**Phase:** ${phaseId}`);
  sections.push(`**Complexity:** ${complexity}/10`);
  sections.push(`**Cost Ceiling:** $${costCeiling}`);
  sections.push("");
  sections.push("### Changes");
  sections.push(description);
  sections.push("");
  sections.push("### Files Affected");
  if (files.length > 0) {
    for (const file of files) {
      sections.push(`- \`${file}\``);
    }
  } else {
    sections.push("_No files affected_");
  }
  sections.push("");
  if (cautionFiles.length > 0) {
    sections.push("### Caution Files :warning:");
    sections.push("The following files require careful review:");
    for (const file of cautionFiles) {
      sections.push(`- \`${file}\``);
    }
    sections.push("");
  }
  if (successCriteria.length > 0) {
    sections.push("### Success Criteria");
    for (const criterion of successCriteria) {
      sections.push(`- [ ] ${criterion}`);
    }
    sections.push("");
  }
  sections.push("### Validation");
  sections.push("- [ ] `bun run build` passes");
  sections.push("- [ ] `bun run typecheck` passes");
  sections.push("- [ ] `bun run lint` passes");
  sections.push("");
  sections.push("---");
  sections.push("*Generated by [KARIMO](https://github.com/opensesh/KARIMO)*");
  return sections.join(`
`);
}
async function createPullRequest(options, client) {
  if (client || await hasGitHubToken()) {
    try {
      const ghClient = client ?? await createGitHubClient();
      return await ghClient.createPullRequest(options);
    } catch (error) {
      console.debug("Octokit PR creation failed, trying gh CLI:", error);
    }
  }
  try {
    const args = [
      "pr",
      "create",
      "--repo",
      `${options.owner}/${options.repo}`,
      "--head",
      options.head,
      "--base",
      options.base,
      "--title",
      options.title,
      "--body",
      options.body
    ];
    if (options.draft) {
      args.push("--draft");
    }
    if (options.labels && options.labels.length > 0) {
      args.push("--label", options.labels.join(","));
    }
    if (options.reviewers && options.reviewers.length > 0) {
      args.push("--reviewer", options.reviewers.join(","));
    }
    const result = await ghExec(args);
    const url = result.stdout.trim();
    const prNumberMatch = url.match(/\/pull\/(\d+)$/);
    const prNumber = prNumberMatch?.[1] ? Number.parseInt(prNumberMatch[1], 10) : 0;
    return {
      number: prNumber,
      url,
      nodeId: "",
      state: "open",
      draft: options.draft ?? false,
      head: options.head,
      base: options.base
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new PrCreateError(options.head, options.base, message);
  }
}
var init_pr = __esm(() => {
  init_client();
  init_errors6();
  init_exec2();
});

// src/github/index.ts
var init_github = __esm(() => {
  init_errors6();
  init_exec2();
  init_cli_auth();
  init_client();
  init_pr();
});

// src/prd/schema.ts
var TaskPrioritySchema, TaskSchema, TasksBlockSchema, PRDStatusSchema, ScopeTypeSchema, PRDMetadataSchema;
var init_schema2 = __esm(() => {
  init_zod();
  TaskPrioritySchema = exports_external.enum(["must", "should", "could"]);
  TaskSchema = exports_external.object({
    id: exports_external.string().min(1, "Task ID is required"),
    title: exports_external.string().min(1, "Task title is required"),
    description: exports_external.string().min(1, "Task description is required"),
    depends_on: exports_external.array(exports_external.string()).default([]),
    complexity: exports_external.number().int().min(1, "Complexity must be at least 1").max(10, "Complexity cannot exceed 10"),
    estimated_iterations: exports_external.number().positive("Estimated iterations must be positive"),
    cost_ceiling: exports_external.number().positive("Cost ceiling must be positive"),
    revision_budget: exports_external.number().nonnegative("Revision budget cannot be negative"),
    priority: TaskPrioritySchema,
    assigned_to: exports_external.string().min(1, "Assigned to is required"),
    success_criteria: exports_external.array(exports_external.string().min(1, "Success criterion cannot be empty")).min(1, "At least one success criterion is required"),
    files_affected: exports_external.array(exports_external.string()).default([]),
    agent_context: exports_external.string().optional()
  });
  TasksBlockSchema = exports_external.object({
    tasks: exports_external.array(TaskSchema).min(1, "At least one task is required")
  });
  PRDStatusSchema = exports_external.enum(["draft", "active", "complete"]);
  ScopeTypeSchema = exports_external.enum(["new-feature", "refactor", "migration", "integration"]);
  PRDMetadataSchema = exports_external.object({
    feature_name: exports_external.string().min(1, "Feature name is required"),
    feature_slug: exports_external.string().min(1, "Feature slug is required"),
    owner: exports_external.string().min(1, "Owner is required"),
    status: PRDStatusSchema,
    created_date: exports_external.string().min(1, "Created date is required"),
    target_date: exports_external.string().optional(),
    phase: exports_external.string().min(1, "Phase is required"),
    scope_type: ScopeTypeSchema,
    github_project: exports_external.string().optional(),
    links: exports_external.array(exports_external.string()).default([]),
    checkpoint_refs: exports_external.array(exports_external.string()).default([])
  });
});

// src/prd/errors.ts
function formatZodIssue2(issue) {
  const path = issue.path.length > 0 ? issue.path.join(".") : "(root)";
  return `  - ${path}: ${issue.message}`;
}
var KarimoPRDError, PRDNotFoundError, PRDReadError, PRDExtractionError, PRDParseError, PRDValidationError, InvalidDependencyError, CyclicDependencyError, DuplicateTaskIdError;
var init_errors7 = __esm(() => {
  KarimoPRDError = class KarimoPRDError extends Error {
    constructor(message) {
      super(message);
      this.name = "KarimoPRDError";
    }
  };
  PRDNotFoundError = class PRDNotFoundError extends KarimoPRDError {
    prdPath;
    constructor(prdPath) {
      super(`PRD file not found.
  Path: ${prdPath}

Ensure the PRD file exists at the specified path.`);
      this.prdPath = prdPath;
      this.name = "PRDNotFoundError";
    }
  };
  PRDReadError = class PRDReadError extends KarimoPRDError {
    prdPath;
    originalError;
    constructor(prdPath, originalError) {
      super(`Failed to read PRD file.
  Path: ${prdPath}
  Reason: ${originalError.message}

Check file permissions and ensure the file is accessible.`);
      this.prdPath = prdPath;
      this.originalError = originalError;
      this.name = "PRDReadError";
    }
  };
  PRDExtractionError = class PRDExtractionError extends KarimoPRDError {
    sourceFile;
    reason;
    constructor(sourceFile, reason) {
      super(`Failed to extract tasks from PRD.
  File: ${sourceFile}
  Reason: ${reason}

Ensure the PRD has a "## Agent Tasks" heading followed by a YAML code block.`);
      this.sourceFile = sourceFile;
      this.reason = reason;
      this.name = "PRDExtractionError";
    }
  };
  PRDParseError = class PRDParseError extends KarimoPRDError {
    sourceFile;
    originalError;
    constructor(sourceFile, originalError) {
      super(`Invalid YAML syntax in PRD file.
  File: ${sourceFile}
  Reason: ${originalError.message}

Fix the YAML syntax errors and try again.`);
      this.sourceFile = sourceFile;
      this.originalError = originalError;
      this.name = "PRDParseError";
    }
  };
  PRDValidationError = class PRDValidationError extends KarimoPRDError {
    sourceFile;
    zodError;
    issues;
    constructor(sourceFile, zodError) {
      const issueList = zodError.issues.map(formatZodIssue2).join(`
`);
      super(`PRD validation failed.
  File: ${sourceFile}
  Issues:
${issueList}

Fix the task definitions and try again.`);
      this.sourceFile = sourceFile;
      this.zodError = zodError;
      this.name = "PRDValidationError";
      this.issues = zodError.issues;
    }
    getFieldPaths() {
      return this.issues.map((issue) => issue.path.join("."));
    }
  };
  InvalidDependencyError = class InvalidDependencyError extends KarimoPRDError {
    taskId;
    missingDep;
    constructor(taskId, missingDep) {
      super(`Invalid task dependency.
  Task: ${taskId}
  Missing dependency: ${missingDep}

Ensure all task IDs in depends_on reference valid tasks.`);
      this.taskId = taskId;
      this.missingDep = missingDep;
      this.name = "InvalidDependencyError";
    }
  };
  CyclicDependencyError = class CyclicDependencyError extends KarimoPRDError {
    cyclePath;
    constructor(cyclePath) {
      const cycleStr = cyclePath.join(" \u2192 ");
      super(`Cyclic dependency detected in task graph.
  Cycle: ${cycleStr}

Remove or restructure dependencies to eliminate the cycle.`);
      this.cyclePath = cyclePath;
      this.name = "CyclicDependencyError";
    }
  };
  DuplicateTaskIdError = class DuplicateTaskIdError extends KarimoPRDError {
    duplicateId;
    constructor(duplicateId) {
      super(`Duplicate task ID found.
  ID: ${duplicateId}

Ensure all task IDs are unique within the PRD.`);
      this.duplicateId = duplicateId;
      this.name = "DuplicateTaskIdError";
    }
  };
});

// src/prd/parser.ts
function normalizeLineEndings(content) {
  return content.replace(/\r\n/g, `
`).replace(/\r/g, `
`);
}
function extractMetadataBlock(content, sourceFile) {
  const lines = content.split(`
`);
  let startIndex = 0;
  while (startIndex < lines.length && lines[startIndex]?.trim() === "") {
    startIndex++;
  }
  const startLine = lines[startIndex];
  if (startLine === undefined) {
    throw new PRDExtractionError(sourceFile, "PRD file is empty");
  }
  if (startLine.startsWith("```yaml")) {
    const closeIndex2 = lines.findIndex((line, i) => i > startIndex && line.trim() === "```");
    if (closeIndex2 === -1) {
      throw new PRDExtractionError(sourceFile, "Unclosed YAML code fence in metadata block");
    }
    const yamlLines = lines.slice(startIndex + 1, closeIndex2);
    const innerStart = yamlLines.findIndex((line) => line.trim() === "---");
    const innerEnd = yamlLines.findLastIndex((line) => line.trim() === "---");
    if (innerStart !== -1 && innerEnd !== -1 && innerStart !== innerEnd) {
      return yamlLines.slice(innerStart + 1, innerEnd).join(`
`);
    }
    return yamlLines.join(`
`);
  }
  if (startLine.trim() !== "---") {
    throw new PRDExtractionError(sourceFile, "PRD must start with YAML metadata block (--- delimiters)");
  }
  const closeIndex = lines.findIndex((line, i) => i > startIndex && line.trim() === "---");
  if (closeIndex === -1) {
    throw new PRDExtractionError(sourceFile, "Unclosed metadata block (missing closing ---)");
  }
  return lines.slice(startIndex + 1, closeIndex).join(`
`);
}
function extractTasksBlock(content, sourceFile) {
  const lines = content.split(`
`);
  const headingPattern = /^#{1,3}\s*agent\s+tasks\s*$/i;
  const headingIndex = lines.findIndex((line) => headingPattern.test(line.trim()));
  if (headingIndex === -1) {
    throw new PRDExtractionError(sourceFile, 'Missing "## Agent Tasks" heading');
  }
  let yamlStart = -1;
  let yamlEnd = -1;
  let inCodeFence = false;
  let fenceIndent = 0;
  for (let i = headingIndex + 1;i < lines.length; i++) {
    const line = lines[i];
    if (line === undefined)
      continue;
    const trimmed = line.trim();
    if (yamlStart === -1 && trimmed === "") {
      continue;
    }
    const fenceMatch = line.match(/^(\s{0,4})```(?:yaml|yml)?/);
    if (fenceMatch && !inCodeFence) {
      inCodeFence = true;
      fenceIndent = fenceMatch[1]?.length ?? 0;
      yamlStart = i + 1;
      continue;
    }
    if (inCodeFence) {
      const closeFenceMatch = line.match(/^(\s{0,4})```\s*$/);
      if (closeFenceMatch && (closeFenceMatch[1]?.length ?? 0) <= fenceIndent) {
        yamlEnd = i;
        break;
      }
    }
    if (!inCodeFence && yamlStart === -1 && trimmed !== "") {
      if (trimmed.startsWith("tasks:") || trimmed.startsWith("-") || trimmed.startsWith("#")) {
        yamlStart = i;
        for (let j3 = i + 1;j3 < lines.length; j3++) {
          const checkLine = lines[j3];
          if (checkLine !== undefined && /^#{1,6}\s/.test(checkLine)) {
            yamlEnd = j3;
            break;
          }
        }
        if (yamlEnd === -1) {
          yamlEnd = lines.length;
        }
        break;
      }
    }
  }
  if (yamlStart === -1) {
    throw new PRDExtractionError(sourceFile, 'No YAML content found after "## Agent Tasks" heading');
  }
  if (inCodeFence && yamlEnd === -1) {
    throw new PRDExtractionError(sourceFile, "Unclosed code fence in Agent Tasks section");
  }
  return lines.slice(yamlStart, yamlEnd).join(`
`);
}
function checkDuplicateIds(tasks) {
  const seen = new Set;
  for (const task of tasks) {
    if (seen.has(task.id)) {
      throw new DuplicateTaskIdError(task.id);
    }
    seen.add(task.id);
  }
}
function toMetadata(data) {
  const result = {
    feature_name: data.feature_name,
    feature_slug: data.feature_slug,
    owner: data.owner,
    status: data.status,
    created_date: data.created_date,
    phase: data.phase,
    scope_type: data.scope_type,
    links: data.links,
    checkpoint_refs: data.checkpoint_refs
  };
  if (data.target_date !== undefined) {
    result.target_date = data.target_date;
  }
  if (data.github_project !== undefined) {
    result.github_project = data.github_project;
  }
  return result;
}
function toTask(data) {
  const result = {
    id: data.id,
    title: data.title,
    description: data.description,
    depends_on: data.depends_on,
    complexity: data.complexity,
    estimated_iterations: data.estimated_iterations,
    cost_ceiling: data.cost_ceiling,
    revision_budget: data.revision_budget,
    priority: data.priority,
    assigned_to: data.assigned_to,
    success_criteria: data.success_criteria,
    files_affected: data.files_affected
  };
  if (data.agent_context !== undefined) {
    result.agent_context = data.agent_context;
  }
  return result;
}
function parsePRD(content, sourceFile) {
  const normalized = normalizeLineEndings(content);
  const metadataYaml = extractMetadataBlock(normalized, sourceFile);
  let rawMetadata;
  try {
    rawMetadata = $parse(metadataYaml);
  } catch (error) {
    throw new PRDParseError(sourceFile, error instanceof Error ? error : new Error(String(error)));
  }
  const metadataResult = PRDMetadataSchema.safeParse(rawMetadata);
  if (!metadataResult.success) {
    throw new PRDValidationError(sourceFile, metadataResult.error);
  }
  const metadata = toMetadata(metadataResult.data);
  const tasksYaml = extractTasksBlock(normalized, sourceFile);
  let rawTasks;
  try {
    rawTasks = $parse(tasksYaml);
  } catch (error) {
    throw new PRDParseError(sourceFile, error instanceof Error ? error : new Error(String(error)));
  }
  const tasksResult = TasksBlockSchema.safeParse(rawTasks);
  if (!tasksResult.success) {
    throw new PRDValidationError(sourceFile, tasksResult.error);
  }
  const tasks = tasksResult.data.tasks.map(toTask);
  checkDuplicateIds(tasks);
  return {
    metadata,
    tasks,
    sourceFile
  };
}
async function parsePRDFile(filePath) {
  const file = Bun.file(filePath);
  if (!await file.exists()) {
    throw new PRDNotFoundError(filePath);
  }
  let content;
  try {
    content = await file.text();
  } catch (error) {
    throw new PRDReadError(filePath, error instanceof Error ? error : new Error(String(error)));
  }
  return parsePRD(content, filePath);
}
var init_parser = __esm(() => {
  init_dist();
  init_errors7();
  init_schema2();
});

// src/prd/dependencies.ts
function buildDependencyGraph(tasks) {
  const graph = new Map;
  for (const task of tasks) {
    graph.set(task.id, {
      taskId: task.id,
      task,
      dependsOn: [...task.depends_on],
      dependedBy: []
    });
  }
  for (const task of tasks) {
    for (const depId of task.depends_on) {
      const depNode = graph.get(depId);
      if (!depNode) {
        throw new InvalidDependencyError(task.id, depId);
      }
      depNode.dependedBy.push(task.id);
    }
  }
  return graph;
}
function findCycle(graph) {
  const visited = new Set;
  const recursionStack = new Set;
  const path = [];
  function dfs(nodeId) {
    visited.add(nodeId);
    recursionStack.add(nodeId);
    path.push(nodeId);
    const node = graph.get(nodeId);
    if (!node)
      return null;
    for (const depId of node.dependsOn) {
      if (!visited.has(depId)) {
        const result = dfs(depId);
        if (result)
          return result;
      } else if (recursionStack.has(depId)) {
        const cycleStart = path.indexOf(depId);
        return [...path.slice(cycleStart), depId];
      }
    }
    path.pop();
    recursionStack.delete(nodeId);
    return null;
  }
  for (const nodeId of graph.keys()) {
    if (!visited.has(nodeId)) {
      const cycle = dfs(nodeId);
      if (cycle)
        return cycle;
    }
  }
  return null;
}
function topologicalSort(graph) {
  if (graph.size === 0)
    return [];
  const inDegree = new Map;
  for (const [id, node] of graph) {
    inDegree.set(id, node.dependsOn.length);
  }
  const queue = [];
  for (const [id, degree] of inDegree) {
    if (degree === 0) {
      queue.push(id);
    }
  }
  const result = [];
  while (queue.length > 0) {
    const nodeId = queue.shift();
    if (nodeId === undefined)
      continue;
    const node = graph.get(nodeId);
    if (node === undefined)
      continue;
    result.push(node.task);
    for (const dependentId of node.dependedBy) {
      const currentDegree = inDegree.get(dependentId) ?? 0;
      const newDegree = currentDegree - 1;
      inDegree.set(dependentId, newDegree);
      if (newDegree === 0) {
        queue.push(dependentId);
      }
    }
  }
  if (result.length !== graph.size) {
    const cycle = findCycle(graph);
    if (cycle) {
      throw new CyclicDependencyError(cycle);
    }
    throw new CyclicDependencyError(["unknown cycle detected"]);
  }
  return result;
}
function getReadyTasks(graph, completedIds) {
  const ready = [];
  for (const [id, node] of graph) {
    if (completedIds.has(id))
      continue;
    const allDepsCompleted = node.dependsOn.every((depId) => completedIds.has(depId));
    if (allDepsCompleted) {
      ready.push(node.task);
    }
  }
  return ready;
}
var init_dependencies = __esm(() => {
  init_errors7();
});

// src/prd/overlaps.ts
class UnionFind {
  parent = new Map;
  rank = new Map;
  find(x2) {
    if (!this.parent.has(x2)) {
      this.parent.set(x2, x2);
      this.rank.set(x2, 0);
    }
    const parentValue = this.parent.get(x2);
    if (parentValue !== undefined && parentValue !== x2) {
      this.parent.set(x2, this.find(parentValue));
    }
    return this.parent.get(x2) ?? x2;
  }
  union(x2, y3) {
    const rootX = this.find(x2);
    const rootY = this.find(y3);
    if (rootX === rootY)
      return;
    const rankX = this.rank.get(rootX) || 0;
    const rankY = this.rank.get(rootY) || 0;
    if (rankX < rankY) {
      this.parent.set(rootX, rootY);
    } else if (rankX > rankY) {
      this.parent.set(rootY, rootX);
    } else {
      this.parent.set(rootY, rootX);
      this.rank.set(rootX, rankX + 1);
    }
  }
  getGroups() {
    const groups = new Map;
    for (const element of this.parent.keys()) {
      const root = this.find(element);
      if (!groups.has(root)) {
        groups.set(root, []);
      }
      groups.get(root)?.push(element);
    }
    return groups;
  }
}
// src/prd/index.ts
var init_prd = __esm(() => {
  init_schema2();
  init_parser();
  init_dependencies();
  init_errors7();
});

// src/orchestrator/summary.ts
function formatDuration(ms) {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  if (hours > 0) {
    const remainingMinutes = minutes % 60;
    return `${hours}h ${remainingMinutes}m`;
  }
  if (minutes > 0) {
    const remainingSeconds = seconds % 60;
    return `${minutes}m ${remainingSeconds}s`;
  }
  return `${seconds}s`;
}
function createTaskSummary(run, title, filesChanged) {
  const duration = run.completedAt && run.startedAt ? formatDuration(run.completedAt.getTime() - run.startedAt.getTime()) : "unknown";
  return {
    taskId: run.taskId,
    phaseId: run.phaseId,
    title,
    status: run.status,
    duration,
    prUrl: run.prUrl,
    filesChanged,
    cautionFiles: run.cautionFilesModified,
    errorMessage: run.errorMessage
  };
}
function formatTaskSummary(summary) {
  const lines = [];
  const statusIcon = getStatusIcon(summary.status);
  lines.push(`${statusIcon} Task ${summary.taskId}: ${summary.title}`);
  lines.push("");
  lines.push(`  Phase:    ${summary.phaseId}`);
  lines.push(`  Status:   ${summary.status}`);
  lines.push(`  Duration: ${summary.duration}`);
  lines.push(`  Files:    ${summary.filesChanged} changed`);
  if (summary.prUrl) {
    lines.push(`  PR:       ${summary.prUrl}`);
  }
  if (summary.cautionFiles.length > 0) {
    lines.push("");
    lines.push("  \u26A0\uFE0F  Caution files modified:");
    for (const file of summary.cautionFiles) {
      lines.push(`      - ${file}`);
    }
  }
  if (summary.errorMessage) {
    lines.push("");
    lines.push(`  \u274C Error: ${summary.errorMessage}`);
  }
  return lines.join(`
`);
}
function printTaskSummary(summary) {
  console.log("");
  console.log("\u2500".repeat(60));
  console.log(formatTaskSummary(summary));
  console.log("\u2500".repeat(60));
  console.log("");
}
function formatDryRunPlan(plan) {
  const lines = [];
  lines.push("\uD83D\uDD0D DRY RUN - No changes will be made");
  lines.push("");
  lines.push("\u2550".repeat(60));
  lines.push("");
  lines.push("Task Details:");
  lines.push(`  ID:         ${plan.task.id}`);
  lines.push(`  Title:      ${plan.task.title}`);
  lines.push(`  Complexity: ${plan.task.complexity}/10`);
  lines.push(`  Cost Cap:   $${plan.task.costCeiling}`);
  lines.push("");
  lines.push("Execution Plan:");
  lines.push(`  PRD Path:      ${plan.prdPath}`);
  lines.push(`  Phase Branch:  ${plan.phaseBranch}`);
  lines.push(`  Task Branch:   ${plan.taskBranch}`);
  lines.push(`  Worktree:      ${plan.worktreePath}`);
  lines.push(`  Engine:        ${plan.engine}`);
  lines.push("");
  lines.push("Validation Commands:");
  lines.push(`  Build:     ${plan.commands.build}`);
  lines.push(`  Typecheck: ${plan.commands.typecheck}`);
  lines.push("");
  lines.push("\u2550".repeat(60));
  return lines.join(`
`);
}
function printDryRunPlan(plan) {
  console.log("");
  console.log(formatDryRunPlan(plan));
  console.log("");
}
function formatRunResult(result) {
  const lines = [];
  if (result.success) {
    lines.push("\u2705 Task completed successfully");
  } else {
    lines.push("\u274C Task failed");
  }
  lines.push("");
  lines.push(formatTaskSummary(result.summary));
  return lines.join(`
`);
}
function getStatusIcon(status) {
  const icons = {
    queued: "\u23F3",
    running: "\uD83D\uDD04",
    review: "\uD83D\uDC40",
    "review-pending": "\u23F8\uFE0F",
    revision: "\uD83D\uDD27",
    done: "\u2705",
    failed: "\u274C",
    aborted: "\uD83D\uDED1",
    "needs-human-rebase": "\u26A0\uFE0F",
    "integration-failure": "\uD83D\uDCA5"
  };
  return icons[status] ?? "\u2753";
}

// src/orchestrator/runner.ts
import { join as join10 } from "path";
async function runTask(options) {
  const {
    phaseId,
    taskId,
    prdPath: prdPathOverride,
    dryRun = false,
    engine = "claude-code"
  } = options;
  const startedAt = new Date;
  const run = {
    taskId,
    phaseId,
    status: "running",
    engine,
    branch: `feature/${phaseId}/${taskId}`,
    startedAt,
    cautionFilesModified: []
  };
  try {
    const { config, rootDir } = await loadConfig();
    const prdPath = prdPathOverride ?? join10(rootDir, ".karimo", "prds", `${phaseId}.md`);
    let parsedPRD;
    try {
      parsedPRD = await parsePRDFile(prdPath);
    } catch {
      throw new PhaseNotFoundError(phaseId, prdPath);
    }
    const task = parsedPRD.tasks.find((t) => t.id === taskId);
    if (!task) {
      throw new TaskNotFoundError(taskId, phaseId);
    }
    const phaseBranch = `feature/${phaseId}`;
    const taskBranch = `feature/${phaseId}/${taskId}`;
    if (dryRun) {
      run.status = "done";
      run.completedAt = new Date;
      return {
        success: true,
        run,
        summary: {
          taskId,
          phaseId,
          title: task.title,
          status: "done",
          duration: "0s (dry run)",
          filesChanged: 0,
          cautionFiles: []
        }
      };
    }
    const defaultBranch = await getDefaultBranch(rootDir);
    if (!await branchExists(phaseBranch, rootDir)) {
      await gitExec(["checkout", "-b", phaseBranch, defaultBranch], { cwd: rootDir });
      await pushBranch(phaseBranch, "origin", { cwd: rootDir });
      await gitExec(["checkout", defaultBranch], { cwd: rootDir });
    }
    try {
      run.worktreePath = await createWorktree(rootDir, phaseId, taskBranch);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      throw new WorktreeError(phaseId, message);
    }
    await createTaskBranch(phaseId, taskId, phaseBranch, { cwd: run.worktreePath });
    const prompt = buildAgentPrompt({
      task,
      config,
      rootDir,
      phaseId
    });
    const agentEnv = buildAgentEnvironment(config);
    const agentEngine = createClaudeCodeEngine();
    if (!await agentEngine.isAvailable()) {
      run.status = "failed";
      run.errorMessage = "Claude Code is not installed";
      run.completedAt = new Date;
      return {
        success: false,
        run,
        summary: createTaskSummary(run, task.title, 0)
      };
    }
    const agentResult = await agentEngine.execute({
      prompt,
      workdir: run.worktreePath,
      env: agentEnv
    });
    if (!agentResult.success) {
      run.status = "failed";
      run.errorMessage = `Agent exited with code ${agentResult.exitCode}`;
      run.completedAt = new Date;
      return {
        success: false,
        run,
        summary: createTaskSummary(run, task.title, 0)
      };
    }
    const checkResult = await prePRChecks({
      worktreePath: run.worktreePath,
      targetBranch: phaseBranch,
      buildCommand: config.commands.build,
      typecheckCommand: config.commands.typecheck,
      neverTouchPatterns: config.boundaries.never_touch,
      requireReviewPatterns: config.boundaries.require_review
    });
    if (!checkResult.success) {
      if (checkResult.rebase && !checkResult.rebase.success && checkResult.rebase.conflictFiles.length > 0) {
        run.status = "needs-human-rebase";
        run.errorMessage = checkResult.errorMessage;
        run.completedAt = new Date;
        throw new RebaseConflictError(checkResult.rebase.conflictFiles, phaseBranch);
      }
      if (checkResult.neverTouchViolations.length > 0) {
        run.status = "failed";
        run.errorMessage = checkResult.errorMessage;
        run.completedAt = new Date;
        throw new NeverTouchViolationError(checkResult.neverTouchViolations);
      }
      const failedCheck = checkResult.build && !checkResult.build.success ? "build" : checkResult.typecheck && !checkResult.typecheck.success ? "typecheck" : "rebase";
      run.status = "failed";
      run.errorMessage = checkResult.errorMessage;
      run.completedAt = new Date;
      throw new PrePRCheckError(failedCheck, checkResult.errorMessage ?? "Unknown error");
    }
    run.cautionFilesModified = checkResult.cautionFiles;
    await pushBranch(taskBranch, "origin", { cwd: run.worktreePath });
    await verifyGhAuth();
    const remoteResult = await gitExec(["remote", "get-url", "origin"], { cwd: rootDir });
    const remoteUrl = remoteResult.stdout.trim();
    const repoMatch = remoteUrl.match(/github\.com[:/]([^/]+)\/(.+?)(?:\.git)?$/);
    if (!repoMatch?.[1] || !repoMatch[2]) {
      throw new PRCreationError(taskId, "Could not parse GitHub repository from remote URL");
    }
    const owner = repoMatch[1];
    const repo = repoMatch[2];
    const prBody = buildPrBody({
      taskId,
      phaseId,
      complexity: task.complexity,
      costCeiling: task.cost_ceiling,
      description: task.description,
      files: checkResult.changedFiles,
      cautionFiles: checkResult.cautionFiles,
      successCriteria: task.success_criteria
    });
    try {
      const pr = await createPullRequest({
        owner,
        repo,
        head: taskBranch,
        base: phaseBranch,
        title: `[${taskId}] ${task.title}`,
        body: prBody,
        draft: false
      });
      run.prNumber = pr.number;
      run.prUrl = pr.url;
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      throw new PRCreationError(taskId, message);
    }
    try {
      await removeWorktree(run.worktreePath, { force: true, repoPath: rootDir });
      run.worktreePath = undefined;
    } catch {}
    run.status = "done";
    run.completedAt = new Date;
    return {
      success: true,
      run,
      summary: createTaskSummary(run, task.title, checkResult.changedFiles.length)
    };
  } catch (error) {
    if (run.status === "running") {
      run.status = "failed";
    }
    run.completedAt = new Date;
    if (!run.errorMessage) {
      run.errorMessage = error instanceof Error ? error.message : String(error);
    }
    if (run.worktreePath) {
      try {
        const { rootDir } = await loadConfig();
        await removeWorktree(run.worktreePath, { force: true, repoPath: rootDir });
      } catch {}
    }
    if (error instanceof TaskNotFoundError || error instanceof PhaseNotFoundError || error instanceof PrePRCheckError || error instanceof NeverTouchViolationError || error instanceof RebaseConflictError || error instanceof PRCreationError || error instanceof WorktreeError) {
      throw error;
    }
    return {
      success: false,
      run,
      summary: createTaskSummary(run, options.taskId, 0)
    };
  }
}
async function createDryRunPlan(options) {
  const { phaseId, taskId, prdPath: prdPathOverride, engine = "claude-code" } = options;
  const { config, rootDir } = await loadConfig();
  const prdPath = prdPathOverride ?? join10(rootDir, ".karimo", "prds", `${phaseId}.md`);
  let parsedPRD;
  try {
    parsedPRD = await parsePRDFile(prdPath);
  } catch {
    throw new PhaseNotFoundError(phaseId, prdPath);
  }
  const task = parsedPRD.tasks.find((t) => t.id === taskId);
  if (!task) {
    throw new TaskNotFoundError(taskId, phaseId);
  }
  return {
    phaseId,
    task: {
      id: task.id,
      title: task.title,
      complexity: task.complexity,
      costCeiling: task.cost_ceiling
    },
    prdPath,
    phaseBranch: `feature/${phaseId}`,
    taskBranch: `feature/${phaseId}/${taskId}`,
    worktreePath: join10(rootDir, "worktrees", phaseId),
    engine,
    commands: {
      build: config.commands.build,
      typecheck: config.commands.typecheck
    }
  };
}
var init_runner = __esm(() => {
  init_agents();
  init_config();
  init_git();
  init_github();
  init_prd();
  init_errors();
  init_pre_pr_checks();
});

// src/orchestrator/index.ts
var init_orchestrator = __esm(() => {
  init_errors();
  init_pre_pr_checks();
  init_runner();
});

// src/cli/orchestrate-command.ts
var exports_orchestrate_command = {};
__export(exports_orchestrate_command, {
  printOrchestrateHelp: () => printOrchestrateHelp,
  parseOrchestrateArgs: () => parseOrchestrateArgs,
  handleOrchestrate: () => handleOrchestrate
});
async function handleOrchestrate(options) {
  const { phase, task, dryRun = false, engine = "claude-code" } = options;
  if (!phase) {
    console.error("Error: --phase is required");
    console.error("");
    console.error("Usage: karimo orchestrate --phase <phase-id> --task <task-id> [--dry-run]");
    return 1;
  }
  if (!task) {
    console.error("Error: --task is required for Level 0");
    console.error("");
    console.error("Usage: karimo orchestrate --phase <phase-id> --task <task-id> [--dry-run]");
    console.error("");
    console.error("Note: Running all ready tasks (--all-ready) will be available in Level 1.");
    return 1;
  }
  try {
    if (dryRun) {
      const plan = await createDryRunPlan({
        phaseId: phase,
        taskId: task,
        engine
      });
      printDryRunPlan(plan);
      return 0;
    }
    console.log(`Starting task ${task} from phase ${phase}...`);
    console.log("");
    const result = await runTask({
      phaseId: phase,
      taskId: task,
      engine
    });
    printTaskSummary(result.summary);
    if (result.success) {
      if (result.run.prUrl) {
        console.log(`PR created: ${result.run.prUrl}`);
      }
      return 0;
    }
    console.error("");
    console.error(formatRunResult(result));
    return 1;
  } catch (error) {
    if (error instanceof PhaseNotFoundError) {
      console.error(`Error: Phase "${error.phaseId}" not found`);
      console.error(`Expected PRD at: ${error.prdPath}`);
      console.error("");
      console.error("Make sure the PRD file exists at the expected location.");
      return 1;
    }
    if (error instanceof TaskNotFoundError) {
      console.error(`Error: Task "${error.taskId}" not found in phase "${error.phaseId}"`);
      console.error("");
      console.error("Check that the task ID matches an entry in the PRD.");
      return 1;
    }
    const message = error instanceof Error ? error.message : String(error);
    console.error(`Error: ${message}`);
    return 1;
  }
}
function parseOrchestrateArgs(args) {
  const options = {};
  for (let i = 0;i < args.length; i++) {
    const arg = args[i];
    const next = args[i + 1];
    switch (arg) {
      case "--phase":
      case "-p":
        if (next !== undefined) {
          options.phase = next;
          i++;
        }
        break;
      case "--task":
      case "-t":
        if (next !== undefined) {
          options.task = next;
          i++;
        }
        break;
      case "--dry-run":
      case "-n":
        options.dryRun = true;
        break;
      case "--engine":
      case "-e":
        if (next !== undefined) {
          options.engine = next;
          i++;
        }
        break;
      case "--prd":
        i++;
        break;
    }
  }
  return options;
}
function printOrchestrateHelp() {
  console.log("Usage: karimo orchestrate [options]");
  console.log("");
  console.log("Run tasks from a PRD using AI agents.");
  console.log("");
  console.log("Options:");
  console.log('  -p, --phase <id>     Phase ID (e.g., "phase-1") [required]');
  console.log('  -t, --task <id>      Task ID (e.g., "1a") [required for Level 0]');
  console.log("  -n, --dry-run        Preview execution plan without running");
  console.log("  -e, --engine <name>  Agent engine to use (default: claude-code)");
  console.log("");
  console.log("Examples:");
  console.log("  karimo orchestrate --phase phase-1 --task 1a");
  console.log("  karimo orchestrate -p phase-1 -t 1a --dry-run");
  console.log("");
}
var init_orchestrate_command = __esm(() => {
  init_orchestrator();
});

// src/doctor/errors.ts
var DoctorError, PrerequisiteError, DoctorCheckFailedError;
var init_errors8 = __esm(() => {
  DoctorError = class DoctorError extends Error {
    constructor(message) {
      super(message);
      this.name = "DoctorError";
    }
  };
  PrerequisiteError = class PrerequisiteError extends DoctorError {
    prerequisite;
    fix;
    constructor(prerequisite, fix) {
      super(`Missing prerequisite: ${prerequisite}`);
      this.prerequisite = prerequisite;
      this.fix = fix;
      this.name = "PrerequisiteError";
    }
  };
  DoctorCheckFailedError = class DoctorCheckFailedError extends DoctorError {
    failedChecks;
    totalChecks;
    constructor(failedChecks, totalChecks) {
      super(`${failedChecks} of ${totalChecks} health checks failed`);
      this.failedChecks = failedChecks;
      this.totalChecks = totalChecks;
      this.name = "DoctorCheckFailedError";
    }
  };
});

// src/doctor/checks/anthropic.ts
async function checkAnthropicApiKey(_projectRoot) {
  const apiKey = process.env["ANTHROPIC_API_KEY"];
  if (apiKey && apiKey.trim().length > 0) {
    const masked = `${apiKey.slice(0, 7)}...${apiKey.slice(-4)}`;
    return {
      name: "anthropic_api_key",
      label: "Anthropic API key",
      status: "pass",
      version: `Set (${masked})`
    };
  }
  return {
    name: "anthropic_api_key",
    label: "Anthropic API key",
    status: "fail",
    message: "Not set",
    fix: `Add to your shell config:

   export ANTHROPIC_API_KEY="sk-ant-..."

   Get a key from: https://console.anthropic.com`
  };
}

// src/doctor/checks/bun.ts
async function checkBun(_projectRoot) {
  try {
    const proc = Bun.spawn(["bun", "--version"], {
      stdout: "pipe",
      stderr: "pipe"
    });
    const exitCode = await proc.exited;
    const stdout = await new Response(proc.stdout).text();
    if (exitCode === 0) {
      const version = stdout.trim();
      return {
        name: "bun",
        label: "Bun runtime",
        status: "pass",
        version: `v${version}`
      };
    }
    return {
      name: "bun",
      label: "Bun runtime",
      status: "fail",
      message: "Bun not responding correctly",
      fix: "curl -fsSL https://bun.sh/install | bash"
    };
  } catch {
    return {
      name: "bun",
      label: "Bun runtime",
      status: "fail",
      message: "Not installed",
      fix: "curl -fsSL https://bun.sh/install | bash"
    };
  }
}

// src/doctor/checks/claude-code.ts
async function checkClaudeCode(_projectRoot) {
  try {
    const proc = Bun.spawn(["claude", "--version"], {
      stdout: "pipe",
      stderr: "pipe"
    });
    const exitCode = await proc.exited;
    const stdout = await new Response(proc.stdout).text();
    if (exitCode === 0) {
      const versionMatch = stdout.match(/(\d+\.\d+\.\d+)/);
      const version = versionMatch ? `v${versionMatch[1]}` : stdout.trim().slice(0, 20);
      return {
        name: "claude_code",
        label: "Claude Code CLI",
        status: "pass",
        version
      };
    }
    return {
      name: "claude_code",
      label: "Claude Code CLI",
      status: "fail",
      message: "CLI not responding correctly",
      fix: "npm install -g @anthropic-ai/claude-code"
    };
  } catch {
    return {
      name: "claude_code",
      label: "Claude Code CLI",
      status: "fail",
      message: "Not installed",
      fix: "npm install -g @anthropic-ai/claude-code"
    };
  }
}

// src/doctor/checks/filesystem.ts
import { existsSync as existsSync8, mkdirSync as mkdirSync2, rmSync, writeFileSync } from "fs";
import { join as join11 } from "path";
async function checkKarimoWritable(projectRoot) {
  const karimoDir = join11(projectRoot, ".karimo");
  const testFile = join11(karimoDir, ".write-test");
  try {
    if (!existsSync8(karimoDir)) {
      mkdirSync2(karimoDir, { recursive: true });
    }
    writeFileSync(testFile, "write test");
    rmSync(testFile);
    return {
      name: "karimo_writable",
      label: ".karimo/ directory",
      status: "pass",
      version: "Writable"
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    return {
      name: "karimo_writable",
      label: ".karimo/ directory",
      status: "fail",
      message: `Not writable: ${message}`,
      fix: `chmod -R u+w ${karimoDir}`
    };
  }
}
var init_filesystem = () => {};

// src/doctor/checks/gh.ts
async function checkGhCli(_projectRoot) {
  try {
    const proc = Bun.spawn(["gh", "--version"], {
      stdout: "pipe",
      stderr: "pipe"
    });
    const exitCode = await proc.exited;
    const stdout = await new Response(proc.stdout).text();
    if (exitCode === 0) {
      const versionMatch = stdout.match(/(\d+\.\d+\.\d+)/);
      const version = versionMatch ? `v${versionMatch[1]}` : "Installed";
      return {
        name: "gh_cli",
        label: "GitHub CLI",
        status: "pass",
        version
      };
    }
    return {
      name: "gh_cli",
      label: "GitHub CLI",
      status: "fail",
      message: "Not responding correctly",
      fix: "brew install gh"
    };
  } catch {
    return {
      name: "gh_cli",
      label: "GitHub CLI",
      status: "fail",
      message: "Not installed",
      fix: "brew install gh"
    };
  }
}
async function checkGhAuth(_projectRoot) {
  try {
    const proc = Bun.spawn(["gh", "auth", "status"], {
      stdout: "pipe",
      stderr: "pipe"
    });
    const exitCode = await proc.exited;
    const stdout = await new Response(proc.stdout).text();
    const stderr = await new Response(proc.stderr).text();
    const output = stdout + stderr;
    if (output.includes("not logged in") || output.includes("gh auth login")) {
      return {
        name: "gh_auth",
        label: "GitHub authentication",
        status: "fail",
        message: "Not authenticated",
        fix: "gh auth login",
        autoFixable: true
      };
    }
    if (exitCode === 0 || output.includes("Logged in")) {
      const accountMatch = output.match(/Logged in to .+ account (\S+)/);
      const username = accountMatch ? `@${accountMatch[1]}` : "Authenticated";
      return {
        name: "gh_auth",
        label: "GitHub authentication",
        status: "pass",
        version: username
      };
    }
    return {
      name: "gh_auth",
      label: "GitHub authentication",
      status: "fail",
      message: "Auth status check failed",
      fix: "gh auth login",
      autoFixable: true
    };
  } catch {
    return {
      name: "gh_auth",
      label: "GitHub authentication",
      status: "fail",
      message: "GitHub CLI not available",
      fix: "Install gh first: brew install gh"
    };
  }
}

// src/doctor/checks/git.ts
import { existsSync as existsSync9 } from "fs";
import { join as join12 } from "path";
async function checkGit(_projectRoot) {
  try {
    const proc = Bun.spawn(["git", "--version"], {
      stdout: "pipe",
      stderr: "pipe"
    });
    const exitCode = await proc.exited;
    const stdout = await new Response(proc.stdout).text();
    if (exitCode === 0) {
      const versionMatch = stdout.match(/(\d+\.\d+\.\d+)/);
      const version = versionMatch ? `v${versionMatch[1]}` : "Installed";
      return {
        name: "git",
        label: "Git",
        status: "pass",
        version
      };
    }
    return {
      name: "git",
      label: "Git",
      status: "fail",
      message: "Git not responding correctly",
      fix: "Install Git: https://git-scm.com/downloads"
    };
  } catch {
    return {
      name: "git",
      label: "Git",
      status: "fail",
      message: "Not installed",
      fix: "Install Git: https://git-scm.com/downloads"
    };
  }
}
async function checkGitRepo(projectRoot) {
  const gitDir = join12(projectRoot, ".git");
  if (existsSync9(gitDir)) {
    try {
      const proc = Bun.spawn(["git", "branch", "--show-current"], {
        cwd: projectRoot,
        stdout: "pipe",
        stderr: "pipe"
      });
      const exitCode = await proc.exited;
      const stdout = await new Response(proc.stdout).text();
      if (exitCode === 0) {
        const branch = stdout.trim() || "detached HEAD";
        return {
          name: "git_repo",
          label: "Git repository",
          status: "pass",
          version: branch
        };
      }
    } catch {}
    return {
      name: "git_repo",
      label: "Git repository",
      status: "pass",
      version: "Detected"
    };
  }
  return {
    name: "git_repo",
    label: "Git repository",
    status: "fail",
    message: "Not a git repository",
    fix: "git init"
  };
}
var init_git2 = () => {};

// src/doctor/checks/index.ts
var init_checks = __esm(() => {
  init_filesystem();
  init_git2();
});

// src/doctor/runner.ts
async function runDoctorChecks(options) {
  const { projectRoot } = options;
  const results = await Promise.all(CHECKS.map((check) => check(projectRoot)));
  const passed = results.filter((r2) => r2.status === "pass").length;
  const failed = results.filter((r2) => r2.status === "fail").length;
  return {
    timestamp: new Date().toISOString(),
    overall: failed === 0 ? "pass" : "fail",
    checks: results,
    passed,
    failed
  };
}
async function runSingleCheck(name, projectRoot) {
  const checkMap = {
    bun: checkBun,
    anthropic_api_key: checkAnthropicApiKey,
    claude_code: checkClaudeCode,
    git: checkGit,
    git_repo: checkGitRepo,
    gh_cli: checkGhCli,
    gh_auth: checkGhAuth,
    karimo_writable: checkKarimoWritable
  };
  const check = checkMap[name];
  if (!check) {
    return null;
  }
  return check(projectRoot);
}
function getAutoFixableChecks(report) {
  return report.checks.filter((c2) => c2.status === "fail" && c2.autoFixable === true);
}
function allCriticalChecksPassed(report) {
  return report.overall === "pass";
}
var CHECKS;
var init_runner2 = __esm(() => {
  init_checks();
  CHECKS = [
    checkBun,
    checkAnthropicApiKey,
    checkClaudeCode,
    checkGit,
    checkGitRepo,
    checkGhCli,
    checkGhAuth,
    checkKarimoWritable
  ];
});

// src/cli/ui/colors.ts
function fg(r2, g2, b3) {
  return `\x1B[38;2;${r2};${g2};${b3}m`;
}
function bold(color) {
  return BOLD + color;
}
function dim(color) {
  return DIM + color;
}
function colorize(text, color) {
  return `${color}${text}${RST}`;
}
function border(width) {
  return `${ORD}${"\u2500".repeat(width)}${RST}`;
}
var RST = "\x1B[0m", BOLD = "\x1B[1m", DIM = "\x1B[2m", OR, ORL, ORD, WH, GY, GYD, GN, RD;
var init_colors = __esm(() => {
  OR = fg(254, 81, 2);
  ORL = fg(255, 140, 70);
  ORD = fg(200, 60, 0);
  WH = fg(220, 220, 220);
  GY = fg(140, 140, 140);
  GYD = fg(90, 90, 90);
  GN = fg(80, 200, 80);
  RD = fg(200, 80, 80);
});

// src/doctor/formatter.ts
function formatCheckLine(result) {
  const indicator = result.status === "pass" ? CHECK : CROSS;
  const label = result.label;
  const dots = DOT.repeat(Math.max(2, LABEL_WIDTH - label.length));
  const paddedLabel = `${label} ${GYD}${dots}${RST}`;
  let info;
  if (result.status === "pass") {
    info = `${GY}${result.version ?? "OK"}${RST}`;
  } else {
    info = `${RD}${result.message ?? "Failed"}${RST}`;
  }
  return `${PAD}\u251C\u2500 ${paddedLabel} ${indicator} ${info}`;
}
function formatDoctorReport(report) {
  const lines = [];
  lines.push(`${PAD}${ORD}\u25C6${RST} ${WH}${BOLD}KARIMO Doctor${RST}`);
  lines.push(`${PAD}${ORD}\u2502${RST}`);
  lines.push(`${PAD}${ORD}\u2502${RST}  Checking your environment...`);
  lines.push(`${PAD}${ORD}\u2502${RST}`);
  for (const check of report.checks) {
    lines.push(formatCheckLine(check));
  }
  lines.push(`${PAD}${ORD}\u2502${RST}`);
  if (report.overall === "pass") {
    lines.push(`${PAD}${ORD}\u2514\u2500${RST} ${GN}All ${report.passed} checks passed.${RST} You're ready to go.`);
  } else {
    const failedChecks = report.checks.filter((c2) => c2.status === "fail");
    if (failedChecks.length > 0) {
      lines.push(`${PAD}${ORD}\u2502${RST}  ${WH}To fix:${RST}`);
      for (const check of failedChecks) {
        if (check.fix) {
          const fixLines = check.fix.split(`
`);
          for (const fixLine of fixLines) {
            lines.push(`${PAD}${ORD}\u2502${RST}    ${GY}${fixLine}${RST}`);
          }
        }
      }
      lines.push(`${PAD}${ORD}\u2502${RST}`);
    }
    lines.push(`${PAD}${ORD}\u2502${RST}  ${GY}${report.passed} passed, ${RD}${report.failed} failed${RST}. Run the commands above to fix.`);
    lines.push(`${PAD}${ORD}\u2502${RST}`);
    lines.push(`${PAD}${ORD}\u2514\u2500${RST} ${GY}Stuck? https://github.com/opensesh/KARIMO/issues${RST}`);
  }
  return lines.join(`
`);
}
function formatDoctorReportJson(report) {
  return JSON.stringify({
    version: "1.0.0",
    timestamp: report.timestamp,
    overall: report.overall,
    checks: report.checks.map((c2) => ({
      name: c2.name,
      status: c2.status,
      ...c2.version && { version: c2.version },
      ...c2.message && { message: c2.message },
      ...c2.fix && { fix: c2.fix }
    }))
  }, null, 2);
}
function formatCompactStatus(report) {
  if (report.overall === "pass") {
    return `${GN}\u2713${RST} All ${report.passed} checks passed`;
  }
  return `${RD}\u2717${RST} ${report.failed} of ${report.passed + report.failed} checks failed`;
}
function formatSetupChecklist(report) {
  const lines = [];
  lines.push(`${PAD}${ORD}\u25C6${RST} ${WH}${BOLD}Setup Checklist${RST}`);
  lines.push(`${PAD}${ORD}\u2502${RST}`);
  lines.push(`${PAD}${ORD}\u2502${RST}  Verifying prerequisites for KARIMO:`);
  lines.push(`${PAD}${ORD}\u2502${RST}  ${GY}CLI tools, API access, and repository state${RST}`);
  lines.push(`${PAD}${ORD}\u2502${RST}`);
  for (const check of report.checks) {
    lines.push(formatCheckLine(check));
  }
  lines.push(`${PAD}${ORD}\u2502${RST}`);
  if (report.overall === "pass") {
    lines.push(`${PAD}${ORD}\u2514${RST}  ${GN}All systems ready.${RST} Let's configure your project.`);
  } else {
    lines.push(`${PAD}${ORD}\u2502${RST}  ${OR}${report.failed} issue${report.failed === 1 ? "" : "s"} need${report.failed === 1 ? "s" : ""} to be resolved${RST} before continuing.`);
    lines.push(`${PAD}${ORD}\u2502${RST}`);
    lines.push(`${PAD}${ORD}\u2514${RST}  ${GY}Stuck? https://github.com/opensesh/KARIMO/issues${RST}`);
  }
  return lines.join(`
`);
}
function formatIssueResolution(check) {
  const lines = [];
  const descriptions = {
    gh_auth: [
      "KARIMO uses GitHub to:",
      "  \u2022 Create pull requests for each task",
      "  \u2022 Track progress via GitHub Projects",
      "  \u2022 Trigger automated code review"
    ],
    anthropic_api_key: ["KARIMO uses Claude to power the interview and agent systems."],
    claude_code: ["KARIMO uses Claude Code to execute tasks."],
    bun: ["KARIMO requires Bun as its runtime."],
    git: ["KARIMO requires Git for version control."],
    git_repo: ["KARIMO needs to run inside a git repository."],
    gh_cli: ["KARIMO uses the GitHub CLI for GitHub operations."],
    karimo_writable: ["KARIMO needs write access to the .karimo/ directory."]
  };
  const titles = {
    gh_auth: "GitHub Authentication Required",
    anthropic_api_key: "Anthropic API Key Required",
    claude_code: "Claude Code CLI Required",
    bun: "Bun Runtime Required",
    git: "Git Required",
    git_repo: "Git Repository Required",
    gh_cli: "GitHub CLI Required",
    karimo_writable: "Directory Permissions Required"
  };
  const title = titles[check.name] ?? `${check.label} Required`;
  const desc = descriptions[check.name] ?? [`${check.label} is required by KARIMO.`];
  lines.push(`${PAD}${ORD}\u25C6${RST} ${WH}${BOLD}${title}${RST}`);
  lines.push(`${PAD}${ORD}\u2502${RST}`);
  for (const line of desc) {
    lines.push(`${PAD}${ORD}\u2502${RST}  ${line}`);
  }
  lines.push(`${PAD}${ORD}\u2502${RST}`);
  if (check.fix) {
    if (check.autoFixable) {
      lines.push(`${PAD}${ORD}\u2502${RST}  Let's get you set up.`);
      lines.push(`${PAD}${ORD}\u2502${RST}`);
      lines.push(`${PAD}${ORD}\u2502${RST}  ${OR}\u2192${RST} Press Enter to run: ${GY}${check.fix}${RST}`);
      lines.push(`${PAD}${ORD}\u2502${RST}  ${GYD}\u2192${RST} Or press Ctrl+C to exit and set up manually`);
    } else {
      lines.push(`${PAD}${ORD}\u2502${RST}  To fix this issue:`);
      lines.push(`${PAD}${ORD}\u2502${RST}`);
      const fixLines = check.fix.split(`
`);
      for (const fixLine of fixLines) {
        lines.push(`${PAD}${ORD}\u2502${RST}    ${GY}${fixLine}${RST}`);
      }
    }
  }
  lines.push(`${PAD}${ORD}\u2502${RST}`);
  lines.push(`${PAD}${ORD}\u2514${RST}  Need help? ${GY}https://github.com/opensesh/KARIMO/issues${RST}`);
  return lines.join(`
`);
}
var PAD = "  ", LABEL_WIDTH = 32, DOT = ".", CHECK, CROSS;
var init_formatter = __esm(() => {
  init_colors();
  CHECK = `${GN}\u2713${RST}`;
  CROSS = `${RD}\u2717${RST}`;
});

// src/doctor/index.ts
var exports_doctor = {};
__export(exports_doctor, {
  runSingleCheck: () => runSingleCheck,
  runDoctorChecks: () => runDoctorChecks,
  getAutoFixableChecks: () => getAutoFixableChecks,
  formatSetupChecklist: () => formatSetupChecklist,
  formatIssueResolution: () => formatIssueResolution,
  formatDoctorReportJson: () => formatDoctorReportJson,
  formatDoctorReport: () => formatDoctorReport,
  formatCompactStatus: () => formatCompactStatus,
  allCriticalChecksPassed: () => allCriticalChecksPassed,
  PrerequisiteError: () => PrerequisiteError,
  DoctorError: () => DoctorError,
  DoctorCheckFailedError: () => DoctorCheckFailedError
});
var init_doctor = __esm(() => {
  init_errors8();
  init_runner2();
  init_formatter();
});

// src/cli/doctor-command.ts
var exports_doctor_command = {};
__export(exports_doctor_command, {
  runDoctorSilent: () => runDoctorSilent,
  parseDoctorArgs: () => parseDoctorArgs,
  handleDoctor: () => handleDoctor
});
function parseDoctorArgs(args) {
  const options = {};
  for (const arg of args) {
    if (arg === "--check") {
      options.check = true;
    }
    if (arg === "--json") {
      options.json = true;
    }
  }
  return options;
}
async function attemptGhAuthFix(projectRoot) {
  console.log();
  const proceed = await ce({
    message: "Run `gh auth login` to authenticate?",
    initialValue: true
  });
  if (lD(proceed) || !proceed) {
    return false;
  }
  console.log();
  v2.info("Opening GitHub authentication flow...");
  console.log();
  try {
    const proc = Bun.spawn(["gh", "auth", "login"], {
      stdin: "inherit",
      stdout: "inherit",
      stderr: "inherit"
    });
    await proc.exited;
    console.log();
    v2.info("Verifying authentication...");
    const result = await runSingleCheck("gh_auth", projectRoot);
    if (result?.status === "pass") {
      v2.success(`Authenticated as ${result.version}`);
      return true;
    }
    v2.error("Authentication check failed. Please try again.");
    return false;
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    v2.error(`Authentication failed: ${message}`);
    return false;
  }
}
async function handleDoctor(options) {
  const { projectRoot, check = false, json = false } = options;
  const report = await runDoctorChecks({ projectRoot });
  if (json) {
    console.log(formatDoctorReportJson(report));
    return report.overall === "pass" ? 0 : 1;
  }
  if (check) {
    console.log(formatDoctorReport(report));
    return report.overall === "pass" ? 0 : 1;
  }
  console.log();
  console.log(formatDoctorReport(report));
  console.log();
  if (report.overall === "pass") {
    return 0;
  }
  const autoFixable = report.checks.filter((c2) => c2.status === "fail" && c2.autoFixable === true);
  for (const check2 of autoFixable) {
    console.log();
    console.log(formatIssueResolution(check2));
    console.log();
    let fixed = false;
    switch (check2.name) {
      case "gh_auth":
        fixed = await attemptGhAuthFix(projectRoot);
        break;
      default:
        break;
    }
    if (fixed) {
      v2.success(`Fixed: ${check2.label}`);
    }
  }
  const finalReport = await runDoctorChecks({ projectRoot });
  if (finalReport.overall === "pass") {
    console.log();
    v2.success("All checks passed!");
    return 0;
  }
  return 1;
}
async function runDoctorSilent(projectRoot) {
  return runDoctorChecks({ projectRoot });
}
var init_doctor_command = __esm(() => {
  init_dist3();
  init_doctor();
});

// src/cli/reset-command.ts
var exports_reset_command = {};
__export(exports_reset_command, {
  printResetHelp: () => printResetHelp,
  parseResetArgs: () => parseResetArgs,
  handleReset: () => handleReset
});
import { existsSync as existsSync10, readdirSync, rmSync as rmSync2, statSync as statSync2 } from "fs";
import { join as join13 } from "path";
function parseResetArgs(args) {
  let hard = false;
  let force = false;
  for (const arg of args) {
    if (arg === "--hard") {
      hard = true;
    } else if (arg === "--force" || arg === "-f") {
      force = true;
    }
  }
  return { hard, force };
}
async function handleReset(options) {
  const { projectRoot, hard = false, force = false } = options;
  const karimoDir = join13(projectRoot, KARIMO_DIR);
  if (!existsSync10(karimoDir)) {
    v2.info("No .karimo directory found. Nothing to reset.");
    return;
  }
  if (!force) {
    const confirmMessage = hard ? "This will delete the entire .karimo directory including config and logs. Continue?" : "This will delete state and PRDs but preserve config.yaml, dogfood.log, and telemetry.log. Continue?";
    const confirmed = await ce({
      message: confirmMessage,
      initialValue: false
    });
    if (lD(confirmed) || !confirmed) {
      v2.info("Reset cancelled.");
      return;
    }
  }
  if (hard) {
    rmSync2(karimoDir, { recursive: true, force: true });
    v2.success("Hard reset complete. Removed .karimo directory.");
  } else {
    const deleted = softReset(karimoDir);
    if (deleted.length > 0) {
      v2.success(`Soft reset complete. Removed: ${deleted.join(", ")}`);
    } else {
      v2.info("Nothing to reset. Only preserved files exist.");
    }
    const preserved = PRESERVED_FILES.filter((f2) => existsSync10(join13(karimoDir, f2)));
    if (preserved.length > 0) {
      v2.info(`Preserved: ${preserved.join(", ")}`);
    }
  }
}
function softReset(karimoDir) {
  const deleted = [];
  const entries = readdirSync(karimoDir);
  for (const entry of entries) {
    if (PRESERVED_FILES.includes(entry)) {
      continue;
    }
    const entryPath = join13(karimoDir, entry);
    const stat = statSync2(entryPath);
    if (stat.isDirectory()) {
      rmSync2(entryPath, { recursive: true, force: true });
      deleted.push(`${entry}/`);
    } else {
      rmSync2(entryPath);
      deleted.push(entry);
    }
  }
  return deleted;
}
function printResetHelp() {
  console.log(`
Usage: karimo reset [options]

Reset KARIMO state in the current project.

Options:
  --hard          Delete entire .karimo directory (including config)
  --force, -f     Skip confirmation prompt

Soft Reset (default):
  Deletes: state.json, prds/, any other generated files
  Preserves: config.yaml, dogfood.log, telemetry.log

Hard Reset (--hard):
  Deletes the entire .karimo directory. You will need to run
  \`karimo init\` again to reconfigure the project.

Examples:
  karimo reset              # Soft reset with confirmation
  karimo reset --force      # Soft reset without confirmation
  karimo reset --hard       # Hard reset with confirmation
  karimo reset --hard -f    # Hard reset without confirmation
`);
}
var KARIMO_DIR = ".karimo", PRESERVED_FILES;
var init_reset_command = __esm(() => {
  init_dist3();
  PRESERVED_FILES = ["config.yaml", "dogfood.log", "telemetry.log"];
});

// src/cli/note-command.ts
var exports_note_command = {};
__export(exports_note_command, {
  printNoteHelp: () => printNoteHelp,
  parseNoteArgs: () => parseNoteArgs,
  handleNote: () => handleNote
});
import { appendFileSync, existsSync as existsSync11, mkdirSync as mkdirSync3 } from "fs";
import { join as join14 } from "path";
function parseNoteArgs(args) {
  let tag = "NOTE";
  const messageTokens = [];
  let i = 0;
  while (i < args.length) {
    const arg = args[i];
    if (arg === "--tag" || arg === "-t") {
      const tagValue = args[i + 1];
      if (tagValue !== undefined) {
        const upperTag = tagValue.toUpperCase();
        if (isValidTag(upperTag)) {
          tag = upperTag;
          i += 2;
          continue;
        }
        messageTokens.push(arg);
        i++;
        continue;
      }
    } else if (arg?.startsWith("--tag=")) {
      const tagValue = arg.slice(6).toUpperCase();
      if (isValidTag(tagValue)) {
        tag = tagValue;
        i++;
        continue;
      }
    } else if (arg?.startsWith("-t=")) {
      const tagValue = arg.slice(3).toUpperCase();
      if (isValidTag(tagValue)) {
        tag = tagValue;
        i++;
        continue;
      }
    } else if (arg !== undefined) {
      messageTokens.push(arg);
    }
    i++;
  }
  const message = messageTokens.join(" ").trim();
  if (!message) {
    return null;
  }
  return { tag, message };
}
function isValidTag(value) {
  return VALID_TAGS.includes(value);
}
async function handleNote(options) {
  const { projectRoot, tag, message } = options;
  const karimoDir = join14(projectRoot, KARIMO_DIR2);
  if (!existsSync11(karimoDir)) {
    mkdirSync3(karimoDir, { recursive: true });
  }
  const timestamp = new Date().toISOString();
  const logEntry = `[${timestamp}] [${tag}] ${message}
`;
  const logPath = join14(karimoDir, DOGFOOD_FILE);
  appendFileSync(logPath, logEntry, "utf-8");
  v2.success(`Note captured: [${tag}]`);
}
function printNoteHelp() {
  console.log(`
Usage: karimo note [options] <message>

Capture dogfooding notes for later analysis.

Options:
  --tag, -t <TAG>   Tag the note (default: NOTE)

Supported tags:
  NOTE      General observation (default)
  BUG       Something broken
  UX        User experience issue
  FRICTION  Something that slowed you down
  IDEA      Feature idea or improvement

Examples:
  karimo note "The init flow was smooth"
  karimo note --tag BUG "Config validation missed a required field"
  karimo note -t FRICTION "Had to restart after timeout"

Notes are saved to: .karimo/dogfood.log
`);
}
var VALID_TAGS, DOGFOOD_FILE = "dogfood.log", KARIMO_DIR2 = ".karimo";
var init_note_command = __esm(() => {
  init_dist3();
  VALID_TAGS = ["NOTE", "BUG", "UX", "FRICTION", "IDEA"];
});

// src/cli/ui/welcome-screen.ts
function showHeader() {
  console.log();
  console.log(`${PAD2}${border(BORDER_WIDTH)}`);
  console.log(WORDMARK);
  console.log(`${PAD2}${WH}${BOLD}Welcome to KARIMO.${RST}`);
  console.log();
  console.log(`${PAD2}${GY}You are the architect. Agents are the builders.${RST}`);
  console.log(`${PAD2}${GYD}Product requirements \u2192 shipped code.${RST}`);
  console.log();
  console.log(`${PAD2}${border(BORDER_WIDTH)}`);
  console.log();
}
function showIntroduction() {
  console.log(`${PAD2}KARIMO turns your ideas into working software.`);
  console.log();
  console.log(`${PAD2}You describe what you want to build. AI agents write the code.`);
  console.log(`${PAD2}Automated review keeps quality high. You stay in control.`);
  console.log();
  console.log(`${PAD2}Here's how it works:`);
  console.log();
  console.log(`${PAD2}  ${OR}1. Define${RST}   You describe features in plain language`);
  console.log(`${PAD2}  ${OR}2. Build${RST}    AI agents implement your requirements`);
  console.log(`${PAD2}  ${OR}3. Review${RST}   Automated checks ensure code quality`);
  console.log();
}
async function showWelcomeScreen() {
  showHeader();
  showIntroduction();
  const proceed = await ce({
    message: "Press Enter to continue...",
    active: "Continue",
    inactive: "Cancel",
    initialValue: true
  });
  if (lD(proceed) || !proceed) {
    ge("Come back when you are ready.");
    return false;
  }
  console.log();
  return true;
}
function showCompactHeader() {
  console.log();
  console.log(`${PAD2}${border(BORDER_WIDTH)}`);
  console.log();
  console.log(`${PAD2}${OR}${BOLD}KARIMO${RST} ${GY}Autonomous Development Framework${RST}`);
  console.log();
  console.log(`${PAD2}${border(BORDER_WIDTH)}`);
  console.log();
}
async function showTransitionToInit() {
  console.log(`${PAD2}${ORD}\u25C6${RST} ${WH}${BOLD}Ready to configure KARIMO${RST}`);
  console.log(`${PAD2}${ORD}\u2502${RST}`);
  console.log(`${PAD2}${ORD}\u2502${RST}  Your environment is set up. Now let's configure this project.`);
  console.log(`${PAD2}${ORD}\u2502${RST}`);
  console.log(`${PAD2}${ORD}\u2502${RST}  KARIMO will scan your codebase to detect:`);
  console.log(`${PAD2}${ORD}\u2502${RST}    \u2022 Project name and tech stack`);
  console.log(`${PAD2}${ORD}\u2502${RST}    \u2022 Build, lint, and test commands`);
  console.log(`${PAD2}${ORD}\u2502${RST}    \u2022 Code quality rules`);
  console.log(`${PAD2}${ORD}\u2502${RST}    \u2022 Files that need extra review`);
  console.log(`${PAD2}${ORD}\u2502${RST}`);
  console.log(`${PAD2}${ORD}\u2502${RST}  This creates ${GY}.karimo/config.yaml${RST} \u2014 you can edit it anytime.`);
  console.log(`${PAD2}${ORD}\u2502${RST}`);
  console.log(`${PAD2}${ORD}\u2514${RST}`);
  console.log();
  const proceed = await ce({
    message: "Start project setup?",
    initialValue: true
  });
  if (lD(proceed) || !proceed) {
    ge("Run `karimo` again when you are ready.");
    return false;
  }
  return true;
}
var BORDER_WIDTH = 60, PAD2 = "  ", WORDMARK;
var init_welcome_screen = __esm(() => {
  init_dist3();
  init_colors();
  WORDMARK = `
${PAD2}${OR}${BOLD}\u2588\u2588\u2557  \u2588\u2588\u2557   \u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2557  \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2588\u2588\u2588\u2557${RST}
${PAD2}${OR}${BOLD}\u2588\u2588\u2551 \u2588\u2588\u2554\u255D  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557  \u2588\u2588\u2551  \u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551  \u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557${RST}
${PAD2}${OR}${BOLD}\u2588\u2588\u2588\u2588\u2588\u2554\u255D   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D  \u2588\u2588\u2551  \u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551${RST}
${PAD2}${OR}${BOLD}\u2588\u2588\u2554\u2550\u2588\u2588\u2557   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557  \u2588\u2588\u2551  \u2588\u2588\u2551\u255A\u2588\u2588\u2554\u255D\u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551${RST}
${PAD2}${OR}${BOLD}\u2588\u2588\u2551  \u2588\u2588\u2557  \u2588\u2588\u2551  \u2588\u2588\u2551  \u2588\u2588\u2551  \u2588\u2588\u2551  \u2588\u2588\u2551  \u2588\u2588\u2551 \u255A\u2550\u255D \u2588\u2588\u2551  \u255A\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D${RST}
${PAD2}${OR}${BOLD}\u255A\u2550\u255D  \u255A\u2550\u255D  \u255A\u2550\u255D  \u255A\u2550\u255D  \u255A\u2550\u255D  \u255A\u2550\u255D  \u255A\u2550\u255D  \u255A\u2550\u255D     \u255A\u2550\u255D   \u255A\u2550\u2550\u2550\u2550\u2550\u255D${RST}
`;
});

// src/cli/ui/animations/timing.ts
function getCurrentPhase(elapsedMs) {
  if (elapsedMs < PHASE_TIMING.wordmark.end) {
    return "wordmark";
  }
  if (elapsedMs < PHASE_TIMING.sections.end) {
    return "sections";
  }
  if (elapsedMs < TOTAL_ANIMATION_MS) {
    return "ready";
  }
  return "complete";
}
function isSectionVisible(sectionKey, elapsedMs) {
  const timing = SECTION_TIMING[sectionKey];
  return elapsedMs >= timing.start;
}
function createAnimationLoop(callback, onComplete) {
  let startTime = null;
  let lastFrameTime = 0;
  let animationHandle = null;
  let stopped = false;
  const tick = () => {
    if (stopped)
      return;
    const now = Date.now();
    if (startTime === null) {
      startTime = now;
      lastFrameTime = now;
    }
    const elapsed = now - startTime;
    const delta = now - lastFrameTime;
    lastFrameTime = now;
    callback(elapsed, delta);
    if (elapsed >= TOTAL_ANIMATION_MS) {
      if (onComplete) {
        onComplete();
      }
      return;
    }
    animationHandle = setTimeout(tick, FRAME_MS);
  };
  animationHandle = setTimeout(tick, 0);
  return {
    stop: () => {
      stopped = true;
      if (animationHandle !== null) {
        clearTimeout(animationHandle);
        animationHandle = null;
      }
    }
  };
}
function calculatePulseIntensity(elapsedMs) {
  const cycle = elapsedMs % PULSE_CYCLE_MS / PULSE_CYCLE_MS;
  const sine = Math.sin(cycle * Math.PI * 2);
  return 0.65 + sine * 0.35;
}
var TARGET_FPS = 30, FRAME_MS, TOTAL_ANIMATION_MS = 2400, PHASE_TIMING, SECTION_TIMING, PULSE_CYCLE_MS = 1500;
var init_timing = __esm(() => {
  FRAME_MS = Math.floor(1000 / TARGET_FPS);
  PHASE_TIMING = {
    wordmark: { start: 0, end: 600 },
    sections: { start: 600, end: 2000 },
    ready: { start: 2000, end: TOTAL_ANIMATION_MS }
  };
  SECTION_TIMING = {
    orchestration: { start: 600, duration: 300 },
    levels: { start: 900, duration: 300 },
    gettingStarted: { start: 1200, duration: 300 },
    ready: { start: 1800, duration: 200 }
  };
});

// src/cli/ui/animations/effects.ts
function lerpColor(from, to, t) {
  const clampedT = Math.max(0, Math.min(1, t));
  return {
    r: Math.round(from.r + (to.r - from.r) * clampedT),
    g: Math.round(from.g + (to.g - from.g) * clampedT),
    b: Math.round(from.b + (to.b - from.b) * clampedT)
  };
}
function rgbToAnsi(color) {
  return `\x1B[38;2;${color.r};${color.g};${color.b}m`;
}
function pulseColor(intensity, baseColor = COLOR_ORANGE_DARK, highlightColor = COLOR_ORANGE_LIGHT) {
  const color = lerpColor(baseColor, highlightColor, intensity);
  return rgbToAnsi(color);
}
var COLOR_ORANGE_LIGHT, COLOR_ORANGE_DARK, ANSI_PATTERN;
var init_effects = __esm(() => {
  init_colors();
  COLOR_ORANGE_LIGHT = { r: 255, g: 140, b: 70 };
  COLOR_ORANGE_DARK = { r: 200, g: 60, b: 0 };
  ANSI_PATTERN = new RegExp(`${String.fromCharCode(27)}\\[[0-9;]*m`, "g");
});

// src/cli/ui/animations/index.ts
var init_animations = __esm(() => {
  init_timing();
  init_effects();
});

// src/cli/ui/terminal-utils.ts
function hideCursor() {
  process.stdout.write(`${CSI}?25l`);
}
function showCursor() {
  process.stdout.write(`${CSI}?25h`);
}
function moveCursorHome() {
  process.stdout.write(`${CSI}H`);
}
function moveCursorUp(n) {
  if (n > 0) {
    process.stdout.write(`${CSI}${n}A`);
  }
}
function clearScreen() {
  process.stdout.write(`${CSI}2J`);
  moveCursorHome();
}
function clearLine2() {
  process.stdout.write(`${CSI}2K`);
}
function getTerminalSize() {
  return {
    columns: process.stdout.columns || 80,
    rows: process.stdout.rows || 24
  };
}
function isTerminalLargeEnough() {
  const { columns, rows } = getTerminalSize();
  return columns >= 80 && rows >= 30;
}
function isTTY() {
  return process.stdout.isTTY === true;
}
function isCI() {
  return process.env["CI"] === "true" || process.env["CI"] === "1" || process.env["CONTINUOUS_INTEGRATION"] === "true" || process.env["GITHUB_ACTIONS"] === "true" || process.env["JENKINS_URL"] !== undefined || process.env["TRAVIS"] === "true" || process.env["CIRCLECI"] === "true" || process.env["GITLAB_CI"] === "true";
}
function canRunAnimation() {
  if (isCI()) {
    return false;
  }
  if (!isTTY()) {
    return false;
  }
  if (!isTerminalLargeEnough()) {
    return false;
  }
  return true;
}
function enableRawMode() {
  if (process.stdin.isTTY) {
    process.stdin.setRawMode(true);
    process.stdin.resume();
    process.stdin.setEncoding("utf8");
  }
  return () => {
    if (process.stdin.isTTY) {
      process.stdin.setRawMode(false);
      process.stdin.pause();
    }
  };
}
function write(content) {
  process.stdout.write(content);
}
var ESC = "\x1B", CSI;
var init_terminal_utils = __esm(() => {
  CSI = `${ESC}[`;
});

// src/cli/ui/welcome-content.ts
function getWordmarkLines() {
  return WORDMARK_LINES.map((line) => `   ${OR}${BOLD}${line}${RST}`);
}
function getHeaderLines() {
  const frameworkName = "OS Autonomous Development Framework";
  const tagline = "Choose your model, select your codebase";
  const lineWidth = 74;
  const leftPad = 3;
  const spacing = lineWidth - leftPad - frameworkName.length - VERSION9.length;
  return [
    "",
    `   ${OR}${frameworkName}${RST}${" ".repeat(spacing)}${GYD}${VERSION9}${RST}`,
    `   ${GY}${tagline}${RST}`,
    ""
  ];
}
function getDivider() {
  return ` ${ORD}${"\u2500".repeat(77)}${RST}`;
}
function flowBox(top, bottom) {
  const innerWidth = Math.max(10, top.length + 2, bottom.length + 2);
  const width = innerWidth;
  const topPad = Math.floor((innerWidth - top.length) / 2);
  const topPadEnd = innerWidth - top.length - topPad;
  const bottomPad = Math.floor((innerWidth - bottom.length) / 2);
  const bottomPadEnd = innerWidth - bottom.length - bottomPad;
  return [
    `${OR}${BOX.tl}${BOX.h.repeat(width)}${BOX.tr}${RST}`,
    `${OR}${BOX.v}${RST}${" ".repeat(topPad)}${WH}${top}${RST}${" ".repeat(topPadEnd)}${OR}${BOX.v}${RST}`,
    `${OR}${BOX.v}${RST}${" ".repeat(bottomPad)}${GY}${bottom}${RST}${" ".repeat(bottomPadEnd)}${OR}${BOX.v}${RST}`,
    `${OR}${BOX.bl}${BOX.h.repeat(width)}${BOX.br}${RST}`
  ];
}
function getOrchestrationFlowLines() {
  const boxes = [
    flowBox("PRD", "Interview"),
    flowBox("Tasks", "(generated)"),
    flowBox("Execute", "(agents)"),
    flowBox("Review", "(checks)"),
    flowBox("Merge", "(PR)")
  ];
  const flowLines = ["", "", "", ""];
  for (let row = 0;row < 4; row++) {
    for (let box = 0;box < boxes.length; box++) {
      const currentBox = boxes[box];
      const currentRow = currentBox?.[row];
      if (currentBox && currentRow !== undefined) {
        flowLines[row] += currentRow;
        if (box < boxes.length - 1) {
          if (row === 1 || row === 2) {
            flowLines[row] += ` ${GYD}${BOX.arrow}${RST} `;
          } else {
            flowLines[row] += "   ";
          }
        }
      }
    }
  }
  return [
    "",
    `   ${WH}${BOLD}Orchestration Flow${RST}`,
    `   ${GY}Turn product requirements into shipped code using agents,${RST}`,
    `   ${GY}automated code review, and human oversight.${RST}`,
    "",
    `   ${flowLines[0]}`,
    `   ${flowLines[1]}`,
    `   ${flowLines[2]}`,
    `   ${flowLines[3]}`,
    ""
  ];
}
function formatLevelRow(level) {
  const code = `${GYD}${level.code}${RST}`;
  const name = `${WH}${level.name.padEnd(12)}${RST}`;
  const desc = `${GY}${level.description}${RST}`;
  return `   ${code} ${name}${desc}`;
}
function getLevelPlanLines() {
  const levelRows = LEVELS.map(formatLevelRow);
  return [
    "",
    `   ${WH}${BOLD}Level-Based Build Plan${RST}`,
    `   ${GY}Each level is a validation loop for trust and code integrity.${RST}`,
    `   ${GY}Complete one before starting the next.${RST}`,
    "",
    ...levelRows,
    ""
  ];
}
function getGettingStartedLines() {
  return [
    "",
    `   ${WH}${BOLD}Getting Started${RST}`,
    `   ${GY}We'll create a config for your codebase, ensure safe usage of${RST}`,
    `   ${GY}Model API keys, and kick off your first feature PRD.${RST}`,
    "",
    `   ${GY}Learn more at${RST} ${OR}>>${RST} ${WH}${GITHUB_URL}${RST}`,
    ""
  ];
}
function getReadyPromptLine(bulletColor = OR) {
  return `   ${bulletColor}\u25CF${RST} ${WH}Ready to get started${RST} ${GY}\u2014 Press Enter to continue${RST}`;
}
function getCompleteWelcomeLines() {
  return [
    "",
    ...getWordmarkLines(),
    ...getHeaderLines(),
    getDivider(),
    ...getOrchestrationFlowLines(),
    getDivider(),
    ...getLevelPlanLines(),
    getDivider(),
    ...getGettingStartedLines(),
    getDivider(),
    "",
    getReadyPromptLine(),
    ""
  ];
}
var VERSION9 = "v0.1.0", GITHUB_URL = "https://github.com/opensesh/KARIMO", WORDMARK_LINES, BOX, LEVELS;
var init_welcome_content = __esm(() => {
  init_colors();
  WORDMARK_LINES = [
    "\u2588\u2588\u2557  \u2588\u2588\u2557   \u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2557  \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2588\u2588\u2588\u2557",
    "\u2588\u2588\u2551 \u2588\u2588\u2554\u255D  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557  \u2588\u2588\u2551  \u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551  \u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557",
    "\u2588\u2588\u2588\u2588\u2588\u2554\u255D   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D  \u2588\u2588\u2551  \u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551",
    "\u2588\u2588\u2554\u2550\u2588\u2588\u2557   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557  \u2588\u2588\u2551  \u2588\u2588\u2551\u255A\u2588\u2588\u2554\u255D\u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551",
    "\u2588\u2588\u2551  \u2588\u2588\u2557  \u2588\u2588\u2551  \u2588\u2588\u2551  \u2588\u2588\u2551  \u2588\u2588\u2551  \u2588\u2588\u2551  \u2588\u2588\u2551 \u255A\u2550\u255D \u2588\u2588\u2551  \u255A\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D",
    "\u255A\u2550\u255D  \u255A\u2550\u255D  \u255A\u2550\u255D  \u255A\u2550\u255D  \u255A\u2550\u255D  \u255A\u2550\u255D  \u255A\u2550\u255D  \u255A\u2550\u255D     \u255A\u2550\u255D   \u255A\u2550\u2550\u2550\u2550\u2550\u255D"
  ];
  BOX = {
    tl: "\u250C",
    tr: "\u2510",
    bl: "\u2514",
    br: "\u2518",
    h: "\u2500",
    v: "\u2502",
    arrow: "\u2192"
  };
  LEVELS = [
    { code: "L0", name: "Foundation", description: "One agent \u2192 one PR \u2192 manual review" },
    { code: "L1", name: "State", description: "GitHub Projects integration, task tracking" },
    { code: "L2", name: "Review", description: "Greptile automated review, revision loops" },
    { code: "L3", name: "Orchestrate", description: "Full sequential execution, overnight runs" },
    { code: "L4", name: "Scale", description: "Parallel execution, fallback engines" },
    { code: "L5", name: "Dashboard", description: "Visual command center, one-click merge" }
  ];
});

// src/cli/ui/animated-welcome.ts
function createInitialState() {
  return {
    phase: "wordmark",
    elapsedMs: 0,
    skipped: false,
    keyPressed: false,
    pressedKey: null
  };
}
function buildFrame(state) {
  const lines = [""];
  if (state.elapsedMs > 0 || state.skipped) {
    lines.push(...getWordmarkLines());
  }
  if (state.elapsedMs >= 300 || state.skipped) {
    lines.push(...getHeaderLines());
  }
  if (state.elapsedMs >= 500 || state.skipped) {
    lines.push(getDivider());
  }
  if (isSectionVisible("orchestration", state.elapsedMs) || state.skipped) {
    lines.push(...getOrchestrationFlowLines());
  }
  if (isSectionVisible("orchestration", state.elapsedMs) || state.skipped) {
    lines.push(getDivider());
  }
  if (isSectionVisible("levels", state.elapsedMs) || state.skipped) {
    lines.push(...getLevelPlanLines());
  }
  if (isSectionVisible("levels", state.elapsedMs) || state.skipped) {
    lines.push(getDivider());
  }
  if (isSectionVisible("gettingStarted", state.elapsedMs) || state.skipped) {
    lines.push(...getGettingStartedLines());
  }
  if (isSectionVisible("gettingStarted", state.elapsedMs) || state.skipped) {
    lines.push(getDivider());
  }
  if (isSectionVisible("ready", state.elapsedMs) || state.skipped) {
    const pulseIntensity = calculatePulseIntensity(state.elapsedMs);
    const bulletColor = pulseColor(pulseIntensity);
    lines.push("");
    lines.push(getReadyPromptLine(bulletColor));
    lines.push("");
  }
  return lines;
}
function renderFrame(lines) {
  moveCursorHome();
  process.stdout.write(lines.join(`
`));
  const { rows } = getTerminalSize();
  const remaining = rows - lines.length;
  if (remaining > 0) {
    process.stdout.write(`
`.repeat(remaining));
  }
}
function setupKeypressListener(onKey) {
  if (!process.stdin.isTTY) {
    return () => {};
  }
  const cleanup = enableRawMode();
  const handler2 = (key) => {
    if (key === "\x03") {
      onKey("ctrl+c");
      return;
    }
    if (key === "\r" || key === `
`) {
      onKey("enter");
      return;
    }
    onKey(key);
  };
  process.stdin.on("data", handler2);
  return () => {
    process.stdin.removeListener("data", handler2);
    cleanup();
  };
}
async function showAnimatedWelcome() {
  if (!canRunAnimation()) {
    return showStaticWelcome();
  }
  return new Promise((resolve2) => {
    const state = createInitialState();
    let cleanupKeypress = null;
    let animationLoop = null;
    const cleanup = () => {
      if (animationLoop) {
        animationLoop.stop();
        animationLoop = null;
      }
      if (cleanupKeypress) {
        cleanupKeypress();
        cleanupKeypress = null;
      }
      showCursor();
    };
    const handleKeypress = (key) => {
      state.keyPressed = true;
      state.pressedKey = key;
      if (key === "ctrl+c") {
        cleanup();
        clearScreen();
        ge("Come back when you are ready.");
        resolve2(false);
        return;
      }
      if (!state.skipped && state.elapsedMs < TOTAL_ANIMATION_MS) {
        state.skipped = true;
        state.elapsedMs = TOTAL_ANIMATION_MS + 1;
        const frame = buildFrame(state);
        renderFrame(frame);
        return;
      }
      if (key === "enter") {
        cleanup();
        clearScreen();
        resolve2(true);
        return;
      }
    };
    cleanupKeypress = setupKeypressListener(handleKeypress);
    clearScreen();
    hideCursor();
    animationLoop = createAnimationLoop((elapsed) => {
      if (state.skipped)
        return;
      state.elapsedMs = elapsed;
      state.phase = getCurrentPhase(elapsed);
      const frame = buildFrame(state);
      renderFrame(frame);
    }, () => {
      if (!state.skipped) {
        state.skipped = true;
      }
    });
    const signalHandler = () => {
      cleanup();
      process.exit(0);
    };
    process.on("SIGINT", signalHandler);
    process.on("SIGTERM", signalHandler);
  });
}
async function showStaticWelcome() {
  const lines = getCompleteWelcomeLines();
  console.log(lines.join(`
`));
  const proceed = await ce({
    message: "Press Enter to continue...",
    active: "Continue",
    inactive: "Cancel",
    initialValue: true
  });
  if (lD(proceed) || !proceed) {
    ge("Come back when you are ready.");
    return false;
  }
  return true;
}
async function showSimpleAnimatedWelcome() {
  if (!canRunAnimation()) {
    return showStaticWelcome();
  }
  clearScreen();
  hideCursor();
  try {
    console.log("");
    for (const line of getWordmarkLines()) {
      console.log(line);
      await sleep(60);
    }
    for (const line of getHeaderLines()) {
      console.log(line);
    }
    await sleep(100);
    console.log(getDivider());
    await sleep(50);
    for (const line of getOrchestrationFlowLines()) {
      console.log(line);
    }
    await sleep(150);
    console.log(getDivider());
    await sleep(50);
    for (const line of getLevelPlanLines()) {
      console.log(line);
    }
    await sleep(150);
    console.log(getDivider());
    await sleep(50);
    for (const line of getGettingStartedLines()) {
      console.log(line);
    }
    await sleep(100);
    console.log(getDivider());
    await sleep(50);
    console.log("");
    console.log(getReadyPromptLine());
    console.log("");
  } finally {
    showCursor();
  }
  const proceed = await ce({
    message: `${OR}\u25CF${RST} ${WH}Continue?${RST}`,
    active: "Yes, let's go",
    inactive: "Exit",
    initialValue: true
  });
  if (lD(proceed) || !proceed) {
    ge(`${GY}Come back when you're ready.${RST}`);
    return false;
  }
  console.log();
  return true;
}
function sleep(ms) {
  return new Promise((resolve2) => setTimeout(resolve2, ms));
}
var init_animated_welcome = __esm(() => {
  init_dist3();
  init_animations();
  init_colors();
  init_terminal_utils();
  init_welcome_content();
});

// src/cli/ui/compact-banner.ts
function supportsUnicodeBlocks() {
  const lang = process.env["LANG"] ?? "";
  const lcAll = process.env["LC_ALL"] ?? "";
  const hasUtf8 = lang.toLowerCase().includes("utf") || lcAll.toLowerCase().includes("utf");
  const term = process.env["TERM"] ?? "";
  const termProgram = process.env["TERM_PROGRAM"] ?? "";
  const knownGood = term.includes("xterm") || term.includes("256color") || term.includes("kitty") || term.includes("alacritty") || termProgram.includes("iTerm") || termProgram.includes("Apple_Terminal") || termProgram.includes("vscode");
  return hasUtf8 || knownGood;
}
function getCompactWordmarkLines() {
  const lines = supportsUnicodeBlocks() ? COMPACT_WORDMARK_LINES : ASCII_FALLBACK_LINES;
  return lines;
}
function getColoredCompactWordmark() {
  const lines = getCompactWordmarkLines();
  return lines.map((line) => `${OR}${BOLD}${line}${RST}`);
}
function renderCompactBanner() {
  if (!isTTY()) {
    return;
  }
  const lines = getColoredCompactWordmark();
  console.log();
  for (const line of lines) {
    console.log(line);
  }
}
function getCompactBannerString() {
  const lines = getColoredCompactWordmark();
  return ["", ...lines].join(`
`);
}
var COMPACT_WORDMARK_LINES, ASCII_FALLBACK_LINES;
var init_compact_banner = __esm(() => {
  init_colors();
  init_terminal_utils();
  COMPACT_WORDMARK_LINES = [
    "\u2588\u2584\u2580 \u2584\u2580\u2584 \u2588\u2580\u2584 \u2588 \u2588\u2584 \u2584\u2588 \u2588\u2580\u2588",
    "\u2588 \u2588 \u2588\u2580\u2588 \u2588\u2580\u2584 \u2588 \u2588 \u2580 \u2588 \u2588 \u2588",
    "\u2580 \u2580 \u2580 \u2580 \u2580 \u2580 \u2580 \u2580   \u2580 \u2580\u2580\u2580"
  ];
  ASCII_FALLBACK_LINES = [
    "K   A   R   I   M   O",
    "|  /|\\  |_) |  |\\/|  |_|",
    "| / | \\ | \\ | |  |   |_|"
  ];
});

// src/cli/ui/session-info.ts
import { homedir } from "os";
function formatModelInfo(modelPreference) {
  if (!modelPreference) {
    return "Not configured";
  }
  const info = MODEL_DISPLAY[modelPreference];
  if (!info) {
    return modelPreference;
  }
  return `${info.name} via ${info.provider}`;
}
function collapsePath(path) {
  const home = homedir();
  if (path.startsWith(home)) {
    return `~${path.slice(home.length)}`;
  }
  return path;
}
function getSessionInfoLines(context) {
  const modelInfo = formatModelInfo(context.modelPreference);
  const displayPath = collapsePath(context.cwd);
  return [
    "",
    `${GYD}${VERSION9}${RST}  ${GYD}\u2502${RST}  ${WH}${modelInfo}${RST}`,
    `${GY}${displayPath}${RST}`,
    ""
  ];
}
function renderSessionInfo(context) {
  if (!isTTY()) {
    return;
  }
  const lines = getSessionInfoLines(context);
  for (const line of lines) {
    console.log(line);
  }
}
function getSessionInfoString(context) {
  return getSessionInfoLines(context).join(`
`);
}
async function buildSessionContext(projectRoot) {
  let modelPreference = null;
  try {
    const { loadConfig: loadConfig2 } = await Promise.resolve().then(() => (init_config(), exports_config));
    const result = await loadConfig2(projectRoot);
    modelPreference = result.config.cost.model_preference;
  } catch {
    modelPreference = null;
  }
  return {
    modelPreference,
    cwd: projectRoot
  };
}
var MODEL_DISPLAY;
var init_session_info = __esm(() => {
  init_colors();
  init_terminal_utils();
  init_welcome_content();
  MODEL_DISPLAY = {
    haiku: { name: "Haiku", provider: "Anthropic" },
    sonnet: { name: "Sonnet", provider: "Anthropic" },
    opus: { name: "Opus", provider: "Anthropic" }
  };
});

// src/cli/ui/long-input.ts
import { tmpdir } from "os";
import { join as join15 } from "path";
function getEditor() {
  return process.env["EDITOR"] || process.env["VISUAL"] || DEFAULT_EDITOR;
}
async function isEditorAvailable(editor) {
  const editorCmd = editor ?? getEditor();
  const whichCmd = process.platform === "win32" ? "where" : "which";
  const proc = Bun.spawn([whichCmd, editorCmd.split(" ")[0] ?? editorCmd], {
    stdout: "pipe",
    stderr: "pipe"
  });
  const exitCode = await proc.exited;
  return exitCode === 0;
}
function shouldUseEditor(input, threshold = LONG_INPUT_THRESHOLD) {
  if (input.trim().toLowerCase() === EDIT_COMMAND) {
    return true;
  }
  return input.length > threshold;
}
function isEditCommand(input) {
  return input.trim().toLowerCase() === EDIT_COMMAND;
}
async function createTempFile(content = "") {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 8);
  const filename = `${TEMP_FILE_PREFIX}${timestamp}-${random}.md`;
  const filepath = join15(tmpdir(), filename);
  await Bun.write(filepath, content);
  return filepath;
}
async function readAndCleanupTempFile(filepath) {
  const file = Bun.file(filepath);
  const content = await file.text();
  try {
    const fs = await import("fs/promises");
    await fs.unlink(filepath);
  } catch {}
  return content;
}
async function openEditor(options = {}) {
  const { initialContent = "", editor } = options;
  const editorCmd = editor ?? getEditor();
  const tempPath = await createTempFile(initialContent);
  try {
    const [cmd, ...args] = editorCmd.split(" ");
    if (!cmd) {
      throw new Error("Invalid editor command");
    }
    const proc = Bun.spawn([cmd, ...args, tempPath], {
      stdin: "inherit",
      stdout: "inherit",
      stderr: "inherit"
    });
    const exitCode = await proc.exited;
    if (exitCode !== 0) {}
    const text = await readAndCleanupTempFile(tempPath);
    const trimmed = text.trim();
    if (trimmed === "" && initialContent.trim() === "") {
      return {
        text: "",
        usedEditor: true,
        cancelled: true
      };
    }
    return {
      text: trimmed,
      usedEditor: true,
      cancelled: false
    };
  } catch (error) {
    try {
      const fs = await import("fs/promises");
      await fs.unlink(tempPath);
    } catch {}
    throw error;
  }
}
async function getLongInput(prompt) {
  const editor = getEditor();
  const available = await isEditorAvailable(editor);
  if (!available) {
    console.warn(`Editor '${editor}' not available. Using direct input.`);
    return "";
  }
  const result = await openEditor({
    prompt,
    initialContent: `# ${prompt}

`
  });
  if (result.cancelled) {
    return "";
  }
  let text = result.text;
  const promptLine = `# ${prompt}`;
  if (text.startsWith(promptLine)) {
    text = text.slice(promptLine.length).trim();
  }
  return text;
}
function formatInputPreview(input, maxLines = 5) {
  const lines = input.split(`
`);
  if (lines.length <= maxLines) {
    return input;
  }
  const preview = lines.slice(0, maxLines).join(`
`);
  const remaining = lines.length - maxLines;
  return `${preview}
... (${remaining} more lines)`;
}
function getInputStats(input) {
  const lines = input.split(`
`);
  const words = input.split(/\s+/).filter((w2) => w2.length > 0);
  return {
    chars: input.length,
    words: words.length,
    lines: lines.length,
    visualWidth: Math.max(...lines.map((l2) => getVisualWidth(l2)))
  };
}
var LONG_INPUT_THRESHOLD = 500, EDIT_COMMAND = "/edit", DEFAULT_EDITOR = "nano", TEMP_FILE_PREFIX = "karimo-input-";
var init_long_input = __esm(() => {
  init_text_format();
});

// src/cli/ui/collapsible-response.ts
function countVisualLines(text, width) {
  const lines = text.split(`
`);
  let totalLines = 0;
  for (const line of lines) {
    if (line.length === 0) {
      totalLines += 1;
      continue;
    }
    const visualWidth = getVisualWidth(line);
    const linesNeeded = Math.ceil(visualWidth / width) || 1;
    totalLines += linesNeeded;
  }
  return totalLines;
}
function getFirstLines(text, n) {
  return text.split(`
`).slice(0, n);
}
function createSeparator(width) {
  return "\u2500".repeat(width);
}
function renderCollapsedView(state, previewLines, margin) {
  const effectiveWidth = getEffectiveWidth(margin);
  const marginPad = " ".repeat(margin);
  const lines = [];
  const preview = getFirstLines(state.fullContent, previewLines);
  for (const line of preview) {
    const wrapped = wrapTextWithMargin(line, margin);
    const wrappedLines = wrapped.split(`
`);
    for (const wl of wrappedLines) {
      lines.push(`${DIM}${wl}${RST}`);
    }
  }
  lines.push(`${marginPad}${GYD}${createSeparator(effectiveWidth)}${RST}`);
  const remainingLines = state.lineCount - previewLines;
  const hint = `ctrl+o to expand (${remainingLines} more line${remainingLines !== 1 ? "s" : ""})`;
  lines.push(`${marginPad}${GYD}${hint}${RST}`);
  return lines;
}
function renderExpandedView(state, margin) {
  const effectiveWidth = getEffectiveWidth(margin);
  const marginPad = " ".repeat(margin);
  const lines = [];
  const wrapped = wrapTextWithMargin(state.fullContent, margin);
  const wrappedLines = wrapped.split(`
`);
  for (const wl of wrappedLines) {
    lines.push(`${DIM}${wl}${RST}`);
  }
  lines.push(`${marginPad}${GYD}${createSeparator(effectiveWidth)}${RST}`);
  lines.push(`${marginPad}${GYD}ctrl+o to collapse${RST}`);
  return lines;
}
function renderShortText(text, margin) {
  const wrapped = wrapTextWithMargin(text, margin);
  const wrappedLines = wrapped.split(`
`);
  return wrappedLines.map((line) => `${DIM}${line}${RST}`);
}
function createCollapsibleRenderer(options = {}) {
  const {
    previewLines = DEFAULT_PREVIEW_LINES,
    collapseThreshold = DEFAULT_COLLAPSE_THRESHOLD,
    margin = DEFAULT_MARGIN2
  } = options;
  let sections = [];
  let nextId = 1;
  function estimateClackOutputLines(text) {
    const effectiveWidth = getEffectiveWidth(margin);
    const lines = text.split(`
`);
    let total = 0;
    for (const line of lines) {
      if (line.length === 0) {
        total += 1;
        continue;
      }
      const visualWidth = getVisualWidth(line);
      total += Math.ceil(visualWidth / effectiveWidth) || 1;
    }
    return total + 1;
  }
  function clearLines(count) {
    for (let i = 0;i < count; i++) {
      moveCursorUp(1);
      clearLine2();
    }
  }
  function writeLines(lines) {
    for (const line of lines) {
      write(`${line}
`);
    }
  }
  function collapseAll() {
    for (const section of sections) {
      if (section.isExpanded && section.lineCount > collapseThreshold) {
        clearLines(section.renderedLines);
        const lines = renderCollapsedView(section, previewLines, margin);
        writeLines(lines);
        section.isExpanded = false;
        section.renderedLines = lines.length;
      }
    }
  }
  function extractContent(input) {
    if (typeof input === "string") {
      return { original: input, display: input };
    }
    return { original: input.original, display: input.display };
  }
  function render(input) {
    const { original, display } = extractContent(input);
    if (!isTTY()) {
      renderNonTTY(original);
      return;
    }
    collapseAll();
    const effectiveWidth = getEffectiveWidth(margin);
    const lineCount = countVisualLines(original, effectiveWidth);
    const clackLines = estimateClackOutputLines(original);
    clearLines(clackLines);
    const state = {
      id: nextId++,
      fullContent: original,
      isExpanded: false,
      lineCount,
      previewLineCount: previewLines,
      renderedLines: 0
    };
    let outputLines;
    if (lineCount <= collapseThreshold) {
      outputLines = renderShortText(display, margin);
      state.isExpanded = true;
    } else {
      outputLines = renderCollapsedView(state, previewLines, margin);
    }
    writeLines(outputLines);
    state.renderedLines = outputLines.length;
    sections.push(state);
  }
  function renderNonTTY(input) {
    const effectiveWidth = getEffectiveWidth(margin);
    const lineCount = countVisualLines(input, effectiveWidth);
    if (lineCount <= collapseThreshold) {
      const lines = renderShortText(input, margin);
      writeLines(lines);
    } else {
      const marginPad = " ".repeat(margin);
      const fullWrapped = wrapTextWithMargin(input, margin);
      for (const line of fullWrapped.split(`
`)) {
        write(`${DIM}${line}${RST}
`);
      }
      const remainingLines = lineCount - previewLines;
      write(`${marginPad}${GYD}[... ${remainingLines} more lines in scrollback]${RST}
`);
    }
  }
  function toggleLast() {
    if (!isTTY()) {
      return;
    }
    const last = sections[sections.length - 1];
    if (!last) {
      return;
    }
    if (last.lineCount <= collapseThreshold) {
      return;
    }
    clearLines(last.renderedLines);
    last.isExpanded = !last.isExpanded;
    let outputLines;
    if (last.isExpanded) {
      outputLines = renderExpandedView(last, margin);
    } else {
      outputLines = renderCollapsedView(last, previewLines, margin);
    }
    writeLines(outputLines);
    last.renderedLines = outputLines.length;
  }
  function getLastState() {
    return sections[sections.length - 1] ?? null;
  }
  function cleanup() {
    sections = [];
    nextId = 1;
  }
  return {
    render,
    toggleLast,
    collapseAll,
    getLastState,
    cleanup
  };
}
var DEFAULT_PREVIEW_LINES = 3, DEFAULT_COLLAPSE_THRESHOLD = 5, DEFAULT_MARGIN2 = 2;
var init_collapsible_response = __esm(() => {
  init_colors();
  init_terminal_utils();
  init_text_format();
});

// src/cli/ui/keypress-manager.ts
function createKeypressManager() {
  const state = {
    active: false,
    paused: false,
    handlers: [],
    dataListener: null,
    exitListener: null
  };
  function parseKey(data) {
    if (data === CTRL_O) {
      return "ctrl+o";
    }
    if (data === CTRL_C) {
      return "ctrl+c";
    }
    return null;
  }
  function activate(handlers) {
    if (!isTTY() || !process.stdin.isTTY) {
      return;
    }
    if (state.active) {
      state.handlers = handlers;
      state.paused = false;
      return;
    }
    state.handlers = handlers;
    state.active = true;
    state.paused = false;
    state.dataListener = (data) => {
      if (state.paused) {
        return;
      }
      const key = parseKey(data);
      if (!key) {
        return;
      }
      if (key === "ctrl+c") {
        deactivate();
        process.exit(130);
        return;
      }
      const handler2 = state.handlers.find((h2) => h2.key === key);
      if (handler2) {
        handler2.callback();
      }
    };
    state.exitListener = () => {
      deactivate();
    };
    process.stdin.setRawMode(true);
    process.stdin.resume();
    process.stdin.setEncoding("utf8");
    process.stdin.on("data", state.dataListener);
    process.on("exit", state.exitListener);
    process.on("SIGINT", state.exitListener);
  }
  function deactivate() {
    if (!state.active) {
      return;
    }
    if (state.dataListener) {
      process.stdin.removeListener("data", state.dataListener);
      state.dataListener = null;
    }
    if (state.exitListener) {
      process.removeListener("exit", state.exitListener);
      process.removeListener("SIGINT", state.exitListener);
      state.exitListener = null;
    }
    if (process.stdin.isTTY) {
      try {
        process.stdin.setRawMode(false);
        process.stdin.pause();
      } catch {}
    }
    state.active = false;
    state.paused = false;
    state.handlers = [];
  }
  function pause() {
    state.paused = true;
  }
  function resume() {
    state.paused = false;
  }
  function isActive() {
    return state.active;
  }
  function isPaused() {
    return state.paused;
  }
  return {
    activate,
    deactivate,
    pause,
    resume,
    isActive,
    isPaused
  };
}
var CTRL_O = "\x0F", CTRL_C = "\x03";
var init_keypress_manager = __esm(() => {
  init_terminal_utils();
});

// src/cli/ui/input-sanitizer.ts
function sanitizeForDisplay(input) {
  let result = input;
  result = result.replace(/\r\n/g, `
`).replace(/\r/g, `
`);
  result = result.replace(/\n{3,}/g, `

`);
  result = result.split(`
`).map((line) => line.trim()).join(`
`);
  result = escapeListMarkers(result);
  return result.trim();
}
function escapeListMarkers(input) {
  return input.split(`
`).map((line) => {
    const numberedMatch = line.match(/^(\d+)\.\s/);
    if (numberedMatch) {
      return line.replace(/^(\d+)\.\s/, "$1) ");
    }
    if (/^[\u2022\u25E6\u25AA\u25B8\u25BA]\s/.test(line)) {
      return line.replace(/^[\u2022\u25E6\u25AA\u25B8\u25BA]\s/, "- ");
    }
    return line;
  }).join(`
`);
}
function createFlattenedPreview(input, maxLength = 100) {
  const sanitized = sanitizeForDisplay(input);
  const lines = sanitized.split(`
`).filter((line) => line.trim()).slice(0, MAX_DISPLAY_LINES);
  if (lines.length === 0) {
    return "";
  }
  if (lines.length === 1) {
    const line = lines[0] ?? "";
    if (line.length <= maxLength) {
      return line;
    }
    return `${line.slice(0, maxLength - 3)}...`;
  }
  const joined = lines.join(LINE_SEPARATOR);
  if (joined.length <= maxLength) {
    return joined;
  }
  return `${joined.slice(0, maxLength - 3)}...`;
}
function processUserInput(raw) {
  return {
    original: raw,
    display: sanitizeForDisplay(raw)
  };
}
function hasComplexFormatting(input) {
  if (/^\d+\.\s/m.test(input)) {
    return true;
  }
  if (/^[-*\u2022\u25E6\u25AA\u25B8\u25BA]\s/m.test(input)) {
    return true;
  }
  if (/\n{3,}/.test(input)) {
    return true;
  }
  const lineCount = input.split(`
`).filter((line) => line.trim()).length;
  if (lineCount > 5) {
    return true;
  }
  return false;
}
var LINE_SEPARATOR = " \u2502 ", MAX_DISPLAY_LINES = 5;

// src/cli/ui/response-formatter.ts
function isQuestionLine(line, prevLineWasQuestion = false) {
  const trimmed = line.trim();
  if (!trimmed) {
    return false;
  }
  if (trimmed.endsWith("?")) {
    return true;
  }
  const lowerLine = trimmed.toLowerCase();
  for (const starter of QUESTION_STARTERS) {
    if (lowerLine.startsWith(`${starter} `) || lowerLine.startsWith(`${starter},`)) {
      return true;
    }
  }
  if (prevLineWasQuestion && /^[-*\u2022\u25E6\u25AA\u25B8\u25BA]\s/.test(trimmed)) {
    return true;
  }
  if (prevLineWasQuestion && /^\d+[.)]\s/.test(trimmed)) {
    return true;
  }
  return false;
}
function findQuestionBlocks(text) {
  const lines = text.split(`
`);
  const blocks = [];
  let inBlock = false;
  let blockStart = 0;
  let prevWasQuestion = false;
  for (let i = 0;i < lines.length; i++) {
    const line = lines[i] ?? "";
    const isQuestion = isQuestionLine(line, prevWasQuestion);
    if (isQuestion) {
      if (!inBlock) {
        inBlock = true;
        blockStart = i;
      }
      prevWasQuestion = true;
    } else {
      if (inBlock) {
        blocks.push([blockStart, i - 1]);
        inBlock = false;
      }
      prevWasQuestion = false;
    }
  }
  if (inBlock) {
    blocks.push([blockStart, lines.length - 1]);
  }
  return blocks;
}
function convertMarkdownBold(text) {
  return text.replace(BOLD_MARKDOWN_REGEX, `${BOLD}$1${RST}`);
}
function formatAgentResponse(response, options = {}) {
  const { highlightQuestions = true, convertBold = true } = options;
  let result = response;
  if (convertBold) {
    result = convertMarkdownBold(result);
  }
  if (highlightQuestions) {
    result = highlightQuestionBlocks(result);
  }
  return result;
}
function highlightQuestionBlocks(text) {
  const lines = text.split(`
`);
  const blocks = findQuestionBlocks(text);
  if (blocks.length === 0) {
    return text;
  }
  const questionLines = new Set;
  for (const [start, end] of blocks) {
    for (let i = start;i <= end; i++) {
      questionLines.add(i);
    }
  }
  const outputLines = [];
  for (let i = 0;i < lines.length; i++) {
    const line = lines[i] ?? "";
    if (questionLines.has(i) && line.trim()) {
      outputLines.push(`${GN}${line}${RST}`);
    } else {
      outputLines.push(line);
    }
  }
  return outputLines.join(`
`);
}
function hasQuestions(response) {
  const blocks = findQuestionBlocks(response);
  return blocks.length > 0;
}
function countQuestions(response) {
  return findQuestionBlocks(response).length;
}
var QUESTION_STARTERS, BOLD_MARKDOWN_REGEX;
var init_response_formatter = __esm(() => {
  init_colors();
  QUESTION_STARTERS = [
    "what",
    "how",
    "why",
    "when",
    "where",
    "who",
    "which",
    "can",
    "could",
    "would",
    "should",
    "do",
    "does",
    "is",
    "are",
    "will",
    "have",
    "has",
    "did",
    "was",
    "were"
  ];
  BOLD_MARKDOWN_REGEX = /\*\*([^*]+)\*\*/g;
});

// src/cli/ui/index.ts
var exports_ui = {};
__export(exports_ui, {
  wrapTextWithMargin: () => wrapTextWithMargin,
  wrapText: () => wrapText,
  truncateText: () => truncateText,
  truncatePattern: () => truncatePattern,
  supportsUnicodeBlocks: () => supportsUnicodeBlocks,
  showWelcomeScreen: () => showWelcomeScreen,
  showTransitionToInit: () => showTransitionToInit,
  showSimpleAnimatedWelcome: () => showSimpleAnimatedWelcome,
  showCursor: () => showCursor,
  showCompactHeader: () => showCompactHeader,
  showAnimatedWelcome: () => showAnimatedWelcome,
  shouldUseEditor: () => shouldUseEditor,
  sanitizeForDisplay: () => sanitizeForDisplay,
  renderSessionInfo: () => renderSessionInfo,
  renderCompactBanner: () => renderCompactBanner,
  processUserInput: () => processUserInput,
  openEditor: () => openEditor,
  isTTY: () => isTTY,
  isQuestionLine: () => isQuestionLine,
  isEditorAvailable: () => isEditorAvailable,
  isEditCommand: () => isEditCommand,
  hideCursor: () => hideCursor,
  hasQuestions: () => hasQuestions,
  hasComplexFormatting: () => hasComplexFormatting,
  getVisualWidth: () => getVisualWidth,
  getTerminalWidth: () => getTerminalWidth,
  getSessionInfoString: () => getSessionInfoString,
  getSessionInfoLines: () => getSessionInfoLines,
  getLongInput: () => getLongInput,
  getInputStats: () => getInputStats,
  getEffectiveWidth: () => getEffectiveWidth,
  getEditor: () => getEditor,
  getCompleteWelcomeLines: () => getCompleteWelcomeLines,
  getCompactWordmarkLines: () => getCompactWordmarkLines,
  getCompactBannerString: () => getCompactBannerString,
  getColoredCompactWordmark: () => getColoredCompactWordmark,
  formatModelInfo: () => formatModelInfo,
  formatInputPreview: () => formatInputPreview,
  formatBoundaryList: () => formatBoundaryList,
  formatBoundariesDisplay: () => formatBoundariesDisplay,
  formatAgentResponse: () => formatAgentResponse,
  findQuestionBlocks: () => findQuestionBlocks,
  dim: () => dim,
  createStreamRenderer: () => createStreamRenderer,
  createKeypressManager: () => createKeypressManager,
  createFlattenedPreview: () => createFlattenedPreview,
  createDivider: () => createDivider,
  createCollapsibleRenderer: () => createCollapsibleRenderer,
  countQuestions: () => countQuestions,
  convertMarkdownBold: () => convertMarkdownBold,
  colorize: () => colorize,
  collapsePath: () => collapsePath,
  clearScreen: () => clearScreen,
  centerText: () => centerText,
  canRunAnimation: () => canRunAnimation,
  buildSessionContext: () => buildSessionContext,
  border: () => border,
  bold: () => bold,
  WH: () => WH,
  VERSION: () => VERSION9,
  RST: () => RST,
  RD: () => RD,
  ORL: () => ORL,
  ORD: () => ORD,
  OR: () => OR,
  GYD: () => GYD,
  GY: () => GY,
  GN: () => GN,
  GITHUB_URL: () => GITHUB_URL,
  DIM: () => DIM,
  COMPACT_WORDMARK_LINES: () => COMPACT_WORDMARK_LINES,
  BORDER_WIDTH: () => BORDER_WIDTH,
  BOLD: () => BOLD
});
var init_ui = __esm(() => {
  init_colors();
  init_welcome_screen();
  init_animated_welcome();
  init_compact_banner();
  init_session_info();
  init_terminal_utils();
  init_welcome_content();
  init_text_format();
  init_long_input();
  init_collapsible_response();
  init_keypress_manager();
  init_boundaries_display();
  init_response_formatter();
});

// src/cli/first-run.ts
var exports_first_run = {};
__export(exports_first_run, {
  runFirstRunFlow: () => runFirstRunFlow,
  isFirstRun: () => isFirstRun
});
async function attemptGhAuthFix2(projectRoot) {
  console.log();
  const proceed = await ce({
    message: "Press Enter to open the GitHub login flow...",
    active: "Continue",
    inactive: "Skip",
    initialValue: true
  });
  if (lD(proceed) || !proceed) {
    return false;
  }
  console.log();
  v2.info("Opening GitHub authentication...");
  console.log();
  try {
    const proc = Bun.spawn(["gh", "auth", "login"], {
      stdin: "inherit",
      stdout: "inherit",
      stderr: "inherit"
    });
    await proc.exited;
    console.log();
    v2.info("Verifying authentication...");
    const result = await runSingleCheck("gh_auth", projectRoot);
    if (result?.status === "pass") {
      v2.success(`Authenticated as ${result.version}`);
      return true;
    }
    v2.error("Authentication check failed. Please try again.");
    return false;
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    v2.error(`Authentication failed: ${message}`);
    return false;
  }
}
async function resolveIssue(check, projectRoot) {
  console.log();
  console.log(formatIssueResolution(check));
  console.log();
  if (check.autoFixable) {
    switch (check.name) {
      case "gh_auth":
        return attemptGhAuthFix2(projectRoot);
      default:
        break;
    }
  }
  const retry = await ce({
    message: "Have you completed the fix? Press Enter to re-check.",
    active: "Re-check",
    inactive: "Exit",
    initialValue: true
  });
  if (lD(retry) || !retry) {
    return false;
  }
  const result = await runSingleCheck(check.name, projectRoot);
  if (result?.status === "pass") {
    v2.success(`Fixed: ${check.label}`);
    return true;
  }
  v2.error(`Still failing: ${check.label}`);
  return false;
}
async function runFirstRunFlow(projectRoot) {
  const continueAfterWelcome = await showSimpleAnimatedWelcome();
  if (!continueAfterWelcome) {
    return false;
  }
  let report = await runDoctorChecks({ projectRoot });
  console.log();
  console.log(formatSetupChecklist(report));
  console.log();
  if (report.overall === "fail") {
    const failedChecks = report.checks.filter((c2) => c2.status === "fail");
    for (const check of failedChecks) {
      const resolved = await resolveIssue(check, projectRoot);
      if (!resolved) {
        console.log();
        ge("Run `karimo` again when the issues are resolved.");
        return false;
      }
    }
    report = await runDoctorChecks({ projectRoot });
    if (report.overall === "fail") {
      console.log();
      console.log(formatSetupChecklist(report));
      console.log();
      ge("Some issues remain. Run `karimo doctor` to see details.");
      return false;
    }
  }
  console.log();
  const proceedToInit = await showTransitionToInit();
  if (!proceedToInit) {
    return false;
  }
  return true;
}
async function isFirstRun(projectRoot) {
  const { existsSync: existsSync12 } = await import("fs");
  const { join: join16 } = await import("path");
  const karimoDir = join16(projectRoot, ".karimo");
  return !existsSync12(karimoDir);
}
var init_first_run = __esm(() => {
  init_dist3();
  init_doctor();
  init_ui();
});

// src/cli/safety/signals.ts
var PROJECT_SIGNALS, MIN_SIGNAL_WEIGHT = 2;
var init_signals = __esm(() => {
  PROJECT_SIGNALS = [
    { file: "package.json", weight: 3 },
    { file: "Cargo.toml", weight: 3 },
    { file: "pyproject.toml", weight: 3 },
    { file: "go.mod", weight: 3 },
    { file: "pom.xml", weight: 3 },
    { file: "build.gradle", weight: 3 },
    { file: "Gemfile", weight: 3 },
    { file: "composer.json", weight: 3 },
    { file: ".git", weight: 2 },
    { file: "Makefile", weight: 2 },
    { file: "CMakeLists.txt", weight: 2 },
    { file: "README.md", weight: 1 },
    { file: "LICENSE", weight: 1 }
  ];
});

// src/cli/safety/index.ts
var exports_safety = {};
__export(exports_safety, {
  formatSafetyError: () => formatSafetyError,
  checkWorkingDirectory: () => checkWorkingDirectory,
  PROJECT_SIGNALS: () => PROJECT_SIGNALS,
  MIN_SIGNAL_WEIGHT: () => MIN_SIGNAL_WEIGHT
});
import { existsSync as existsSync12, readFileSync as readFileSync5 } from "fs";
import { homedir as homedir2 } from "os";
import { join as join16, resolve as resolve2 } from "path";
function isKarimoRepo(projectRoot) {
  const packageJsonPath = join16(projectRoot, "package.json");
  if (!existsSync12(packageJsonPath)) {
    return false;
  }
  try {
    const packageJson = JSON.parse(readFileSync5(packageJsonPath, "utf-8"));
    const name = packageJson.name ?? "";
    const isKarimoName = name === "karimo" || name === "@karimo/core";
    if (!isKarimoName) {
      return false;
    }
    const karimoFiles = ["bin/karimo.ts", "src/cli/main.ts"];
    return karimoFiles.every((file) => existsSync12(join16(projectRoot, file)));
  } catch {
    return false;
  }
}
function detectProjectSignals(projectRoot) {
  const detected = [];
  let totalWeight = 0;
  for (const signal of PROJECT_SIGNALS) {
    const filePath = join16(projectRoot, signal.file);
    if (existsSync12(filePath)) {
      detected.push(signal);
      totalWeight += signal.weight;
    }
  }
  return {
    signals: detected,
    totalWeight
  };
}
function checkWorkingDirectory(projectRoot) {
  const absolutePath = resolve2(projectRoot);
  const home = homedir2();
  if (absolutePath === home) {
    return {
      safe: false,
      reason: "home_directory",
      details: "Cannot run KARIMO in home directory"
    };
  }
  if (absolutePath === "/") {
    return {
      safe: false,
      reason: "root_directory",
      details: "Cannot run KARIMO in root directory"
    };
  }
  if (isKarimoRepo(absolutePath)) {
    return {
      safe: false,
      reason: "karimo_repo",
      details: "Cannot run KARIMO on the KARIMO repository itself"
    };
  }
  const { signals, totalWeight } = detectProjectSignals(absolutePath);
  if (totalWeight < MIN_SIGNAL_WEIGHT) {
    return {
      safe: false,
      reason: "insufficient_signals",
      details: `Directory does not appear to be a valid project (signal weight: ${totalWeight}/${MIN_SIGNAL_WEIGHT})`,
      signalWeight: totalWeight,
      detectedSignals: signals
    };
  }
  return {
    safe: true,
    signalWeight: totalWeight,
    detectedSignals: signals
  };
}
function formatSafetyError(result) {
  if (result.safe) {
    return "";
  }
  const lines = [];
  switch (result.reason) {
    case "home_directory":
      lines.push("You are in your home directory.");
      lines.push("");
      lines.push("KARIMO must be run inside a project directory.");
      lines.push("Navigate to a project folder and try again:");
      lines.push("");
      lines.push("  cd ~/path/to/your/project");
      lines.push("  karimo");
      break;
    case "root_directory":
      lines.push("You are in the root directory.");
      lines.push("");
      lines.push("KARIMO must be run inside a project directory.");
      lines.push("Navigate to a project folder and try again.");
      break;
    case "karimo_repo":
      lines.push("This is the KARIMO repository itself.");
      lines.push("");
      lines.push("KARIMO should not be used to modify its own codebase.");
      lines.push("Navigate to a different project to use KARIMO:");
      lines.push("");
      lines.push("  cd ~/path/to/your/project");
      lines.push("  karimo");
      break;
    case "insufficient_signals":
      lines.push("This directory does not appear to be a valid project.");
      lines.push("");
      lines.push("KARIMO looks for project indicators like:");
      lines.push("  - package.json, Cargo.toml, pyproject.toml, go.mod");
      lines.push("  - .git directory, Makefile");
      lines.push("  - README.md, LICENSE");
      lines.push("");
      if (result.detectedSignals && result.detectedSignals.length > 0) {
        lines.push(`Found: ${result.detectedSignals.map((s) => s.file).join(", ")}`);
        lines.push(`Signal weight: ${result.signalWeight}/${MIN_SIGNAL_WEIGHT} (minimum required)`);
      } else {
        lines.push("No project indicators found.");
      }
      lines.push("");
      lines.push("Make sure you are in a project directory with standard project files.");
      break;
  }
  return lines.join(`
`);
}
var init_safety = __esm(() => {
  init_signals();
  init_signals();
});

// src/cli/telemetry/writer.ts
import { appendFileSync as appendFileSync2, existsSync as existsSync13, mkdirSync as mkdirSync4 } from "fs";
import { join as join17 } from "path";
function getTelemetryPath(projectRoot) {
  return join17(projectRoot, KARIMO_DIR3, TELEMETRY_FILE);
}
function ensureKarimoDir(projectRoot) {
  const karimoDir = join17(projectRoot, KARIMO_DIR3);
  if (!existsSync13(karimoDir)) {
    mkdirSync4(karimoDir, { recursive: true });
  }
}
function writeTelemetryEvent(projectRoot, event) {
  try {
    ensureKarimoDir(projectRoot);
    const logPath = getTelemetryPath(projectRoot);
    const line = `${JSON.stringify(event)}
`;
    appendFileSync2(logPath, line, "utf-8");
  } catch {}
}
var TELEMETRY_FILE = "telemetry.log", KARIMO_DIR3 = ".karimo";
var init_writer = () => {};

// src/cli/telemetry/helpers.ts
function now() {
  return new Date().toISOString();
}
function logCommandStart(projectRoot, command, args) {
  const event = {
    event: "command_start",
    timestamp: now(),
    command,
    args
  };
  writeTelemetryEvent(projectRoot, event);
}
function logCommandEnd(projectRoot, command, durationMs, exitCode) {
  const event = {
    event: "command_end",
    timestamp: now(),
    command,
    durationMs,
    exitCode
  };
  writeTelemetryEvent(projectRoot, event);
}
function logError(projectRoot, error, options) {
  const errorInfo = {
    name: error.name,
    message: error.message
  };
  if (error.stack !== undefined) {
    errorInfo.stack = error.stack;
  }
  const event = {
    event: "error",
    timestamp: now(),
    error: errorInfo
  };
  if (options?.fatal !== undefined) {
    event.fatal = options.fatal;
  }
  writeTelemetryEvent(projectRoot, event);
}
function logRetry(projectRoot, operation, attempt, maxAttempts, reason) {
  const event = {
    event: "retry",
    timestamp: now(),
    operation,
    attempt,
    maxAttempts
  };
  if (reason !== undefined) {
    event.reason = reason;
  }
  writeTelemetryEvent(projectRoot, event);
}
async function withTelemetry(projectRoot, command, args, fn) {
  const startTime = Date.now();
  logCommandStart(projectRoot, command, args);
  try {
    const result = await fn();
    const durationMs = Date.now() - startTime;
    logCommandEnd(projectRoot, command, durationMs, 0);
    return result;
  } catch (error) {
    const durationMs = Date.now() - startTime;
    logCommandEnd(projectRoot, command, durationMs, 1);
    if (error instanceof Error) {
      logError(projectRoot, error);
    }
    throw error;
  }
}
var init_helpers = __esm(() => {
  init_writer();
});

// src/cli/telemetry/index.ts
var exports_telemetry = {};
__export(exports_telemetry, {
  writeTelemetryEvent: () => writeTelemetryEvent,
  withTelemetry: () => withTelemetry,
  logRetry: () => logRetry,
  logError: () => logError,
  logCommandStart: () => logCommandStart,
  logCommandEnd: () => logCommandEnd,
  getTelemetryPath: () => getTelemetryPath
});
var init_telemetry = __esm(() => {
  init_writer();
  init_helpers();
});

// src/cli/state/types.ts
var DEFAULT_STATE;
var init_types2 = __esm(() => {
  DEFAULT_STATE = {
    level: 0,
    current_prd: null,
    current_prd_section: null,
    completed_prds: [],
    completed_cycles: 0,
    last_activity: new Date().toISOString()
  };
});

// src/cli/state/schema.ts
var KarimoLevelSchema, PRDSectionSchema, KarimoStateSchema, PRDMetadataSchema2;
var init_schema3 = __esm(() => {
  init_zod();
  KarimoLevelSchema = exports_external.union([
    exports_external.literal(0),
    exports_external.literal(1),
    exports_external.literal(2),
    exports_external.literal(3),
    exports_external.literal(4),
    exports_external.literal(5)
  ]);
  PRDSectionSchema = exports_external.enum([
    "framing",
    "requirements",
    "dependencies",
    "agent-context",
    "retrospective",
    "review",
    "finalized"
  ]);
  KarimoStateSchema = exports_external.object({
    level: KarimoLevelSchema,
    current_prd: exports_external.string().nullable(),
    current_prd_section: PRDSectionSchema.nullable(),
    completed_prds: exports_external.array(exports_external.string()),
    completed_cycles: exports_external.number().int().nonnegative(),
    last_activity: exports_external.string().datetime({ offset: true }).or(exports_external.string().datetime()),
    onboarded_at: exports_external.string().datetime({ offset: true }).or(exports_external.string().datetime()).optional(),
    doctor_last_run: exports_external.string().datetime({ offset: true }).or(exports_external.string().datetime()).optional()
  });
  PRDMetadataSchema2 = exports_external.object({
    feature_name: exports_external.string(),
    feature_slug: exports_external.string(),
    owner: exports_external.string(),
    status: exports_external.enum(["draft", "active", "complete"]),
    created_date: exports_external.string(),
    target_date: exports_external.string().optional(),
    phase: exports_external.string().optional(),
    scope_type: exports_external.string().optional(),
    github_project: exports_external.string().optional(),
    links: exports_external.array(exports_external.string()).optional(),
    checkpoint_refs: exports_external.array(exports_external.string()).optional()
  });
});

// src/cli/state/errors.ts
var KarimoStateError, StateCorruptedError, StateWriteError, PRDMetadataError;
var init_errors9 = __esm(() => {
  KarimoStateError = class KarimoStateError extends Error {
    constructor(message) {
      super(message);
      this.name = "KarimoStateError";
    }
  };
  StateCorruptedError = class StateCorruptedError extends KarimoStateError {
    path;
    details;
    constructor(path, details) {
      super(`State file corrupted at ${path}: ${details}`);
      this.path = path;
      this.details = details;
      this.name = "StateCorruptedError";
    }
  };
  StateWriteError = class StateWriteError extends KarimoStateError {
    path;
    cause;
    constructor(path, cause) {
      super(`Failed to write state file at ${path}: ${cause.message}`);
      this.path = path;
      this.cause = cause;
      this.name = "StateWriteError";
    }
  };
  PRDMetadataError = class PRDMetadataError extends KarimoStateError {
    path;
    details;
    constructor(path, details) {
      super(`Failed to parse PRD metadata at ${path}: ${details}`);
      this.path = path;
      this.details = details;
      this.name = "PRDMetadataError";
    }
  };
});

// src/cli/state/loader.ts
import { existsSync as existsSync14, mkdirSync as mkdirSync5 } from "fs";
import { join as join18 } from "path";
function getStatePath(projectRoot) {
  return join18(projectRoot, KARIMO_DIR4, STATE_FILE);
}
function getKarimoDirPath(projectRoot) {
  return join18(projectRoot, KARIMO_DIR4);
}
function karimoDirExists(projectRoot) {
  return existsSync14(getKarimoDirPath(projectRoot));
}
function stateExists(projectRoot) {
  return existsSync14(getStatePath(projectRoot));
}
async function loadState(projectRoot) {
  const statePath = getStatePath(projectRoot);
  if (!existsSync14(statePath)) {
    return { ...DEFAULT_STATE };
  }
  try {
    const content = await Bun.file(statePath).text();
    const json = JSON.parse(content);
    const result = KarimoStateSchema.safeParse(json);
    if (!result.success) {
      throw new StateCorruptedError(statePath, result.error.errors.map((e2) => e2.message).join(", "));
    }
    return result.data;
  } catch (error) {
    if (error instanceof StateCorruptedError) {
      throw error;
    }
    throw new StateCorruptedError(statePath, error.message);
  }
}
async function saveState(projectRoot, state) {
  const karimoDir = getKarimoDirPath(projectRoot);
  const statePath = getStatePath(projectRoot);
  if (!existsSync14(karimoDir)) {
    mkdirSync5(karimoDir, { recursive: true });
  }
  const updatedState = {
    ...state,
    last_activity: new Date().toISOString()
  };
  try {
    const content = JSON.stringify(updatedState, null, 2);
    await Bun.write(statePath, content);
  } catch (error) {
    throw new StateWriteError(statePath, error);
  }
}
async function updateState(projectRoot, updates) {
  const currentState = await loadState(projectRoot);
  const newState = {
    ...currentState,
    ...updates
  };
  await saveState(projectRoot, newState);
  return newState;
}
async function resetState(projectRoot) {
  const currentState = await loadState(projectRoot);
  const resetState2 = {
    ...DEFAULT_STATE,
    completed_prds: currentState.completed_prds,
    completed_cycles: currentState.completed_cycles
  };
  await saveState(projectRoot, resetState2);
  return resetState2;
}
async function setCurrentPRD(projectRoot, prdSlug, section = "framing") {
  return updateState(projectRoot, {
    current_prd: prdSlug,
    current_prd_section: section
  });
}
async function clearCurrentPRD(projectRoot, markCompleted = false) {
  const currentState = await loadState(projectRoot);
  const completedPrds = markCompleted && currentState.current_prd ? [...currentState.completed_prds, currentState.current_prd] : currentState.completed_prds;
  return updateState(projectRoot, {
    current_prd: null,
    current_prd_section: null,
    completed_prds: completedPrds
  });
}
async function markOnboarded(projectRoot) {
  return updateState(projectRoot, {
    onboarded_at: new Date().toISOString()
  });
}
async function recordDoctorRun(projectRoot) {
  return updateState(projectRoot, {
    doctor_last_run: new Date().toISOString()
  });
}
async function isOnboarded(projectRoot) {
  const state = await loadState(projectRoot);
  return state.onboarded_at !== undefined;
}
function isOnboardedSync(projectRoot) {
  const statePath = getStatePath(projectRoot);
  if (!existsSync14(statePath)) {
    return false;
  }
  try {
    const fs = __require("fs");
    const text = fs.readFileSync(statePath, "utf-8");
    const json = JSON.parse(text);
    return typeof json === "object" && json !== null && "onboarded_at" in json;
  } catch {
    return false;
  }
}
var KARIMO_DIR4 = ".karimo", STATE_FILE = "state.json";
var init_loader2 = __esm(() => {
  init_errors9();
  init_schema3();
  init_types2();
});

// src/cli/state/detector.ts
import { existsSync as existsSync15, readdirSync as readdirSync2, statSync as statSync3 } from "fs";
import { basename as basename2, join as join19 } from "path";
function configExists2(projectRoot) {
  return existsSync15(join19(projectRoot, ".karimo", CONFIG_FILE4));
}
function prdsDirExists(projectRoot) {
  return existsSync15(join19(projectRoot, ".karimo", PRDS_DIR));
}
function listPRDFiles(projectRoot) {
  const prdsPath = join19(projectRoot, ".karimo", PRDS_DIR);
  if (!existsSync15(prdsPath)) {
    return [];
  }
  const entries = readdirSync2(prdsPath);
  return entries.filter((entry) => entry.endsWith(".md")).map((entry) => join19(prdsPath, entry)).filter((path) => statSync3(path).isFile()).sort();
}
function extractPRDSlug(path) {
  const filename = basename2(path);
  return filename.replace(/\.md$/, "");
}
function extractFrontmatter(content) {
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match)
    return null;
  const frontmatter = match[1];
  return frontmatter ?? null;
}
function parsePRDMetadata(content, path) {
  const frontmatter = extractFrontmatter(content);
  if (!frontmatter) {
    return null;
  }
  try {
    const yaml = $parse(frontmatter);
    const result = PRDMetadataSchema2.safeParse(yaml);
    if (!result.success) {
      console.warn(`Warning: Invalid PRD metadata at ${path}: ${result.error.message}`);
      return null;
    }
    return result.data;
  } catch {
    return null;
  }
}
function isPRDFinalized(content) {
  const tasksMatch = content.match(/```yaml\n[\s\S]*?tasks:\s*\n([\s\S]*?)```/);
  if (!tasksMatch) {
    return false;
  }
  const tasksContent = tasksMatch[1];
  if (!tasksContent) {
    return false;
  }
  return /- id:/.test(tasksContent);
}
async function getPRDFileInfos(projectRoot) {
  const files = listPRDFiles(projectRoot);
  const infos = [];
  for (const path of files) {
    const content = await Bun.file(path).text();
    const slug = extractPRDSlug(path);
    const metadata = parsePRDMetadata(content, path);
    const finalized = isPRDFinalized(content);
    infos.push({
      path,
      slug,
      metadata,
      finalized
    });
  }
  return infos;
}
async function getCurrentPRDSection(projectRoot, prdSlug) {
  const state = await loadState(projectRoot);
  if (state.current_prd === prdSlug && state.current_prd_section) {
    return state.current_prd_section;
  }
  const prdPath = join19(projectRoot, ".karimo", PRDS_DIR, `${prdSlug}.md`);
  if (!existsSync15(prdPath)) {
    return null;
  }
  const content = await Bun.file(prdPath).text();
  if (isPRDFinalized(content)) {
    return "finalized";
  }
  if (/## 11\. Agent Boundaries/.test(content) && /Files the agent should reference/.test(content)) {
    return "review";
  }
  if (/## 10\. Checkpoint Learnings/.test(content) && /Patterns to reinforce/.test(content)) {
    return "retrospective";
  }
  if (/## 6\. Dependencies & Risks/.test(content) && /### External Blockers/.test(content)) {
    return "dependencies";
  }
  if (/## 4\. Requirements/.test(content) && /### Must Have/.test(content)) {
    return "requirements";
  }
  if (/## 1\. Executive Summary/.test(content) && /One-liner:/.test(content)) {
    return "framing";
  }
  return null;
}
async function detectProjectPhase(projectRoot) {
  if (!isOnboardedSync(projectRoot)) {
    return "welcome";
  }
  if (!configExists2(projectRoot)) {
    return "init";
  }
  const prdInfos = await getPRDFileInfos(projectRoot);
  if (prdInfos.length === 0) {
    return "create-prd";
  }
  const state = await loadState(projectRoot);
  if (state.current_prd && state.current_prd_section !== "finalized") {
    const currentPRD = prdInfos.find((p) => p.slug === state.current_prd);
    if (currentPRD && !currentPRD.finalized) {
      return "resume-prd";
    }
  }
  const finalizedPRDs = prdInfos.filter((p) => p.finalized);
  if (finalizedPRDs.length > 0) {
    const completedPRDSlugs = new Set(state.completed_prds);
    const pendingPRDs = finalizedPRDs.filter((p) => !completedPRDSlugs.has(p.slug));
    if (pendingPRDs.length > 0) {
      return "execute";
    }
  }
  return "complete";
}
async function getNextPRDNumber(projectRoot) {
  const prdInfos = await getPRDFileInfos(projectRoot);
  let maxNum = 0;
  for (const info of prdInfos) {
    const match = info.slug.match(/^(\d+)_/);
    if (match) {
      const numStr = match[1];
      if (numStr) {
        const num = Number.parseInt(numStr, 10);
        if (num > maxNum) {
          maxNum = num;
        }
      }
    }
  }
  return String(maxNum + 1).padStart(3, "0");
}
var CONFIG_FILE4 = "config.yaml", PRDS_DIR = "prds";
var init_detector = __esm(() => {
  init_dist();
  init_loader2();
  init_schema3();
});

// src/cli/state/index.ts
var exports_state = {};
__export(exports_state, {
  updateState: () => updateState,
  stateExists: () => stateExists,
  setCurrentPRD: () => setCurrentPRD,
  saveState: () => saveState,
  resetState: () => resetState,
  recordDoctorRun: () => recordDoctorRun,
  prdsDirExists: () => prdsDirExists,
  parsePRDMetadata: () => parsePRDMetadata,
  markOnboarded: () => markOnboarded,
  loadState: () => loadState,
  listPRDFiles: () => listPRDFiles,
  karimoDirExists: () => karimoDirExists,
  isPRDFinalized: () => isPRDFinalized,
  isOnboardedSync: () => isOnboardedSync,
  isOnboarded: () => isOnboarded,
  getStatePath: () => getStatePath,
  getPRDFileInfos: () => getPRDFileInfos,
  getNextPRDNumber: () => getNextPRDNumber,
  getKarimoDirPath: () => getKarimoDirPath,
  getCurrentPRDSection: () => getCurrentPRDSection,
  extractPRDSlug: () => extractPRDSlug,
  detectProjectPhase: () => detectProjectPhase,
  configExists: () => configExists2,
  clearCurrentPRD: () => clearCurrentPRD,
  StateWriteError: () => StateWriteError,
  StateCorruptedError: () => StateCorruptedError,
  PRDSectionSchema: () => PRDSectionSchema,
  PRDMetadataSchema: () => PRDMetadataSchema2,
  PRDMetadataError: () => PRDMetadataError,
  KarimoStateSchema: () => KarimoStateSchema,
  KarimoStateError: () => KarimoStateError,
  KarimoLevelSchema: () => KarimoLevelSchema,
  DEFAULT_STATE: () => DEFAULT_STATE
});
var init_state = __esm(() => {
  init_types2();
  init_schema3();
  init_errors9();
  init_loader2();
  init_detector();
});

// src/cli/returning-welcome.ts
var exports_returning_welcome = {};
__export(exports_returning_welcome, {
  showReturningWelcome: () => showReturningWelcome,
  buildStateContext: () => buildStateContext
});
function getStateHint(context) {
  switch (context.phase) {
    case "resume-prd": {
      const prdName = context.currentPRDName ?? "untitled";
      const section = context.currentSection ? SECTION_DISPLAY[context.currentSection] : "unknown";
      return `${OR}\u25CF${RST} ${WH}PRD in progress${RST} ${GY}\u2014${RST} ${WH}"${prdName}"${RST} ${GYD}(${section})${RST}`;
    }
    case "execute": {
      const count = context.readyTaskCount;
      const noun = count === 1 ? "task" : "tasks";
      return `${OR}\u25CF${RST} ${WH}${count} ${noun} ready for execution${RST}`;
    }
    case "create-prd":
      return `${OR}\u25CF${RST} ${WH}Ready to create your first PRD${RST}`;
    case "complete":
      return `${GN}\u2713${RST} ${WH}All tasks complete${RST}`;
    case "init":
      return `${OR}\u25CF${RST} ${WH}Configuration needed${RST}`;
    case "welcome":
      return `${OR}\u25CF${RST} ${WH}Welcome to KARIMO${RST}`;
    default:
      return "";
  }
}
async function buildStateContext(projectRoot, phase) {
  let state = null;
  let currentPRDName = null;
  let currentSection = null;
  let readyTaskCount = 0;
  try {
    state = await loadState(projectRoot);
    currentPRDName = state.current_prd;
    currentSection = state.current_prd_section;
  } catch {}
  if (phase === "execute") {
    try {
      const prdInfos = await getPRDFileInfos(projectRoot);
      const finalizedPRDs = prdInfos.filter((prd) => prd.finalized);
      const completedPRDSlugs = new Set(state?.completed_prds ?? []);
      const pendingPRDs = finalizedPRDs.filter((prd) => !completedPRDSlugs.has(prd.slug));
      for (const prd of pendingPRDs) {
        const prdResult = await parsePRDFile(prd.path);
        if (prdResult.tasks && prdResult.tasks.length > 0) {
          const graph = buildDependencyGraph(prdResult.tasks);
          const readyTasks = getReadyTasks(graph, new Set);
          readyTaskCount += readyTasks.length;
        }
      }
    } catch {}
  }
  return {
    phase,
    state,
    currentPRDName,
    currentSection,
    readyTaskCount
  };
}
function getActionOptions(phase) {
  switch (phase) {
    case "resume-prd":
      return [
        { value: "resume-prd", label: "Resume PRD interview", hint: "Continue where you left off" },
        { value: "start-prd", label: "Start new PRD", hint: "Create a different feature" },
        { value: "reconfigure", label: "Reconfigure project", hint: "Update config.yaml" },
        { value: "help", label: "Show help", hint: "Available commands" },
        { value: "exit", label: "Exit", hint: "Ctrl+C" }
      ];
    case "execute":
      return [
        { value: "execute", label: "Execute tasks", hint: "Run ready tasks" },
        { value: "start-prd", label: "Create new PRD", hint: "Add another feature" },
        { value: "reconfigure", label: "Reconfigure project", hint: "Update config.yaml" },
        { value: "help", label: "Show help", hint: "Available commands" },
        { value: "exit", label: "Exit", hint: "Ctrl+C" }
      ];
    case "create-prd":
      return [
        { value: "start-prd", label: "Create PRD", hint: "Start PRD interview" },
        { value: "reconfigure", label: "Reconfigure project", hint: "Update config.yaml" },
        { value: "help", label: "Show help", hint: "Available commands" },
        { value: "exit", label: "Exit", hint: "Ctrl+C" }
      ];
    case "init":
      return [
        { value: "init", label: "Configure project", hint: "Set up KARIMO" },
        { value: "help", label: "Show help", hint: "Available commands" },
        { value: "exit", label: "Exit", hint: "Ctrl+C" }
      ];
    case "complete":
      return [
        { value: "start-prd", label: "Create new PRD", hint: "Start a new feature" },
        { value: "reconfigure", label: "Reconfigure project", hint: "Update config.yaml" },
        { value: "help", label: "Show help", hint: "Available commands" },
        { value: "exit", label: "Exit", hint: "Ctrl+C" }
      ];
    default:
      return [
        { value: "help", label: "Show help", hint: "Available commands" },
        { value: "exit", label: "Exit", hint: "Ctrl+C" }
      ];
  }
}
function showInlineHelp() {
  console.log();
  console.log(`${WH}Available Commands${RST}`);
  console.log();
  console.log(`  ${OR}karimo${RST}             ${GY}Start guided flow${RST}`);
  console.log(`  ${OR}karimo init${RST}        ${GY}Configure project${RST}`);
  console.log(`  ${OR}karimo doctor${RST}      ${GY}Check environment${RST}`);
  console.log(`  ${OR}karimo status${RST}      ${GY}Show project status${RST}`);
  console.log(`  ${OR}karimo info${RST}        ${GY}About KARIMO${RST}`);
  console.log(`  ${OR}karimo help${RST}        ${GY}Show full help${RST}`);
  console.log();
}
async function showReturningWelcome(projectRoot, phase) {
  if (!isTTY()) {
    return getDefaultAction(phase);
  }
  const sessionContext = await buildSessionContext(projectRoot);
  const stateContext = await buildStateContext(projectRoot, phase);
  console.log(getCompactBannerString());
  console.log(getSessionInfoString(sessionContext));
  console.log(getStateHint(stateContext));
  console.log();
  const options = getActionOptions(phase);
  const action = await le({
    message: "What would you like to do?",
    options
  });
  if (lD(action)) {
    return null;
  }
  if (action === "help") {
    showInlineHelp();
    return showReturningWelcome(projectRoot, phase);
  }
  return action;
}
function getDefaultAction(phase) {
  switch (phase) {
    case "resume-prd":
      return "resume-prd";
    case "execute":
      return "execute";
    case "create-prd":
      return "start-prd";
    case "init":
      return "init";
    default:
      return "exit";
  }
}
var SECTION_DISPLAY;
var init_returning_welcome = __esm(() => {
  init_dist3();
  init_prd();
  init_state();
  init_colors();
  init_compact_banner();
  init_session_info();
  init_terminal_utils();
  SECTION_DISPLAY = {
    framing: "framing",
    requirements: "requirements",
    dependencies: "dependencies",
    "agent-context": "agent context",
    retrospective: "retrospective",
    review: "review",
    finalized: "finalized"
  };
});

// node_modules/@anthropic-ai/sdk/internal/tslib.mjs
function __classPrivateFieldSet(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldGet(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
}
var init_tslib = () => {};

// node_modules/@anthropic-ai/sdk/internal/utils/uuid.mjs
var uuid4 = function() {
  const { crypto: crypto2 } = globalThis;
  if (crypto2?.randomUUID) {
    uuid4 = crypto2.randomUUID.bind(crypto2);
    return crypto2.randomUUID();
  }
  const u8 = new Uint8Array(1);
  const randomByte = crypto2 ? () => crypto2.getRandomValues(u8)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c2) => (+c2 ^ randomByte() & 15 >> +c2 / 4).toString(16));
};

// node_modules/@anthropic-ai/sdk/internal/errors.mjs
function isAbortError(err) {
  return typeof err === "object" && err !== null && (("name" in err) && err.name === "AbortError" || ("message" in err) && String(err.message).includes("FetchRequestCanceledException"));
}
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      if (Object.prototype.toString.call(err) === "[object Error]") {
        const error = new Error(err.message, err.cause ? { cause: err.cause } : {});
        if (err.stack)
          error.stack = err.stack;
        if (err.cause && !error.cause)
          error.cause = err.cause;
        if (err.name)
          error.name = err.name;
        return error;
      }
    } catch {}
    try {
      return new Error(JSON.stringify(err));
    } catch {}
  }
  return new Error(err);
};

// node_modules/@anthropic-ai/sdk/core/error.mjs
var AnthropicError, APIError, APIUserAbortError, APIConnectionError, APIConnectionTimeoutError, BadRequestError, AuthenticationError, PermissionDeniedError, NotFoundError, ConflictError, UnprocessableEntityError, RateLimitError, InternalServerError;
var init_error = __esm(() => {
  AnthropicError = class AnthropicError extends Error {
  };
  APIError = class APIError extends AnthropicError {
    constructor(status, error, message, headers) {
      super(`${APIError.makeMessage(status, error, message)}`);
      this.status = status;
      this.headers = headers;
      this.requestID = headers?.get("request-id");
      this.error = error;
    }
    static makeMessage(status, error, message) {
      const msg = error?.message ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
      if (status && msg) {
        return `${status} ${msg}`;
      }
      if (status) {
        return `${status} status code (no body)`;
      }
      if (msg) {
        return msg;
      }
      return "(no status code or body)";
    }
    static generate(status, errorResponse, message, headers) {
      if (!status || !headers) {
        return new APIConnectionError({ message, cause: castToError(errorResponse) });
      }
      const error = errorResponse;
      if (status === 400) {
        return new BadRequestError(status, error, message, headers);
      }
      if (status === 401) {
        return new AuthenticationError(status, error, message, headers);
      }
      if (status === 403) {
        return new PermissionDeniedError(status, error, message, headers);
      }
      if (status === 404) {
        return new NotFoundError(status, error, message, headers);
      }
      if (status === 409) {
        return new ConflictError(status, error, message, headers);
      }
      if (status === 422) {
        return new UnprocessableEntityError(status, error, message, headers);
      }
      if (status === 429) {
        return new RateLimitError(status, error, message, headers);
      }
      if (status >= 500) {
        return new InternalServerError(status, error, message, headers);
      }
      return new APIError(status, error, message, headers);
    }
  };
  APIUserAbortError = class APIUserAbortError extends APIError {
    constructor({ message } = {}) {
      super(undefined, undefined, message || "Request was aborted.", undefined);
    }
  };
  APIConnectionError = class APIConnectionError extends APIError {
    constructor({ message, cause }) {
      super(undefined, undefined, message || "Connection error.", undefined);
      if (cause)
        this.cause = cause;
    }
  };
  APIConnectionTimeoutError = class APIConnectionTimeoutError extends APIConnectionError {
    constructor({ message } = {}) {
      super({ message: message ?? "Request timed out." });
    }
  };
  BadRequestError = class BadRequestError extends APIError {
  };
  AuthenticationError = class AuthenticationError extends APIError {
  };
  PermissionDeniedError = class PermissionDeniedError extends APIError {
  };
  NotFoundError = class NotFoundError extends APIError {
  };
  ConflictError = class ConflictError extends APIError {
  };
  UnprocessableEntityError = class UnprocessableEntityError extends APIError {
  };
  RateLimitError = class RateLimitError extends APIError {
  };
  InternalServerError = class InternalServerError extends APIError {
  };
});

// node_modules/@anthropic-ai/sdk/internal/utils/values.mjs
function maybeObj(x2) {
  if (typeof x2 !== "object") {
    return {};
  }
  return x2 ?? {};
}
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
var startsWithSchemeRegexp, isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
}, isArray = (val) => (isArray = Array.isArray, isArray(val)), isReadonlyArray, validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new AnthropicError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new AnthropicError(`${name} must be a positive integer`);
  }
  return n;
}, safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return;
  }
};
var init_values = __esm(() => {
  init_error();
  startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
  isReadonlyArray = isArray;
});

// node_modules/@anthropic-ai/sdk/internal/utils/sleep.mjs
var sleep2 = (ms) => new Promise((resolve3) => setTimeout(resolve3, ms));

// node_modules/@anthropic-ai/sdk/version.mjs
var VERSION10 = "0.74.0";

// node_modules/@anthropic-ai/sdk/internal/detect-platform.mjs
function getDetectedPlatform() {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return "deno";
  }
  if (typeof EdgeRuntime !== "undefined") {
    return "edge";
  }
  if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
    return "node";
  }
  return "unknown";
}
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var isRunningInBrowser = () => {
  return typeof window !== "undefined" && typeof window.document !== "undefined" && typeof navigator !== "undefined";
}, getPlatformProperties = () => {
  const detectedPlatform = getDetectedPlatform();
  if (detectedPlatform === "deno") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION10,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION10,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  }
  if (detectedPlatform === "node") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION10,
      "X-Stainless-OS": normalizePlatform(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": normalizeArch(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION10,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION10,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
}, normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
}, normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
}, _platformHeaders, getPlatformHeaders = () => {
  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
};
var init_detect_platform = () => {};

// node_modules/@anthropic-ai/sdk/internal/shims.mjs
function getDefaultFetch() {
  if (typeof fetch !== "undefined") {
    return fetch;
  }
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new Anthropic({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function makeReadableStream(...args) {
  const ReadableStream = globalThis.ReadableStream;
  if (typeof ReadableStream === "undefined") {
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  }
  return new ReadableStream(...args);
}
function ReadableStreamFrom(iterable) {
  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
  return makeReadableStream({
    start() {},
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      await iter.return?.();
    }
  });
}
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e2) {
        reader.releaseLock();
        throw e2;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: undefined };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function CancelReadableStream(stream) {
  if (stream === null || typeof stream !== "object")
    return;
  if (stream[Symbol.asyncIterator]) {
    await stream[Symbol.asyncIterator]().return?.();
    return;
  }
  const reader = stream.getReader();
  const cancelPromise = reader.cancel();
  reader.releaseLock();
  await cancelPromise;
}

// node_modules/@anthropic-ai/sdk/internal/request-options.mjs
var FallbackEncoder = ({ headers, body }) => {
  return {
    bodyHeaders: {
      "content-type": "application/json"
    },
    body: JSON.stringify(body)
  };
};

// node_modules/@anthropic-ai/sdk/internal/utils/bytes.mjs
function concatBytes(buffers) {
  let length = 0;
  for (const buffer of buffers) {
    length += buffer.length;
  }
  const output = new Uint8Array(length);
  let index = 0;
  for (const buffer of buffers) {
    output.set(buffer, index);
    index += buffer.length;
  }
  return output;
}
function encodeUTF8(str) {
  let encoder;
  return (encodeUTF8_ ?? (encoder = new globalThis.TextEncoder, encodeUTF8_ = encoder.encode.bind(encoder)))(str);
}
function decodeUTF8(bytes) {
  let decoder;
  return (decodeUTF8_ ?? (decoder = new globalThis.TextDecoder, decodeUTF8_ = decoder.decode.bind(decoder)))(bytes);
}
var encodeUTF8_, decodeUTF8_;

// node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs
class LineDecoder {
  constructor() {
    _LineDecoder_buffer.set(this, undefined);
    _LineDecoder_carriageReturnIndex.set(this, undefined);
    __classPrivateFieldSet(this, _LineDecoder_buffer, new Uint8Array, "f");
    __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    __classPrivateFieldSet(this, _LineDecoder_buffer, concatBytes([__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), binaryChunk]), "f");
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex(__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f"))) != null) {
      if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") == null) {
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, "f");
        continue;
      }
      if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
        lines.push(decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
        __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f")), "f");
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
        continue;
      }
      const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, endIndex));
      lines.push(line);
      __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(patternIndex.index), "f");
      __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
    }
    return lines;
  }
  flush() {
    if (!__classPrivateFieldGet(this, _LineDecoder_buffer, "f").length) {
      return [];
    }
    return this.decode(`
`);
  }
}
function findNewlineIndex(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i = startIndex ?? 0;i < buffer.length; i++) {
    if (buffer[i] === newline) {
      return { preceding: i, index: i + 1, carriage: false };
    }
    if (buffer[i] === carriage) {
      return { preceding: i, index: i + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0;i < buffer.length - 1; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}
var _LineDecoder_buffer, _LineDecoder_carriageReturnIndex;
var init_line = __esm(() => {
  init_tslib();
  _LineDecoder_buffer = new WeakMap, _LineDecoder_carriageReturnIndex = new WeakMap;
  LineDecoder.NEWLINE_CHARS = new Set([`
`, "\r"]);
  LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
});

// node_modules/@anthropic-ai/sdk/internal/utils/log.mjs
function noop2() {}
function makeLogFn(fnLevel, logger, logLevel) {
  if (!logger || levelNumbers[fnLevel] > levelNumbers[logLevel]) {
    return noop2;
  } else {
    return logger[fnLevel].bind(logger);
  }
}
function loggerFor(client) {
  const logger = client.logger;
  const logLevel = client.logLevel ?? "off";
  if (!logger) {
    return noopLogger;
  }
  const cachedLogger = cachedLoggers.get(logger);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn("error", logger, logLevel),
    warn: makeLogFn("warn", logger, logLevel),
    info: makeLogFn("info", logger, logLevel),
    debug: makeLogFn("debug", logger, logLevel)
  };
  cachedLoggers.set(logger, [logLevel, levelLogger]);
  return levelLogger;
}
var levelNumbers, parseLogLevel = (maybeLevel, sourceName, client) => {
  if (!maybeLevel) {
    return;
  }
  if (hasOwn(levelNumbers, maybeLevel)) {
    return maybeLevel;
  }
  loggerFor(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);
  return;
}, noopLogger, cachedLoggers, formatRequestDetails = (details) => {
  if (details.options) {
    details.options = { ...details.options };
    delete details.options["headers"];
  }
  if (details.headers) {
    details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
      name,
      name.toLowerCase() === "x-api-key" || name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
    ]));
  }
  if ("retryOfRequestLogID" in details) {
    if (details.retryOfRequestLogID) {
      details.retryOf = details.retryOfRequestLogID;
    }
    delete details.retryOfRequestLogID;
  }
  return details;
};
var init_log = __esm(() => {
  init_values();
  levelNumbers = {
    off: 0,
    error: 200,
    warn: 300,
    info: 400,
    debug: 500
  };
  noopLogger = {
    error: noop2,
    warn: noop2,
    info: noop2,
    debug: noop2
  };
  cachedLoggers = /* @__PURE__ */ new WeakMap;
});

// node_modules/@anthropic-ai/sdk/core/streaming.mjs
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
      throw new AnthropicError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
    }
    throw new AnthropicError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder;
  const lineDecoder = new LineDecoder;
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator2) {
  let data = new Uint8Array;
  for await (const chunk of iterator2) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}

class SSEDecoder {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _3, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
}
function partition(str, delimiter) {
  const index = str.indexOf(delimiter);
  if (index !== -1) {
    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
  }
  return [str, "", ""];
}
var _Stream_client, Stream;
var init_streaming = __esm(() => {
  init_tslib();
  init_error();
  init_line();
  init_values();
  init_log();
  init_error();
  Stream = class Stream {
    constructor(iterator2, controller, client) {
      this.iterator = iterator2;
      _Stream_client.set(this, undefined);
      this.controller = controller;
      __classPrivateFieldSet(this, _Stream_client, client, "f");
    }
    static fromSSEResponse(response, controller, client) {
      let consumed = false;
      const logger = client ? loggerFor(client) : console;
      async function* iterator2() {
        if (consumed) {
          throw new AnthropicError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        }
        consumed = true;
        let done = false;
        try {
          for await (const sse of _iterSSEMessages(response, controller)) {
            if (sse.event === "completion") {
              try {
                yield JSON.parse(sse.data);
              } catch (e2) {
                logger.error(`Could not parse message into JSON:`, sse.data);
                logger.error(`From chunk:`, sse.raw);
                throw e2;
              }
            }
            if (sse.event === "message_start" || sse.event === "message_delta" || sse.event === "message_stop" || sse.event === "content_block_start" || sse.event === "content_block_delta" || sse.event === "content_block_stop") {
              try {
                yield JSON.parse(sse.data);
              } catch (e2) {
                logger.error(`Could not parse message into JSON:`, sse.data);
                logger.error(`From chunk:`, sse.raw);
                throw e2;
              }
            }
            if (sse.event === "ping") {
              continue;
            }
            if (sse.event === "error") {
              throw new APIError(undefined, safeJSON(sse.data) ?? sse.data, undefined, response.headers);
            }
          }
          done = true;
        } catch (e2) {
          if (isAbortError(e2))
            return;
          throw e2;
        } finally {
          if (!done)
            controller.abort();
        }
      }
      return new Stream(iterator2, controller, client);
    }
    static fromReadableStream(readableStream, controller, client) {
      let consumed = false;
      async function* iterLines() {
        const lineDecoder = new LineDecoder;
        const iter = ReadableStreamToAsyncIterable(readableStream);
        for await (const chunk of iter) {
          for (const line of lineDecoder.decode(chunk)) {
            yield line;
          }
        }
        for (const line of lineDecoder.flush()) {
          yield line;
        }
      }
      async function* iterator2() {
        if (consumed) {
          throw new AnthropicError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        }
        consumed = true;
        let done = false;
        try {
          for await (const line of iterLines()) {
            if (done)
              continue;
            if (line)
              yield JSON.parse(line);
          }
          done = true;
        } catch (e2) {
          if (isAbortError(e2))
            return;
          throw e2;
        } finally {
          if (!done)
            controller.abort();
        }
      }
      return new Stream(iterator2, controller, client);
    }
    [(_Stream_client = new WeakMap, Symbol.asyncIterator)]() {
      return this.iterator();
    }
    tee() {
      const left = [];
      const right = [];
      const iterator2 = this.iterator();
      const teeIterator = (queue) => {
        return {
          next: () => {
            if (queue.length === 0) {
              const result = iterator2.next();
              left.push(result);
              right.push(result);
            }
            return queue.shift();
          }
        };
      };
      return [
        new Stream(() => teeIterator(left), this.controller, __classPrivateFieldGet(this, _Stream_client, "f")),
        new Stream(() => teeIterator(right), this.controller, __classPrivateFieldGet(this, _Stream_client, "f"))
      ];
    }
    toReadableStream() {
      const self = this;
      let iter;
      return makeReadableStream({
        async start() {
          iter = self[Symbol.asyncIterator]();
        },
        async pull(ctrl) {
          try {
            const { value, done } = await iter.next();
            if (done)
              return ctrl.close();
            const bytes = encodeUTF8(JSON.stringify(value) + `
`);
            ctrl.enqueue(bytes);
          } catch (err) {
            ctrl.error(err);
          }
        },
        async cancel() {
          await iter.return?.();
        }
      });
    }
  };
});

// node_modules/@anthropic-ai/sdk/internal/parse.mjs
async function defaultParseResponse(client, props) {
  const { response, requestLogID, retryOfRequestLogID, startTime } = props;
  const body = await (async () => {
    if (props.options.stream) {
      loggerFor(client).debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller);
      }
      return Stream.fromSSEResponse(response, props.controller);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const mediaType = contentType?.split(";")[0]?.trim();
    const isJSON = mediaType?.includes("application/json") || mediaType?.endsWith("+json");
    if (isJSON) {
      const contentLength = response.headers.get("content-length");
      if (contentLength === "0") {
        return;
      }
      const json = await response.json();
      return addRequestID(json, response);
    }
    const text = await response.text();
    return text;
  })();
  loggerFor(client).debug(`[${requestLogID}] response parsed`, formatRequestDetails({
    retryOfRequestLogID,
    url: response.url,
    status: response.status,
    body,
    durationMs: Date.now() - startTime
  }));
  return body;
}
function addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("request-id"),
    enumerable: false
  });
}
var init_parse = __esm(() => {
  init_streaming();
  init_log();
});

// node_modules/@anthropic-ai/sdk/core/api-promise.mjs
var _APIPromise_client, APIPromise;
var init_api_promise = __esm(() => {
  init_tslib();
  init_parse();
  APIPromise = class APIPromise extends Promise {
    constructor(client, responsePromise, parseResponse = defaultParseResponse) {
      super((resolve3) => {
        resolve3(null);
      });
      this.responsePromise = responsePromise;
      this.parseResponse = parseResponse;
      _APIPromise_client.set(this, undefined);
      __classPrivateFieldSet(this, _APIPromise_client, client, "f");
    }
    _thenUnwrap(transform) {
      return new APIPromise(__classPrivateFieldGet(this, _APIPromise_client, "f"), this.responsePromise, async (client, props) => addRequestID(transform(await this.parseResponse(client, props), props), props.response));
    }
    asResponse() {
      return this.responsePromise.then((p) => p.response);
    }
    async withResponse() {
      const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
      return { data, response, request_id: response.headers.get("request-id") };
    }
    parse() {
      if (!this.parsedPromise) {
        this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(__classPrivateFieldGet(this, _APIPromise_client, "f"), data));
      }
      return this.parsedPromise;
    }
    then(onfulfilled, onrejected) {
      return this.parse().then(onfulfilled, onrejected);
    }
    catch(onrejected) {
      return this.parse().catch(onrejected);
    }
    finally(onfinally) {
      return this.parse().finally(onfinally);
    }
  };
  _APIPromise_client = new WeakMap;
});

// node_modules/@anthropic-ai/sdk/core/pagination.mjs
var _AbstractPage_client, AbstractPage, PagePromise, Page, PageCursor;
var init_pagination = __esm(() => {
  init_tslib();
  init_error();
  init_parse();
  init_api_promise();
  init_values();
  AbstractPage = class AbstractPage {
    constructor(client, response, body, options) {
      _AbstractPage_client.set(this, undefined);
      __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
      this.options = options;
      this.response = response;
      this.body = body;
    }
    hasNextPage() {
      const items = this.getPaginatedItems();
      if (!items.length)
        return false;
      return this.nextPageRequestOptions() != null;
    }
    async getNextPage() {
      const nextOptions = this.nextPageRequestOptions();
      if (!nextOptions) {
        throw new AnthropicError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
      }
      return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
    }
    async* iterPages() {
      let page = this;
      yield page;
      while (page.hasNextPage()) {
        page = await page.getNextPage();
        yield page;
      }
    }
    async* [(_AbstractPage_client = new WeakMap, Symbol.asyncIterator)]() {
      for await (const page of this.iterPages()) {
        for (const item of page.getPaginatedItems()) {
          yield item;
        }
      }
    }
  };
  PagePromise = class PagePromise extends APIPromise {
    constructor(client, request2, Page) {
      super(client, request2, async (client2, props) => new Page(client2, props.response, await defaultParseResponse(client2, props), props.options));
    }
    async* [Symbol.asyncIterator]() {
      const page = await this;
      for await (const item of page) {
        yield item;
      }
    }
  };
  Page = class Page extends AbstractPage {
    constructor(client, response, body, options) {
      super(client, response, body, options);
      this.data = body.data || [];
      this.has_more = body.has_more || false;
      this.first_id = body.first_id || null;
      this.last_id = body.last_id || null;
    }
    getPaginatedItems() {
      return this.data ?? [];
    }
    hasNextPage() {
      if (this.has_more === false) {
        return false;
      }
      return super.hasNextPage();
    }
    nextPageRequestOptions() {
      if (this.options.query?.["before_id"]) {
        const first_id = this.first_id;
        if (!first_id) {
          return null;
        }
        return {
          ...this.options,
          query: {
            ...maybeObj(this.options.query),
            before_id: first_id
          }
        };
      }
      const cursor = this.last_id;
      if (!cursor) {
        return null;
      }
      return {
        ...this.options,
        query: {
          ...maybeObj(this.options.query),
          after_id: cursor
        }
      };
    }
  };
  PageCursor = class PageCursor extends AbstractPage {
    constructor(client, response, body, options) {
      super(client, response, body, options);
      this.data = body.data || [];
      this.has_more = body.has_more || false;
      this.next_page = body.next_page || null;
    }
    getPaginatedItems() {
      return this.data ?? [];
    }
    hasNextPage() {
      if (this.has_more === false) {
        return false;
      }
      return super.hasNextPage();
    }
    nextPageRequestOptions() {
      const cursor = this.next_page;
      if (!cursor) {
        return null;
      }
      return {
        ...this.options,
        query: {
          ...maybeObj(this.options.query),
          page: cursor
        }
      };
    }
  };
});

// node_modules/@anthropic-ai/sdk/internal/uploads.mjs
function makeFile(fileBits, fileName, options) {
  checkFileSupport();
  return new File(fileBits, fileName ?? "unknown_file", options);
}
function getName(value, stripPath) {
  const val = typeof value === "object" && value !== null && (("name" in value) && value.name && String(value.name) || ("url" in value) && value.url && String(value.url) || ("filename" in value) && value.filename && String(value.filename) || ("path" in value) && value.path && String(value.path)) || "";
  return stripPath ? val.split(/[\\/]/).pop() || undefined : val;
}
function supportsFormData(fetchObject) {
  const fetch2 = typeof fetchObject === "function" ? fetchObject : fetchObject.fetch;
  const cached = supportsFormDataMap.get(fetch2);
  if (cached)
    return cached;
  const promise = (async () => {
    try {
      const FetchResponse = "Response" in fetch2 ? fetch2.Response : (await fetch2("data:,")).constructor;
      const data = new FormData;
      if (data.toString() === await new FetchResponse(data).text()) {
        return false;
      }
      return true;
    } catch {
      return true;
    }
  })();
  supportsFormDataMap.set(fetch2, promise);
  return promise;
}
var checkFileSupport = () => {
  if (typeof File === "undefined") {
    const { process: process2 } = globalThis;
    const isOldNode = typeof process2?.versions?.node === "string" && parseInt(process2.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
}, isAsyncIterable = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function", multipartFormRequestOptions = async (opts, fetch2, stripFilenames = true) => {
  return { ...opts, body: await createForm(opts.body, fetch2, stripFilenames) };
}, supportsFormDataMap, createForm = async (body, fetch2, stripFilenames = true) => {
  if (!await supportsFormData(fetch2)) {
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  }
  const form = new FormData;
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value, stripFilenames)));
  return form;
}, isNamedBlob = (value) => value instanceof Blob && ("name" in value), addFormValue = async (form, key, value, stripFilenames) => {
  if (value === undefined)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (value instanceof Response) {
    let options = {};
    const contentType = value.headers.get("Content-Type");
    if (contentType) {
      options = { type: contentType };
    }
    form.append(key, makeFile([await value.blob()], getName(value, stripFilenames), options));
  } else if (isAsyncIterable(value)) {
    form.append(key, makeFile([await new Response(ReadableStreamFrom(value)).blob()], getName(value, stripFilenames)));
  } else if (isNamedBlob(value)) {
    form.append(key, makeFile([value], getName(value, stripFilenames), { type: value.type }));
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry, stripFilenames)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop, stripFilenames)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};
var init_uploads = __esm(() => {
  supportsFormDataMap = /* @__PURE__ */ new WeakMap;
});

// node_modules/@anthropic-ai/sdk/internal/to-file.mjs
async function toFile(value, name, options) {
  checkFileSupport();
  value = await value;
  name || (name = getName(value, true));
  if (isFileLike(value)) {
    if (value instanceof File && name == null && options == null) {
      return value;
    }
    return makeFile([await value.arrayBuffer()], name ?? value.name, {
      type: value.type,
      lastModified: value.lastModified,
      ...options
    });
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop());
    return makeFile(await getBytes(blob), name, options);
  }
  const parts = await getBytes(value);
  if (!options?.type) {
    const type = parts.find((part) => typeof part === "object" && ("type" in part) && part.type);
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return makeFile(parts, name, options);
}
async function getBytes(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable(value)) {
    for await (const chunk of value) {
      parts.push(...await getBytes(chunk));
    }
  } else {
    const constructor = value?.constructor?.name;
    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  if (typeof value !== "object" || value === null)
    return "";
  const props = Object.getOwnPropertyNames(value);
  return `; props: [${props.map((p) => `"${p}"`).join(", ")}]`;
}
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function", isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value), isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var init_to_file = __esm(() => {
  init_uploads();
  init_uploads();
});

// node_modules/@anthropic-ai/sdk/core/uploads.mjs
var init_uploads2 = __esm(() => {
  init_to_file();
});

// node_modules/@anthropic-ai/sdk/resources/shared.mjs
var init_shared = () => {};

// node_modules/@anthropic-ai/sdk/core/resource.mjs
class APIResource {
  constructor(client) {
    this._client = client;
  }
}

// node_modules/@anthropic-ai/sdk/internal/headers.mjs
function* iterateHeaders(headers) {
  if (!headers)
    return;
  if (brand_privateNullableHeaders in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name of nulls) {
      yield [name, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isReadonlyArray(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers ?? {});
  }
  for (let row of iter) {
    const name = row[0];
    if (typeof name !== "string")
      throw new TypeError("expected header name to be a string");
    const values = isReadonlyArray(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === undefined)
        continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name, null];
      }
      yield [name, value];
    }
  }
}
var brand_privateNullableHeaders, buildHeaders = (newHeaders) => {
  const targetHeaders = new Headers;
  const nullHeaders = new Set;
  for (const headers of newHeaders) {
    const seenHeaders = new Set;
    for (const [name, value] of iterateHeaders(headers)) {
      const lowerName = name.toLowerCase();
      if (!seenHeaders.has(lowerName)) {
        targetHeaders.delete(name);
        seenHeaders.add(lowerName);
      }
      if (value === null) {
        targetHeaders.delete(name);
        nullHeaders.add(lowerName);
      } else {
        targetHeaders.append(name, value);
        nullHeaders.delete(lowerName);
      }
    }
  }
  return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };
};
var init_headers = __esm(() => {
  init_values();
  brand_privateNullableHeaders = Symbol.for("brand.privateNullableHeaders");
});

// node_modules/@anthropic-ai/sdk/lib/stainless-helper-header.mjs
function wasCreatedByStainlessHelper(value) {
  return typeof value === "object" && value !== null && SDK_HELPER_SYMBOL in value;
}
function collectStainlessHelpers(tools, messages) {
  const helpers = new Set;
  if (tools) {
    for (const tool of tools) {
      if (wasCreatedByStainlessHelper(tool)) {
        helpers.add(tool[SDK_HELPER_SYMBOL]);
      }
    }
  }
  if (messages) {
    for (const message of messages) {
      if (wasCreatedByStainlessHelper(message)) {
        helpers.add(message[SDK_HELPER_SYMBOL]);
      }
      if (Array.isArray(message.content)) {
        for (const block of message.content) {
          if (wasCreatedByStainlessHelper(block)) {
            helpers.add(block[SDK_HELPER_SYMBOL]);
          }
        }
      }
    }
  }
  return Array.from(helpers);
}
function stainlessHelperHeader(tools, messages) {
  const helpers = collectStainlessHelpers(tools, messages);
  if (helpers.length === 0)
    return {};
  return { "x-stainless-helper": helpers.join(", ") };
}
function stainlessHelperHeaderFromFile(file) {
  if (wasCreatedByStainlessHelper(file)) {
    return { "x-stainless-helper": file[SDK_HELPER_SYMBOL] };
  }
  return {};
}
var SDK_HELPER_SYMBOL;
var init_stainless_helper_header = __esm(() => {
  SDK_HELPER_SYMBOL = Symbol("anthropic.sdk.stainlessHelper");
});

// node_modules/@anthropic-ai/sdk/internal/utils/path.mjs
function encodeURIPath(str) {
  return str.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
var EMPTY, createPathTagFunction = (pathEncoder = encodeURIPath) => function path(statics, ...params) {
  if (statics.length === 1)
    return statics[0];
  let postPath = false;
  const invalidSegments = [];
  const path2 = statics.reduce((previousValue, currentValue, index) => {
    if (/[?#]/.test(currentValue)) {
      postPath = true;
    }
    const value = params[index];
    let encoded = (postPath ? encodeURIComponent : pathEncoder)("" + value);
    if (index !== params.length && (value == null || typeof value === "object" && value.toString === Object.getPrototypeOf(Object.getPrototypeOf(value.hasOwnProperty ?? EMPTY) ?? EMPTY)?.toString)) {
      encoded = value + "";
      invalidSegments.push({
        start: previousValue.length + currentValue.length,
        length: encoded.length,
        error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`
      });
    }
    return previousValue + currentValue + (index === params.length ? "" : encoded);
  }, "");
  const pathOnly = path2.split(/[?#]/, 1)[0];
  const invalidSegmentPattern = /(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi;
  let match;
  while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {
    invalidSegments.push({
      start: match.index,
      length: match[0].length,
      error: `Value "${match[0]}" can't be safely passed as a path parameter`
    });
  }
  invalidSegments.sort((a3, b3) => a3.start - b3.start);
  if (invalidSegments.length > 0) {
    let lastEnd = 0;
    const underline = invalidSegments.reduce((acc, segment) => {
      const spaces = " ".repeat(segment.start - lastEnd);
      const arrows = "^".repeat(segment.length);
      lastEnd = segment.start + segment.length;
      return acc + spaces + arrows;
    }, "");
    throw new AnthropicError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e2) => e2.error).join(`
`)}
${path2}
${underline}`);
  }
  return path2;
}, path;
var init_path = __esm(() => {
  init_error();
  EMPTY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));
  path = /* @__PURE__ */ createPathTagFunction(encodeURIPath);
});

// node_modules/@anthropic-ai/sdk/resources/beta/files.mjs
var Files;
var init_files = __esm(() => {
  init_pagination();
  init_headers();
  init_stainless_helper_header();
  init_uploads();
  init_path();
  Files = class Files extends APIResource {
    list(params = {}, options) {
      const { betas, ...query } = params ?? {};
      return this._client.getAPIList("/v1/files", Page, {
        query,
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "files-api-2025-04-14"].toString() },
          options?.headers
        ])
      });
    }
    delete(fileID, params = {}, options) {
      const { betas } = params ?? {};
      return this._client.delete(path`/v1/files/${fileID}`, {
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "files-api-2025-04-14"].toString() },
          options?.headers
        ])
      });
    }
    download(fileID, params = {}, options) {
      const { betas } = params ?? {};
      return this._client.get(path`/v1/files/${fileID}/content`, {
        ...options,
        headers: buildHeaders([
          {
            "anthropic-beta": [...betas ?? [], "files-api-2025-04-14"].toString(),
            Accept: "application/binary"
          },
          options?.headers
        ]),
        __binaryResponse: true
      });
    }
    retrieveMetadata(fileID, params = {}, options) {
      const { betas } = params ?? {};
      return this._client.get(path`/v1/files/${fileID}`, {
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "files-api-2025-04-14"].toString() },
          options?.headers
        ])
      });
    }
    upload(params, options) {
      const { betas, ...body } = params;
      return this._client.post("/v1/files", multipartFormRequestOptions({
        body,
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "files-api-2025-04-14"].toString() },
          stainlessHelperHeaderFromFile(body.file),
          options?.headers
        ])
      }, this._client));
    }
  };
});

// node_modules/@anthropic-ai/sdk/resources/beta/models.mjs
var Models;
var init_models = __esm(() => {
  init_pagination();
  init_headers();
  init_path();
  Models = class Models extends APIResource {
    retrieve(modelID, params = {}, options) {
      const { betas } = params ?? {};
      return this._client.get(path`/v1/models/${modelID}?beta=true`, {
        ...options,
        headers: buildHeaders([
          { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : undefined },
          options?.headers
        ])
      });
    }
    list(params = {}, options) {
      const { betas, ...query } = params ?? {};
      return this._client.getAPIList("/v1/models?beta=true", Page, {
        query,
        ...options,
        headers: buildHeaders([
          { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : undefined },
          options?.headers
        ])
      });
    }
  };
});

// node_modules/@anthropic-ai/sdk/error.mjs
var init_error2 = __esm(() => {
  init_error();
});

// node_modules/@anthropic-ai/sdk/internal/constants.mjs
var MODEL_NONSTREAMING_TOKENS;
var init_constants = __esm(() => {
  MODEL_NONSTREAMING_TOKENS = {
    "claude-opus-4-20250514": 8192,
    "claude-opus-4-0": 8192,
    "claude-4-opus-20250514": 8192,
    "anthropic.claude-opus-4-20250514-v1:0": 8192,
    "claude-opus-4@20250514": 8192,
    "claude-opus-4-1-20250805": 8192,
    "anthropic.claude-opus-4-1-20250805-v1:0": 8192,
    "claude-opus-4-1@20250805": 8192
  };
});

// node_modules/@anthropic-ai/sdk/lib/beta-parser.mjs
function getOutputFormat(params) {
  return params?.output_format ?? params?.output_config?.format;
}
function maybeParseBetaMessage(message, params, opts) {
  const outputFormat = getOutputFormat(params);
  if (!params || !("parse" in (outputFormat ?? {}))) {
    return {
      ...message,
      content: message.content.map((block) => {
        if (block.type === "text") {
          const parsedBlock = Object.defineProperty({ ...block }, "parsed_output", {
            value: null,
            enumerable: false
          });
          return Object.defineProperty(parsedBlock, "parsed", {
            get() {
              opts.logger.warn("The `parsed` property on `text` blocks is deprecated, please use `parsed_output` instead.");
              return null;
            },
            enumerable: false
          });
        }
        return block;
      }),
      parsed_output: null
    };
  }
  return parseBetaMessage(message, params, opts);
}
function parseBetaMessage(message, params, opts) {
  let firstParsedOutput = null;
  const content = message.content.map((block) => {
    if (block.type === "text") {
      const parsedOutput = parseBetaOutputFormat(params, block.text);
      if (firstParsedOutput === null) {
        firstParsedOutput = parsedOutput;
      }
      const parsedBlock = Object.defineProperty({ ...block }, "parsed_output", {
        value: parsedOutput,
        enumerable: false
      });
      return Object.defineProperty(parsedBlock, "parsed", {
        get() {
          opts.logger.warn("The `parsed` property on `text` blocks is deprecated, please use `parsed_output` instead.");
          return parsedOutput;
        },
        enumerable: false
      });
    }
    return block;
  });
  return {
    ...message,
    content,
    parsed_output: firstParsedOutput
  };
}
function parseBetaOutputFormat(params, content) {
  const outputFormat = getOutputFormat(params);
  if (outputFormat?.type !== "json_schema") {
    return null;
  }
  try {
    if ("parse" in outputFormat) {
      return outputFormat.parse(content);
    }
    return JSON.parse(content);
  } catch (error2) {
    throw new AnthropicError(`Failed to parse structured output: ${error2}`);
  }
}
var init_beta_parser = __esm(() => {
  init_error();
});

// node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs
var tokenize = (input) => {
  let current = 0;
  let tokens = [];
  while (current < input.length) {
    let char = input[current];
    if (char === "\\") {
      current++;
      continue;
    }
    if (char === "{") {
      tokens.push({
        type: "brace",
        value: "{"
      });
      current++;
      continue;
    }
    if (char === "}") {
      tokens.push({
        type: "brace",
        value: "}"
      });
      current++;
      continue;
    }
    if (char === "[") {
      tokens.push({
        type: "paren",
        value: "["
      });
      current++;
      continue;
    }
    if (char === "]") {
      tokens.push({
        type: "paren",
        value: "]"
      });
      current++;
      continue;
    }
    if (char === ":") {
      tokens.push({
        type: "separator",
        value: ":"
      });
      current++;
      continue;
    }
    if (char === ",") {
      tokens.push({
        type: "delimiter",
        value: ","
      });
      current++;
      continue;
    }
    if (char === '"') {
      let value = "";
      let danglingQuote = false;
      char = input[++current];
      while (char !== '"') {
        if (current === input.length) {
          danglingQuote = true;
          break;
        }
        if (char === "\\") {
          current++;
          if (current === input.length) {
            danglingQuote = true;
            break;
          }
          value += char + input[current];
          char = input[++current];
        } else {
          value += char;
          char = input[++current];
        }
      }
      char = input[++current];
      if (!danglingQuote) {
        tokens.push({
          type: "string",
          value
        });
      }
      continue;
    }
    let WHITESPACE = /\s/;
    if (char && WHITESPACE.test(char)) {
      current++;
      continue;
    }
    let NUMBERS = /[0-9]/;
    if (char && NUMBERS.test(char) || char === "-" || char === ".") {
      let value = "";
      if (char === "-") {
        value += char;
        char = input[++current];
      }
      while (char && NUMBERS.test(char) || char === ".") {
        value += char;
        char = input[++current];
      }
      tokens.push({
        type: "number",
        value
      });
      continue;
    }
    let LETTERS = /[a-z]/i;
    if (char && LETTERS.test(char)) {
      let value = "";
      while (char && LETTERS.test(char)) {
        if (current === input.length) {
          break;
        }
        value += char;
        char = input[++current];
      }
      if (value == "true" || value == "false" || value === "null") {
        tokens.push({
          type: "name",
          value
        });
      } else {
        current++;
        continue;
      }
      continue;
    }
    current++;
  }
  return tokens;
}, strip = (tokens) => {
  if (tokens.length === 0) {
    return tokens;
  }
  let lastToken = tokens[tokens.length - 1];
  switch (lastToken.type) {
    case "separator":
      tokens = tokens.slice(0, tokens.length - 1);
      return strip(tokens);
      break;
    case "number":
      let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];
      if (lastCharacterOfLastToken === "." || lastCharacterOfLastToken === "-") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      }
    case "string":
      let tokenBeforeTheLastToken = tokens[tokens.length - 2];
      if (tokenBeforeTheLastToken?.type === "delimiter") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      } else if (tokenBeforeTheLastToken?.type === "brace" && tokenBeforeTheLastToken.value === "{") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      }
      break;
    case "delimiter":
      tokens = tokens.slice(0, tokens.length - 1);
      return strip(tokens);
      break;
  }
  return tokens;
}, unstrip = (tokens) => {
  let tail = [];
  tokens.map((token) => {
    if (token.type === "brace") {
      if (token.value === "{") {
        tail.push("}");
      } else {
        tail.splice(tail.lastIndexOf("}"), 1);
      }
    }
    if (token.type === "paren") {
      if (token.value === "[") {
        tail.push("]");
      } else {
        tail.splice(tail.lastIndexOf("]"), 1);
      }
    }
  });
  if (tail.length > 0) {
    tail.reverse().map((item) => {
      if (item === "}") {
        tokens.push({
          type: "brace",
          value: "}"
        });
      } else if (item === "]") {
        tokens.push({
          type: "paren",
          value: "]"
        });
      }
    });
  }
  return tokens;
}, generate = (tokens) => {
  let output = "";
  tokens.map((token) => {
    switch (token.type) {
      case "string":
        output += '"' + token.value + '"';
        break;
      default:
        output += token.value;
        break;
    }
  });
  return output;
}, partialParse = (input) => JSON.parse(generate(unstrip(strip(tokenize(input)))));
var init_parser2 = () => {};

// node_modules/@anthropic-ai/sdk/streaming.mjs
var init_streaming2 = __esm(() => {
  init_streaming();
});

// node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs
function tracksToolInput(content) {
  return content.type === "tool_use" || content.type === "server_tool_use" || content.type === "mcp_tool_use";
}
function checkNever(x2) {}
var _BetaMessageStream_instances, _BetaMessageStream_currentMessageSnapshot, _BetaMessageStream_params, _BetaMessageStream_connectedPromise, _BetaMessageStream_resolveConnectedPromise, _BetaMessageStream_rejectConnectedPromise, _BetaMessageStream_endPromise, _BetaMessageStream_resolveEndPromise, _BetaMessageStream_rejectEndPromise, _BetaMessageStream_listeners, _BetaMessageStream_ended, _BetaMessageStream_errored, _BetaMessageStream_aborted, _BetaMessageStream_catchingPromiseCreated, _BetaMessageStream_response, _BetaMessageStream_request_id, _BetaMessageStream_logger, _BetaMessageStream_getFinalMessage, _BetaMessageStream_getFinalText, _BetaMessageStream_handleError, _BetaMessageStream_beginRequest, _BetaMessageStream_addStreamEvent, _BetaMessageStream_endRequest, _BetaMessageStream_accumulateMessage, JSON_BUF_PROPERTY = "__json_buf", BetaMessageStream;
var init_BetaMessageStream = __esm(() => {
  init_tslib();
  init_parser2();
  init_error2();
  init_streaming2();
  init_beta_parser();
  BetaMessageStream = class BetaMessageStream {
    constructor(params, opts) {
      _BetaMessageStream_instances.add(this);
      this.messages = [];
      this.receivedMessages = [];
      _BetaMessageStream_currentMessageSnapshot.set(this, undefined);
      _BetaMessageStream_params.set(this, null);
      this.controller = new AbortController;
      _BetaMessageStream_connectedPromise.set(this, undefined);
      _BetaMessageStream_resolveConnectedPromise.set(this, () => {});
      _BetaMessageStream_rejectConnectedPromise.set(this, () => {});
      _BetaMessageStream_endPromise.set(this, undefined);
      _BetaMessageStream_resolveEndPromise.set(this, () => {});
      _BetaMessageStream_rejectEndPromise.set(this, () => {});
      _BetaMessageStream_listeners.set(this, {});
      _BetaMessageStream_ended.set(this, false);
      _BetaMessageStream_errored.set(this, false);
      _BetaMessageStream_aborted.set(this, false);
      _BetaMessageStream_catchingPromiseCreated.set(this, false);
      _BetaMessageStream_response.set(this, undefined);
      _BetaMessageStream_request_id.set(this, undefined);
      _BetaMessageStream_logger.set(this, undefined);
      _BetaMessageStream_handleError.set(this, (error2) => {
        __classPrivateFieldSet(this, _BetaMessageStream_errored, true, "f");
        if (isAbortError(error2)) {
          error2 = new APIUserAbortError;
        }
        if (error2 instanceof APIUserAbortError) {
          __classPrivateFieldSet(this, _BetaMessageStream_aborted, true, "f");
          return this._emit("abort", error2);
        }
        if (error2 instanceof AnthropicError) {
          return this._emit("error", error2);
        }
        if (error2 instanceof Error) {
          const anthropicError = new AnthropicError(error2.message);
          anthropicError.cause = error2;
          return this._emit("error", anthropicError);
        }
        return this._emit("error", new AnthropicError(String(error2)));
      });
      __classPrivateFieldSet(this, _BetaMessageStream_connectedPromise, new Promise((resolve3, reject) => {
        __classPrivateFieldSet(this, _BetaMessageStream_resolveConnectedPromise, resolve3, "f");
        __classPrivateFieldSet(this, _BetaMessageStream_rejectConnectedPromise, reject, "f");
      }), "f");
      __classPrivateFieldSet(this, _BetaMessageStream_endPromise, new Promise((resolve3, reject) => {
        __classPrivateFieldSet(this, _BetaMessageStream_resolveEndPromise, resolve3, "f");
        __classPrivateFieldSet(this, _BetaMessageStream_rejectEndPromise, reject, "f");
      }), "f");
      __classPrivateFieldGet(this, _BetaMessageStream_connectedPromise, "f").catch(() => {});
      __classPrivateFieldGet(this, _BetaMessageStream_endPromise, "f").catch(() => {});
      __classPrivateFieldSet(this, _BetaMessageStream_params, params, "f");
      __classPrivateFieldSet(this, _BetaMessageStream_logger, opts?.logger ?? console, "f");
    }
    get response() {
      return __classPrivateFieldGet(this, _BetaMessageStream_response, "f");
    }
    get request_id() {
      return __classPrivateFieldGet(this, _BetaMessageStream_request_id, "f");
    }
    async withResponse() {
      __classPrivateFieldSet(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
      const response = await __classPrivateFieldGet(this, _BetaMessageStream_connectedPromise, "f");
      if (!response) {
        throw new Error("Could not resolve a `Response` object");
      }
      return {
        data: this,
        response,
        request_id: response.headers.get("request-id")
      };
    }
    static fromReadableStream(stream) {
      const runner = new BetaMessageStream(null);
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    static createMessage(messages, params, options, { logger } = {}) {
      const runner = new BetaMessageStream(params, { logger });
      for (const message of params.messages) {
        runner._addMessageParam(message);
      }
      __classPrivateFieldSet(runner, _BetaMessageStream_params, { ...params, stream: true }, "f");
      runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
      return runner;
    }
    _run(executor) {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet(this, _BetaMessageStream_handleError, "f"));
    }
    _addMessageParam(message) {
      this.messages.push(message);
    }
    _addMessage(message, emit = true) {
      this.receivedMessages.push(message);
      if (emit) {
        this._emit("message", message);
      }
    }
    async _createMessage(messages, params, options) {
      const signal = options?.signal;
      let abortHandler;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        abortHandler = this.controller.abort.bind(this.controller);
        signal.addEventListener("abort", abortHandler);
      }
      try {
        __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
        const { response, data: stream } = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
        this._connected(response);
        for await (const event of stream) {
          __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
        }
        if (stream.controller.signal?.aborted) {
          throw new APIUserAbortError;
        }
        __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
      } finally {
        if (signal && abortHandler) {
          signal.removeEventListener("abort", abortHandler);
        }
      }
    }
    _connected(response) {
      if (this.ended)
        return;
      __classPrivateFieldSet(this, _BetaMessageStream_response, response, "f");
      __classPrivateFieldSet(this, _BetaMessageStream_request_id, response?.headers.get("request-id"), "f");
      __classPrivateFieldGet(this, _BetaMessageStream_resolveConnectedPromise, "f").call(this, response);
      this._emit("connect");
    }
    get ended() {
      return __classPrivateFieldGet(this, _BetaMessageStream_ended, "f");
    }
    get errored() {
      return __classPrivateFieldGet(this, _BetaMessageStream_errored, "f");
    }
    get aborted() {
      return __classPrivateFieldGet(this, _BetaMessageStream_aborted, "f");
    }
    abort() {
      this.controller.abort();
    }
    on(event, listener) {
      const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event] = []);
      listeners.push({ listener });
      return this;
    }
    off(event, listener) {
      const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event];
      if (!listeners)
        return this;
      const index = listeners.findIndex((l2) => l2.listener === listener);
      if (index >= 0)
        listeners.splice(index, 1);
      return this;
    }
    once(event, listener) {
      const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event] = []);
      listeners.push({ listener, once: true });
      return this;
    }
    emitted(event) {
      return new Promise((resolve3, reject) => {
        __classPrivateFieldSet(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
        if (event !== "error")
          this.once("error", reject);
        this.once(event, resolve3);
      });
    }
    async done() {
      __classPrivateFieldSet(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
      await __classPrivateFieldGet(this, _BetaMessageStream_endPromise, "f");
    }
    get currentMessage() {
      return __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, "f");
    }
    async finalMessage() {
      await this.done();
      return __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this);
    }
    async finalText() {
      await this.done();
      return __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalText).call(this);
    }
    _emit(event, ...args) {
      if (__classPrivateFieldGet(this, _BetaMessageStream_ended, "f"))
        return;
      if (event === "end") {
        __classPrivateFieldSet(this, _BetaMessageStream_ended, true, "f");
        __classPrivateFieldGet(this, _BetaMessageStream_resolveEndPromise, "f").call(this);
      }
      const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event];
      if (listeners) {
        __classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event] = listeners.filter((l2) => !l2.once);
        listeners.forEach(({ listener }) => listener(...args));
      }
      if (event === "abort") {
        const error2 = args[0];
        if (!__classPrivateFieldGet(this, _BetaMessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
          Promise.reject(error2);
        }
        __classPrivateFieldGet(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error2);
        __classPrivateFieldGet(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error2);
        this._emit("end");
        return;
      }
      if (event === "error") {
        const error2 = args[0];
        if (!__classPrivateFieldGet(this, _BetaMessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
          Promise.reject(error2);
        }
        __classPrivateFieldGet(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error2);
        __classPrivateFieldGet(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error2);
        this._emit("end");
      }
    }
    _emitFinal() {
      const finalMessage = this.receivedMessages.at(-1);
      if (finalMessage) {
        this._emit("finalMessage", __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this));
      }
    }
    async _fromReadableStream(readableStream, options) {
      const signal = options?.signal;
      let abortHandler;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        abortHandler = this.controller.abort.bind(this.controller);
        signal.addEventListener("abort", abortHandler);
      }
      try {
        __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
        this._connected(null);
        const stream = Stream.fromReadableStream(readableStream, this.controller);
        for await (const event of stream) {
          __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
        }
        if (stream.controller.signal?.aborted) {
          throw new APIUserAbortError;
        }
        __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
      } finally {
        if (signal && abortHandler) {
          signal.removeEventListener("abort", abortHandler);
        }
      }
    }
    [(_BetaMessageStream_currentMessageSnapshot = new WeakMap, _BetaMessageStream_params = new WeakMap, _BetaMessageStream_connectedPromise = new WeakMap, _BetaMessageStream_resolveConnectedPromise = new WeakMap, _BetaMessageStream_rejectConnectedPromise = new WeakMap, _BetaMessageStream_endPromise = new WeakMap, _BetaMessageStream_resolveEndPromise = new WeakMap, _BetaMessageStream_rejectEndPromise = new WeakMap, _BetaMessageStream_listeners = new WeakMap, _BetaMessageStream_ended = new WeakMap, _BetaMessageStream_errored = new WeakMap, _BetaMessageStream_aborted = new WeakMap, _BetaMessageStream_catchingPromiseCreated = new WeakMap, _BetaMessageStream_response = new WeakMap, _BetaMessageStream_request_id = new WeakMap, _BetaMessageStream_logger = new WeakMap, _BetaMessageStream_handleError = new WeakMap, _BetaMessageStream_instances = new WeakSet, _BetaMessageStream_getFinalMessage = function _BetaMessageStream_getFinalMessage2() {
      if (this.receivedMessages.length === 0) {
        throw new AnthropicError("stream ended without producing a Message with role=assistant");
      }
      return this.receivedMessages.at(-1);
    }, _BetaMessageStream_getFinalText = function _BetaMessageStream_getFinalText2() {
      if (this.receivedMessages.length === 0) {
        throw new AnthropicError("stream ended without producing a Message with role=assistant");
      }
      const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
      if (textBlocks.length === 0) {
        throw new AnthropicError("stream ended without producing a content block with type=text");
      }
      return textBlocks.join(" ");
    }, _BetaMessageStream_beginRequest = function _BetaMessageStream_beginRequest2() {
      if (this.ended)
        return;
      __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, undefined, "f");
    }, _BetaMessageStream_addStreamEvent = function _BetaMessageStream_addStreamEvent2(event) {
      if (this.ended)
        return;
      const messageSnapshot = __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_accumulateMessage).call(this, event);
      this._emit("streamEvent", event, messageSnapshot);
      switch (event.type) {
        case "content_block_delta": {
          const content = messageSnapshot.content.at(-1);
          switch (event.delta.type) {
            case "text_delta": {
              if (content.type === "text") {
                this._emit("text", event.delta.text, content.text || "");
              }
              break;
            }
            case "citations_delta": {
              if (content.type === "text") {
                this._emit("citation", event.delta.citation, content.citations ?? []);
              }
              break;
            }
            case "input_json_delta": {
              if (tracksToolInput(content) && content.input) {
                this._emit("inputJson", event.delta.partial_json, content.input);
              }
              break;
            }
            case "thinking_delta": {
              if (content.type === "thinking") {
                this._emit("thinking", event.delta.thinking, content.thinking);
              }
              break;
            }
            case "signature_delta": {
              if (content.type === "thinking") {
                this._emit("signature", content.signature);
              }
              break;
            }
            case "compaction_delta": {
              if (content.type === "compaction" && content.content) {
                this._emit("compaction", content.content);
              }
              break;
            }
            default:
              checkNever(event.delta);
          }
          break;
        }
        case "message_stop": {
          this._addMessageParam(messageSnapshot);
          this._addMessage(maybeParseBetaMessage(messageSnapshot, __classPrivateFieldGet(this, _BetaMessageStream_params, "f"), { logger: __classPrivateFieldGet(this, _BetaMessageStream_logger, "f") }), true);
          break;
        }
        case "content_block_stop": {
          this._emit("contentBlock", messageSnapshot.content.at(-1));
          break;
        }
        case "message_start": {
          __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, messageSnapshot, "f");
          break;
        }
        case "content_block_start":
        case "message_delta":
          break;
      }
    }, _BetaMessageStream_endRequest = function _BetaMessageStream_endRequest2() {
      if (this.ended) {
        throw new AnthropicError(`stream has ended, this shouldn't happen`);
      }
      const snapshot = __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, "f");
      if (!snapshot) {
        throw new AnthropicError(`request ended without sending any chunks`);
      }
      __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, undefined, "f");
      return maybeParseBetaMessage(snapshot, __classPrivateFieldGet(this, _BetaMessageStream_params, "f"), { logger: __classPrivateFieldGet(this, _BetaMessageStream_logger, "f") });
    }, _BetaMessageStream_accumulateMessage = function _BetaMessageStream_accumulateMessage2(event) {
      let snapshot = __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, "f");
      if (event.type === "message_start") {
        if (snapshot) {
          throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
        }
        return event.message;
      }
      if (!snapshot) {
        throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
      }
      switch (event.type) {
        case "message_stop":
          return snapshot;
        case "message_delta":
          snapshot.container = event.delta.container;
          snapshot.stop_reason = event.delta.stop_reason;
          snapshot.stop_sequence = event.delta.stop_sequence;
          snapshot.usage.output_tokens = event.usage.output_tokens;
          snapshot.context_management = event.context_management;
          if (event.usage.input_tokens != null) {
            snapshot.usage.input_tokens = event.usage.input_tokens;
          }
          if (event.usage.cache_creation_input_tokens != null) {
            snapshot.usage.cache_creation_input_tokens = event.usage.cache_creation_input_tokens;
          }
          if (event.usage.cache_read_input_tokens != null) {
            snapshot.usage.cache_read_input_tokens = event.usage.cache_read_input_tokens;
          }
          if (event.usage.server_tool_use != null) {
            snapshot.usage.server_tool_use = event.usage.server_tool_use;
          }
          if (event.usage.iterations != null) {
            snapshot.usage.iterations = event.usage.iterations;
          }
          return snapshot;
        case "content_block_start":
          snapshot.content.push(event.content_block);
          return snapshot;
        case "content_block_delta": {
          const snapshotContent = snapshot.content.at(event.index);
          switch (event.delta.type) {
            case "text_delta": {
              if (snapshotContent?.type === "text") {
                snapshot.content[event.index] = {
                  ...snapshotContent,
                  text: (snapshotContent.text || "") + event.delta.text
                };
              }
              break;
            }
            case "citations_delta": {
              if (snapshotContent?.type === "text") {
                snapshot.content[event.index] = {
                  ...snapshotContent,
                  citations: [...snapshotContent.citations ?? [], event.delta.citation]
                };
              }
              break;
            }
            case "input_json_delta": {
              if (snapshotContent && tracksToolInput(snapshotContent)) {
                let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || "";
                jsonBuf += event.delta.partial_json;
                const newContent = { ...snapshotContent };
                Object.defineProperty(newContent, JSON_BUF_PROPERTY, {
                  value: jsonBuf,
                  enumerable: false,
                  writable: true
                });
                if (jsonBuf) {
                  try {
                    newContent.input = partialParse(jsonBuf);
                  } catch (err) {
                    const error2 = new AnthropicError(`Unable to parse tool parameter JSON from model. Please retry your request or adjust your prompt. Error: ${err}. JSON: ${jsonBuf}`);
                    __classPrivateFieldGet(this, _BetaMessageStream_handleError, "f").call(this, error2);
                  }
                }
                snapshot.content[event.index] = newContent;
              }
              break;
            }
            case "thinking_delta": {
              if (snapshotContent?.type === "thinking") {
                snapshot.content[event.index] = {
                  ...snapshotContent,
                  thinking: snapshotContent.thinking + event.delta.thinking
                };
              }
              break;
            }
            case "signature_delta": {
              if (snapshotContent?.type === "thinking") {
                snapshot.content[event.index] = {
                  ...snapshotContent,
                  signature: event.delta.signature
                };
              }
              break;
            }
            case "compaction_delta": {
              if (snapshotContent?.type === "compaction") {
                snapshot.content[event.index] = {
                  ...snapshotContent,
                  content: (snapshotContent.content || "") + event.delta.content
                };
              }
              break;
            }
            default:
              checkNever(event.delta);
          }
          return snapshot;
        }
        case "content_block_stop":
          return snapshot;
      }
    }, Symbol.asyncIterator)]() {
      const pushQueue = [];
      const readQueue = [];
      let done = false;
      this.on("streamEvent", (event) => {
        const reader = readQueue.shift();
        if (reader) {
          reader.resolve(event);
        } else {
          pushQueue.push(event);
        }
      });
      this.on("end", () => {
        done = true;
        for (const reader of readQueue) {
          reader.resolve(undefined);
        }
        readQueue.length = 0;
      });
      this.on("abort", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      this.on("error", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      return {
        next: async () => {
          if (!pushQueue.length) {
            if (done) {
              return { value: undefined, done: true };
            }
            return new Promise((resolve3, reject) => readQueue.push({ resolve: resolve3, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: undefined, done: true });
          }
          const chunk = pushQueue.shift();
          return { value: chunk, done: false };
        },
        return: async () => {
          this.abort();
          return { value: undefined, done: true };
        }
      };
    }
    toReadableStream() {
      const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
      return stream.toReadableStream();
    }
  };
});

// node_modules/@anthropic-ai/sdk/lib/tools/ToolError.mjs
var ToolError;
var init_ToolError = __esm(() => {
  ToolError = class ToolError extends Error {
    constructor(content) {
      const message = typeof content === "string" ? content : content.map((block) => {
        if (block.type === "text")
          return block.text;
        return `[${block.type}]`;
      }).join(" ");
      super(message);
      this.name = "ToolError";
      this.content = content;
    }
  };
});

// node_modules/@anthropic-ai/sdk/lib/tools/CompactionControl.mjs
var DEFAULT_TOKEN_THRESHOLD = 1e5, DEFAULT_SUMMARY_PROMPT = `You have been working on the task described above but have not yet completed it. Write a continuation summary that will allow you (or another instance of yourself) to resume work efficiently in a future context window where the conversation history will be replaced with this summary. Your summary should be structured, concise, and actionable. Include:
1. Task Overview
The user's core request and success criteria
Any clarifications or constraints they specified
2. Current State
What has been completed so far
Files created, modified, or analyzed (with paths if relevant)
Key outputs or artifacts produced
3. Important Discoveries
Technical constraints or requirements uncovered
Decisions made and their rationale
Errors encountered and how they were resolved
What approaches were tried that didn't work (and why)
4. Next Steps
Specific actions needed to complete the task
Any blockers or open questions to resolve
Priority order if multiple steps remain
5. Context to Preserve
User preferences or style requirements
Domain-specific details that aren't obvious
Any promises made to the user
Be concise but complete\u2014err on the side of including information that would prevent duplicate work or repeated mistakes. Write in a way that enables immediate resumption of the task.
Wrap your summary in <summary></summary> tags.`;

// node_modules/@anthropic-ai/sdk/lib/tools/BetaToolRunner.mjs
function promiseWithResolvers() {
  let resolve3;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve3 = res;
    reject = rej;
  });
  return { promise, resolve: resolve3, reject };
}
async function generateToolResponse(params, lastMessage = params.messages.at(-1)) {
  if (!lastMessage || lastMessage.role !== "assistant" || !lastMessage.content || typeof lastMessage.content === "string") {
    return null;
  }
  const toolUseBlocks = lastMessage.content.filter((content) => content.type === "tool_use");
  if (toolUseBlocks.length === 0) {
    return null;
  }
  const toolResults = await Promise.all(toolUseBlocks.map(async (toolUse) => {
    const tool = params.tools.find((t) => ("name" in t ? t.name : t.mcp_server_name) === toolUse.name);
    if (!tool || !("run" in tool)) {
      return {
        type: "tool_result",
        tool_use_id: toolUse.id,
        content: `Error: Tool '${toolUse.name}' not found`,
        is_error: true
      };
    }
    try {
      let input = toolUse.input;
      if ("parse" in tool && tool.parse) {
        input = tool.parse(input);
      }
      const result = await tool.run(input);
      return {
        type: "tool_result",
        tool_use_id: toolUse.id,
        content: result
      };
    } catch (error2) {
      return {
        type: "tool_result",
        tool_use_id: toolUse.id,
        content: error2 instanceof ToolError ? error2.content : `Error: ${error2 instanceof Error ? error2.message : String(error2)}`,
        is_error: true
      };
    }
  }));
  return {
    role: "user",
    content: toolResults
  };
}
var _BetaToolRunner_instances, _BetaToolRunner_consumed, _BetaToolRunner_mutated, _BetaToolRunner_state, _BetaToolRunner_options, _BetaToolRunner_message, _BetaToolRunner_toolResponse, _BetaToolRunner_completion, _BetaToolRunner_iterationCount, _BetaToolRunner_checkAndCompact, _BetaToolRunner_generateToolResponse, BetaToolRunner;
var init_BetaToolRunner = __esm(() => {
  init_tslib();
  init_ToolError();
  init_error();
  init_headers();
  init_stainless_helper_header();
  BetaToolRunner = class BetaToolRunner {
    constructor(client, params, options) {
      _BetaToolRunner_instances.add(this);
      this.client = client;
      _BetaToolRunner_consumed.set(this, false);
      _BetaToolRunner_mutated.set(this, false);
      _BetaToolRunner_state.set(this, undefined);
      _BetaToolRunner_options.set(this, undefined);
      _BetaToolRunner_message.set(this, undefined);
      _BetaToolRunner_toolResponse.set(this, undefined);
      _BetaToolRunner_completion.set(this, undefined);
      _BetaToolRunner_iterationCount.set(this, 0);
      __classPrivateFieldSet(this, _BetaToolRunner_state, {
        params: {
          ...params,
          messages: structuredClone(params.messages)
        }
      }, "f");
      const helpers = collectStainlessHelpers(params.tools, params.messages);
      const helperValue = ["BetaToolRunner", ...helpers].join(", ");
      __classPrivateFieldSet(this, _BetaToolRunner_options, {
        ...options,
        headers: buildHeaders([{ "x-stainless-helper": helperValue }, options?.headers])
      }, "f");
      __classPrivateFieldSet(this, _BetaToolRunner_completion, promiseWithResolvers(), "f");
    }
    async* [(_BetaToolRunner_consumed = new WeakMap, _BetaToolRunner_mutated = new WeakMap, _BetaToolRunner_state = new WeakMap, _BetaToolRunner_options = new WeakMap, _BetaToolRunner_message = new WeakMap, _BetaToolRunner_toolResponse = new WeakMap, _BetaToolRunner_completion = new WeakMap, _BetaToolRunner_iterationCount = new WeakMap, _BetaToolRunner_instances = new WeakSet, _BetaToolRunner_checkAndCompact = async function _BetaToolRunner_checkAndCompact2() {
      const compactionControl = __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.compactionControl;
      if (!compactionControl || !compactionControl.enabled) {
        return false;
      }
      let tokensUsed = 0;
      if (__classPrivateFieldGet(this, _BetaToolRunner_message, "f") !== undefined) {
        try {
          const message = await __classPrivateFieldGet(this, _BetaToolRunner_message, "f");
          const totalInputTokens = message.usage.input_tokens + (message.usage.cache_creation_input_tokens ?? 0) + (message.usage.cache_read_input_tokens ?? 0);
          tokensUsed = totalInputTokens + message.usage.output_tokens;
        } catch {
          return false;
        }
      }
      const threshold = compactionControl.contextTokenThreshold ?? DEFAULT_TOKEN_THRESHOLD;
      if (tokensUsed < threshold) {
        return false;
      }
      const model = compactionControl.model ?? __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.model;
      const summaryPrompt = compactionControl.summaryPrompt ?? DEFAULT_SUMMARY_PROMPT;
      const messages = __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.messages;
      if (messages[messages.length - 1].role === "assistant") {
        const lastMessage = messages[messages.length - 1];
        if (Array.isArray(lastMessage.content)) {
          const nonToolBlocks = lastMessage.content.filter((block) => block.type !== "tool_use");
          if (nonToolBlocks.length === 0) {
            messages.pop();
          } else {
            lastMessage.content = nonToolBlocks;
          }
        }
      }
      const response = await this.client.beta.messages.create({
        model,
        messages: [
          ...messages,
          {
            role: "user",
            content: [
              {
                type: "text",
                text: summaryPrompt
              }
            ]
          }
        ],
        max_tokens: __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.max_tokens
      }, {
        headers: { "x-stainless-helper": "compaction" }
      });
      if (response.content[0]?.type !== "text") {
        throw new AnthropicError("Expected text response for compaction");
      }
      __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.messages = [
        {
          role: "user",
          content: response.content
        }
      ];
      return true;
    }, Symbol.asyncIterator)]() {
      var _a;
      if (__classPrivateFieldGet(this, _BetaToolRunner_consumed, "f")) {
        throw new AnthropicError("Cannot iterate over a consumed stream");
      }
      __classPrivateFieldSet(this, _BetaToolRunner_consumed, true, "f");
      __classPrivateFieldSet(this, _BetaToolRunner_mutated, true, "f");
      __classPrivateFieldSet(this, _BetaToolRunner_toolResponse, undefined, "f");
      try {
        while (true) {
          let stream;
          try {
            if (__classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.max_iterations && __classPrivateFieldGet(this, _BetaToolRunner_iterationCount, "f") >= __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.max_iterations) {
              break;
            }
            __classPrivateFieldSet(this, _BetaToolRunner_mutated, false, "f");
            __classPrivateFieldSet(this, _BetaToolRunner_toolResponse, undefined, "f");
            __classPrivateFieldSet(this, _BetaToolRunner_iterationCount, (_a = __classPrivateFieldGet(this, _BetaToolRunner_iterationCount, "f"), _a++, _a), "f");
            __classPrivateFieldSet(this, _BetaToolRunner_message, undefined, "f");
            const { max_iterations, compactionControl, ...params } = __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params;
            if (params.stream) {
              stream = this.client.beta.messages.stream({ ...params }, __classPrivateFieldGet(this, _BetaToolRunner_options, "f"));
              __classPrivateFieldSet(this, _BetaToolRunner_message, stream.finalMessage(), "f");
              __classPrivateFieldGet(this, _BetaToolRunner_message, "f").catch(() => {});
              yield stream;
            } else {
              __classPrivateFieldSet(this, _BetaToolRunner_message, this.client.beta.messages.create({ ...params, stream: false }, __classPrivateFieldGet(this, _BetaToolRunner_options, "f")), "f");
              yield __classPrivateFieldGet(this, _BetaToolRunner_message, "f");
            }
            const isCompacted = await __classPrivateFieldGet(this, _BetaToolRunner_instances, "m", _BetaToolRunner_checkAndCompact).call(this);
            if (!isCompacted) {
              if (!__classPrivateFieldGet(this, _BetaToolRunner_mutated, "f")) {
                const { role, content } = await __classPrivateFieldGet(this, _BetaToolRunner_message, "f");
                __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.messages.push({ role, content });
              }
              const toolMessage = await __classPrivateFieldGet(this, _BetaToolRunner_instances, "m", _BetaToolRunner_generateToolResponse).call(this, __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.messages.at(-1));
              if (toolMessage) {
                __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.messages.push(toolMessage);
              } else if (!__classPrivateFieldGet(this, _BetaToolRunner_mutated, "f")) {
                break;
              }
            }
          } finally {
            if (stream) {
              stream.abort();
            }
          }
        }
        if (!__classPrivateFieldGet(this, _BetaToolRunner_message, "f")) {
          throw new AnthropicError("ToolRunner concluded without a message from the server");
        }
        __classPrivateFieldGet(this, _BetaToolRunner_completion, "f").resolve(await __classPrivateFieldGet(this, _BetaToolRunner_message, "f"));
      } catch (error2) {
        __classPrivateFieldSet(this, _BetaToolRunner_consumed, false, "f");
        __classPrivateFieldGet(this, _BetaToolRunner_completion, "f").promise.catch(() => {});
        __classPrivateFieldGet(this, _BetaToolRunner_completion, "f").reject(error2);
        __classPrivateFieldSet(this, _BetaToolRunner_completion, promiseWithResolvers(), "f");
        throw error2;
      }
    }
    setMessagesParams(paramsOrMutator) {
      if (typeof paramsOrMutator === "function") {
        __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params = paramsOrMutator(__classPrivateFieldGet(this, _BetaToolRunner_state, "f").params);
      } else {
        __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params = paramsOrMutator;
      }
      __classPrivateFieldSet(this, _BetaToolRunner_mutated, true, "f");
      __classPrivateFieldSet(this, _BetaToolRunner_toolResponse, undefined, "f");
    }
    async generateToolResponse() {
      const message = await __classPrivateFieldGet(this, _BetaToolRunner_message, "f") ?? this.params.messages.at(-1);
      if (!message) {
        return null;
      }
      return __classPrivateFieldGet(this, _BetaToolRunner_instances, "m", _BetaToolRunner_generateToolResponse).call(this, message);
    }
    done() {
      return __classPrivateFieldGet(this, _BetaToolRunner_completion, "f").promise;
    }
    async runUntilDone() {
      if (!__classPrivateFieldGet(this, _BetaToolRunner_consumed, "f")) {
        for await (const _3 of this) {}
      }
      return this.done();
    }
    get params() {
      return __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params;
    }
    pushMessages(...messages) {
      this.setMessagesParams((params) => ({
        ...params,
        messages: [...params.messages, ...messages]
      }));
    }
    then(onfulfilled, onrejected) {
      return this.runUntilDone().then(onfulfilled, onrejected);
    }
  };
  _BetaToolRunner_generateToolResponse = async function _BetaToolRunner_generateToolResponse2(lastMessage) {
    if (__classPrivateFieldGet(this, _BetaToolRunner_toolResponse, "f") !== undefined) {
      return __classPrivateFieldGet(this, _BetaToolRunner_toolResponse, "f");
    }
    __classPrivateFieldSet(this, _BetaToolRunner_toolResponse, generateToolResponse(__classPrivateFieldGet(this, _BetaToolRunner_state, "f").params, lastMessage), "f");
    return __classPrivateFieldGet(this, _BetaToolRunner_toolResponse, "f");
  };
});

// node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs
var JSONLDecoder;
var init_jsonl = __esm(() => {
  init_error();
  init_line();
  JSONLDecoder = class JSONLDecoder {
    constructor(iterator2, controller) {
      this.iterator = iterator2;
      this.controller = controller;
    }
    async* decoder() {
      const lineDecoder = new LineDecoder;
      for await (const chunk of this.iterator) {
        for (const line of lineDecoder.decode(chunk)) {
          yield JSON.parse(line);
        }
      }
      for (const line of lineDecoder.flush()) {
        yield JSON.parse(line);
      }
    }
    [Symbol.asyncIterator]() {
      return this.decoder();
    }
    static fromResponse(response, controller) {
      if (!response.body) {
        controller.abort();
        if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
          throw new AnthropicError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
        }
        throw new AnthropicError(`Attempted to iterate over a response with no body`);
      }
      return new JSONLDecoder(ReadableStreamToAsyncIterable(response.body), controller);
    }
  };
});

// node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs
var Batches;
var init_batches = __esm(() => {
  init_pagination();
  init_headers();
  init_jsonl();
  init_error2();
  init_path();
  Batches = class Batches extends APIResource {
    create(params, options) {
      const { betas, ...body } = params;
      return this._client.post("/v1/messages/batches?beta=true", {
        body,
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString() },
          options?.headers
        ])
      });
    }
    retrieve(messageBatchID, params = {}, options) {
      const { betas } = params ?? {};
      return this._client.get(path`/v1/messages/batches/${messageBatchID}?beta=true`, {
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString() },
          options?.headers
        ])
      });
    }
    list(params = {}, options) {
      const { betas, ...query } = params ?? {};
      return this._client.getAPIList("/v1/messages/batches?beta=true", Page, {
        query,
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString() },
          options?.headers
        ])
      });
    }
    delete(messageBatchID, params = {}, options) {
      const { betas } = params ?? {};
      return this._client.delete(path`/v1/messages/batches/${messageBatchID}?beta=true`, {
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString() },
          options?.headers
        ])
      });
    }
    cancel(messageBatchID, params = {}, options) {
      const { betas } = params ?? {};
      return this._client.post(path`/v1/messages/batches/${messageBatchID}/cancel?beta=true`, {
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString() },
          options?.headers
        ])
      });
    }
    async results(messageBatchID, params = {}, options) {
      const batch = await this.retrieve(messageBatchID);
      if (!batch.results_url) {
        throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
      }
      const { betas } = params ?? {};
      return this._client.get(batch.results_url, {
        ...options,
        headers: buildHeaders([
          {
            "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString(),
            Accept: "application/binary"
          },
          options?.headers
        ]),
        stream: true,
        __binaryResponse: true
      })._thenUnwrap((_3, props) => JSONLDecoder.fromResponse(props.response, props.controller));
    }
  };
});

// node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs
function transformOutputFormat(params) {
  if (!params.output_format) {
    return params;
  }
  if (params.output_config?.format) {
    throw new AnthropicError("Both output_format and output_config.format were provided. " + "Please use only output_config.format (output_format is deprecated).");
  }
  const { output_format, ...rest } = params;
  return {
    ...rest,
    output_config: {
      ...params.output_config,
      format: output_format
    }
  };
}
var DEPRECATED_MODELS, MODELS_TO_WARN_WITH_THINKING_ENABLED, Messages;
var init_messages = __esm(() => {
  init_error2();
  init_constants();
  init_headers();
  init_stainless_helper_header();
  init_beta_parser();
  init_BetaMessageStream();
  init_BetaToolRunner();
  init_ToolError();
  init_batches();
  init_batches();
  init_BetaToolRunner();
  init_ToolError();
  DEPRECATED_MODELS = {
    "claude-1.3": "November 6th, 2024",
    "claude-1.3-100k": "November 6th, 2024",
    "claude-instant-1.1": "November 6th, 2024",
    "claude-instant-1.1-100k": "November 6th, 2024",
    "claude-instant-1.2": "November 6th, 2024",
    "claude-3-sonnet-20240229": "July 21st, 2025",
    "claude-3-opus-20240229": "January 5th, 2026",
    "claude-2.1": "July 21st, 2025",
    "claude-2.0": "July 21st, 2025",
    "claude-3-7-sonnet-latest": "February 19th, 2026",
    "claude-3-7-sonnet-20250219": "February 19th, 2026"
  };
  MODELS_TO_WARN_WITH_THINKING_ENABLED = ["claude-opus-4-6"];
  Messages = class Messages extends APIResource {
    constructor() {
      super(...arguments);
      this.batches = new Batches(this._client);
    }
    create(params, options) {
      const modifiedParams = transformOutputFormat(params);
      const { betas, ...body } = modifiedParams;
      if (body.model in DEPRECATED_MODELS) {
        console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
      }
      if (body.model in MODELS_TO_WARN_WITH_THINKING_ENABLED && body.thinking && body.thinking.type === "enabled") {
        console.warn(`Using Claude with ${body.model} and 'thinking.type=enabled' is deprecated. Use 'thinking.type=adaptive' instead which results in better model performance in our testing: https://platform.claude.com/docs/en/build-with-claude/adaptive-thinking`);
      }
      let timeout = this._client._options.timeout;
      if (!body.stream && timeout == null) {
        const maxNonstreamingTokens = MODEL_NONSTREAMING_TOKENS[body.model] ?? undefined;
        timeout = this._client.calculateNonstreamingTimeout(body.max_tokens, maxNonstreamingTokens);
      }
      const helperHeader = stainlessHelperHeader(body.tools, body.messages);
      return this._client.post("/v1/messages?beta=true", {
        body,
        timeout: timeout ?? 600000,
        ...options,
        headers: buildHeaders([
          { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : undefined },
          helperHeader,
          options?.headers
        ]),
        stream: modifiedParams.stream ?? false
      });
    }
    parse(params, options) {
      options = {
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...params.betas ?? [], "structured-outputs-2025-12-15"].toString() },
          options?.headers
        ])
      };
      return this.create(params, options).then((message) => parseBetaMessage(message, params, { logger: this._client.logger ?? console }));
    }
    stream(body, options) {
      return BetaMessageStream.createMessage(this, body, options);
    }
    countTokens(params, options) {
      const modifiedParams = transformOutputFormat(params);
      const { betas, ...body } = modifiedParams;
      return this._client.post("/v1/messages/count_tokens?beta=true", {
        body,
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "token-counting-2024-11-01"].toString() },
          options?.headers
        ])
      });
    }
    toolRunner(body, options) {
      return new BetaToolRunner(this._client, body, options);
    }
  };
  Messages.Batches = Batches;
  Messages.BetaToolRunner = BetaToolRunner;
  Messages.ToolError = ToolError;
});

// node_modules/@anthropic-ai/sdk/resources/beta/skills/versions.mjs
var Versions;
var init_versions = __esm(() => {
  init_pagination();
  init_headers();
  init_uploads();
  init_path();
  Versions = class Versions extends APIResource {
    create(skillID, params = {}, options) {
      const { betas, ...body } = params ?? {};
      return this._client.post(path`/v1/skills/${skillID}/versions?beta=true`, multipartFormRequestOptions({
        body,
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
          options?.headers
        ])
      }, this._client));
    }
    retrieve(version, params, options) {
      const { skill_id, betas } = params;
      return this._client.get(path`/v1/skills/${skill_id}/versions/${version}?beta=true`, {
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
          options?.headers
        ])
      });
    }
    list(skillID, params = {}, options) {
      const { betas, ...query } = params ?? {};
      return this._client.getAPIList(path`/v1/skills/${skillID}/versions?beta=true`, PageCursor, {
        query,
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
          options?.headers
        ])
      });
    }
    delete(version, params, options) {
      const { skill_id, betas } = params;
      return this._client.delete(path`/v1/skills/${skill_id}/versions/${version}?beta=true`, {
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
          options?.headers
        ])
      });
    }
  };
});

// node_modules/@anthropic-ai/sdk/resources/beta/skills/skills.mjs
var Skills;
var init_skills = __esm(() => {
  init_versions();
  init_versions();
  init_pagination();
  init_headers();
  init_uploads();
  init_path();
  Skills = class Skills extends APIResource {
    constructor() {
      super(...arguments);
      this.versions = new Versions(this._client);
    }
    create(params = {}, options) {
      const { betas, ...body } = params ?? {};
      return this._client.post("/v1/skills?beta=true", multipartFormRequestOptions({
        body,
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
          options?.headers
        ])
      }, this._client, false));
    }
    retrieve(skillID, params = {}, options) {
      const { betas } = params ?? {};
      return this._client.get(path`/v1/skills/${skillID}?beta=true`, {
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
          options?.headers
        ])
      });
    }
    list(params = {}, options) {
      const { betas, ...query } = params ?? {};
      return this._client.getAPIList("/v1/skills?beta=true", PageCursor, {
        query,
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
          options?.headers
        ])
      });
    }
    delete(skillID, params = {}, options) {
      const { betas } = params ?? {};
      return this._client.delete(path`/v1/skills/${skillID}?beta=true`, {
        ...options,
        headers: buildHeaders([
          { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
          options?.headers
        ])
      });
    }
  };
  Skills.Versions = Versions;
});

// node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs
var Beta;
var init_beta = __esm(() => {
  init_files();
  init_files();
  init_models();
  init_models();
  init_messages();
  init_messages();
  init_skills();
  init_skills();
  Beta = class Beta extends APIResource {
    constructor() {
      super(...arguments);
      this.models = new Models(this._client);
      this.messages = new Messages(this._client);
      this.files = new Files(this._client);
      this.skills = new Skills(this._client);
    }
  };
  Beta.Models = Models;
  Beta.Messages = Messages;
  Beta.Files = Files;
  Beta.Skills = Skills;
});

// node_modules/@anthropic-ai/sdk/resources/completions.mjs
var Completions;
var init_completions = __esm(() => {
  init_headers();
  Completions = class Completions extends APIResource {
    create(params, options) {
      const { betas, ...body } = params;
      return this._client.post("/v1/complete", {
        body,
        timeout: this._client._options.timeout ?? 600000,
        ...options,
        headers: buildHeaders([
          { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : undefined },
          options?.headers
        ]),
        stream: params.stream ?? false
      });
    }
  };
});

// node_modules/@anthropic-ai/sdk/lib/parser.mjs
function getOutputFormat2(params) {
  return params?.output_config?.format;
}
function maybeParseMessage(message, params, opts) {
  const outputFormat = getOutputFormat2(params);
  if (!params || !("parse" in (outputFormat ?? {}))) {
    return {
      ...message,
      content: message.content.map((block) => {
        if (block.type === "text") {
          const parsedBlock = Object.defineProperty({ ...block }, "parsed_output", {
            value: null,
            enumerable: false
          });
          return parsedBlock;
        }
        return block;
      }),
      parsed_output: null
    };
  }
  return parseMessage(message, params, opts);
}
function parseMessage(message, params, opts) {
  let firstParsedOutput = null;
  const content = message.content.map((block) => {
    if (block.type === "text") {
      const parsedOutput = parseOutputFormat(params, block.text);
      if (firstParsedOutput === null) {
        firstParsedOutput = parsedOutput;
      }
      const parsedBlock = Object.defineProperty({ ...block }, "parsed_output", {
        value: parsedOutput,
        enumerable: false
      });
      return parsedBlock;
    }
    return block;
  });
  return {
    ...message,
    content,
    parsed_output: firstParsedOutput
  };
}
function parseOutputFormat(params, content) {
  const outputFormat = getOutputFormat2(params);
  if (outputFormat?.type !== "json_schema") {
    return null;
  }
  try {
    if ("parse" in outputFormat) {
      return outputFormat.parse(content);
    }
    return JSON.parse(content);
  } catch (error2) {
    throw new AnthropicError(`Failed to parse structured output: ${error2}`);
  }
}
var init_parser3 = __esm(() => {
  init_error();
});

// node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs
function tracksToolInput2(content) {
  return content.type === "tool_use" || content.type === "server_tool_use";
}
function checkNever2(x2) {}
var _MessageStream_instances, _MessageStream_currentMessageSnapshot, _MessageStream_params, _MessageStream_connectedPromise, _MessageStream_resolveConnectedPromise, _MessageStream_rejectConnectedPromise, _MessageStream_endPromise, _MessageStream_resolveEndPromise, _MessageStream_rejectEndPromise, _MessageStream_listeners, _MessageStream_ended, _MessageStream_errored, _MessageStream_aborted, _MessageStream_catchingPromiseCreated, _MessageStream_response, _MessageStream_request_id, _MessageStream_logger, _MessageStream_getFinalMessage, _MessageStream_getFinalText, _MessageStream_handleError, _MessageStream_beginRequest, _MessageStream_addStreamEvent, _MessageStream_endRequest, _MessageStream_accumulateMessage, JSON_BUF_PROPERTY2 = "__json_buf", MessageStream;
var init_MessageStream = __esm(() => {
  init_tslib();
  init_error2();
  init_streaming2();
  init_parser2();
  init_parser3();
  MessageStream = class MessageStream {
    constructor(params, opts) {
      _MessageStream_instances.add(this);
      this.messages = [];
      this.receivedMessages = [];
      _MessageStream_currentMessageSnapshot.set(this, undefined);
      _MessageStream_params.set(this, null);
      this.controller = new AbortController;
      _MessageStream_connectedPromise.set(this, undefined);
      _MessageStream_resolveConnectedPromise.set(this, () => {});
      _MessageStream_rejectConnectedPromise.set(this, () => {});
      _MessageStream_endPromise.set(this, undefined);
      _MessageStream_resolveEndPromise.set(this, () => {});
      _MessageStream_rejectEndPromise.set(this, () => {});
      _MessageStream_listeners.set(this, {});
      _MessageStream_ended.set(this, false);
      _MessageStream_errored.set(this, false);
      _MessageStream_aborted.set(this, false);
      _MessageStream_catchingPromiseCreated.set(this, false);
      _MessageStream_response.set(this, undefined);
      _MessageStream_request_id.set(this, undefined);
      _MessageStream_logger.set(this, undefined);
      _MessageStream_handleError.set(this, (error2) => {
        __classPrivateFieldSet(this, _MessageStream_errored, true, "f");
        if (isAbortError(error2)) {
          error2 = new APIUserAbortError;
        }
        if (error2 instanceof APIUserAbortError) {
          __classPrivateFieldSet(this, _MessageStream_aborted, true, "f");
          return this._emit("abort", error2);
        }
        if (error2 instanceof AnthropicError) {
          return this._emit("error", error2);
        }
        if (error2 instanceof Error) {
          const anthropicError = new AnthropicError(error2.message);
          anthropicError.cause = error2;
          return this._emit("error", anthropicError);
        }
        return this._emit("error", new AnthropicError(String(error2)));
      });
      __classPrivateFieldSet(this, _MessageStream_connectedPromise, new Promise((resolve3, reject) => {
        __classPrivateFieldSet(this, _MessageStream_resolveConnectedPromise, resolve3, "f");
        __classPrivateFieldSet(this, _MessageStream_rejectConnectedPromise, reject, "f");
      }), "f");
      __classPrivateFieldSet(this, _MessageStream_endPromise, new Promise((resolve3, reject) => {
        __classPrivateFieldSet(this, _MessageStream_resolveEndPromise, resolve3, "f");
        __classPrivateFieldSet(this, _MessageStream_rejectEndPromise, reject, "f");
      }), "f");
      __classPrivateFieldGet(this, _MessageStream_connectedPromise, "f").catch(() => {});
      __classPrivateFieldGet(this, _MessageStream_endPromise, "f").catch(() => {});
      __classPrivateFieldSet(this, _MessageStream_params, params, "f");
      __classPrivateFieldSet(this, _MessageStream_logger, opts?.logger ?? console, "f");
    }
    get response() {
      return __classPrivateFieldGet(this, _MessageStream_response, "f");
    }
    get request_id() {
      return __classPrivateFieldGet(this, _MessageStream_request_id, "f");
    }
    async withResponse() {
      __classPrivateFieldSet(this, _MessageStream_catchingPromiseCreated, true, "f");
      const response = await __classPrivateFieldGet(this, _MessageStream_connectedPromise, "f");
      if (!response) {
        throw new Error("Could not resolve a `Response` object");
      }
      return {
        data: this,
        response,
        request_id: response.headers.get("request-id")
      };
    }
    static fromReadableStream(stream) {
      const runner = new MessageStream(null);
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    static createMessage(messages, params, options, { logger } = {}) {
      const runner = new MessageStream(params, { logger });
      for (const message of params.messages) {
        runner._addMessageParam(message);
      }
      __classPrivateFieldSet(runner, _MessageStream_params, { ...params, stream: true }, "f");
      runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
      return runner;
    }
    _run(executor) {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet(this, _MessageStream_handleError, "f"));
    }
    _addMessageParam(message) {
      this.messages.push(message);
    }
    _addMessage(message, emit = true) {
      this.receivedMessages.push(message);
      if (emit) {
        this._emit("message", message);
      }
    }
    async _createMessage(messages, params, options) {
      const signal = options?.signal;
      let abortHandler;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        abortHandler = this.controller.abort.bind(this.controller);
        signal.addEventListener("abort", abortHandler);
      }
      try {
        __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
        const { response, data: stream } = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
        this._connected(response);
        for await (const event of stream) {
          __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
        }
        if (stream.controller.signal?.aborted) {
          throw new APIUserAbortError;
        }
        __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
      } finally {
        if (signal && abortHandler) {
          signal.removeEventListener("abort", abortHandler);
        }
      }
    }
    _connected(response) {
      if (this.ended)
        return;
      __classPrivateFieldSet(this, _MessageStream_response, response, "f");
      __classPrivateFieldSet(this, _MessageStream_request_id, response?.headers.get("request-id"), "f");
      __classPrivateFieldGet(this, _MessageStream_resolveConnectedPromise, "f").call(this, response);
      this._emit("connect");
    }
    get ended() {
      return __classPrivateFieldGet(this, _MessageStream_ended, "f");
    }
    get errored() {
      return __classPrivateFieldGet(this, _MessageStream_errored, "f");
    }
    get aborted() {
      return __classPrivateFieldGet(this, _MessageStream_aborted, "f");
    }
    abort() {
      this.controller.abort();
    }
    on(event, listener) {
      const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _MessageStream_listeners, "f")[event] = []);
      listeners.push({ listener });
      return this;
    }
    off(event, listener) {
      const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, "f")[event];
      if (!listeners)
        return this;
      const index = listeners.findIndex((l2) => l2.listener === listener);
      if (index >= 0)
        listeners.splice(index, 1);
      return this;
    }
    once(event, listener) {
      const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _MessageStream_listeners, "f")[event] = []);
      listeners.push({ listener, once: true });
      return this;
    }
    emitted(event) {
      return new Promise((resolve3, reject) => {
        __classPrivateFieldSet(this, _MessageStream_catchingPromiseCreated, true, "f");
        if (event !== "error")
          this.once("error", reject);
        this.once(event, resolve3);
      });
    }
    async done() {
      __classPrivateFieldSet(this, _MessageStream_catchingPromiseCreated, true, "f");
      await __classPrivateFieldGet(this, _MessageStream_endPromise, "f");
    }
    get currentMessage() {
      return __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, "f");
    }
    async finalMessage() {
      await this.done();
      return __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this);
    }
    async finalText() {
      await this.done();
      return __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_getFinalText).call(this);
    }
    _emit(event, ...args) {
      if (__classPrivateFieldGet(this, _MessageStream_ended, "f"))
        return;
      if (event === "end") {
        __classPrivateFieldSet(this, _MessageStream_ended, true, "f");
        __classPrivateFieldGet(this, _MessageStream_resolveEndPromise, "f").call(this);
      }
      const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, "f")[event];
      if (listeners) {
        __classPrivateFieldGet(this, _MessageStream_listeners, "f")[event] = listeners.filter((l2) => !l2.once);
        listeners.forEach(({ listener }) => listener(...args));
      }
      if (event === "abort") {
        const error2 = args[0];
        if (!__classPrivateFieldGet(this, _MessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
          Promise.reject(error2);
        }
        __classPrivateFieldGet(this, _MessageStream_rejectConnectedPromise, "f").call(this, error2);
        __classPrivateFieldGet(this, _MessageStream_rejectEndPromise, "f").call(this, error2);
        this._emit("end");
        return;
      }
      if (event === "error") {
        const error2 = args[0];
        if (!__classPrivateFieldGet(this, _MessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
          Promise.reject(error2);
        }
        __classPrivateFieldGet(this, _MessageStream_rejectConnectedPromise, "f").call(this, error2);
        __classPrivateFieldGet(this, _MessageStream_rejectEndPromise, "f").call(this, error2);
        this._emit("end");
      }
    }
    _emitFinal() {
      const finalMessage = this.receivedMessages.at(-1);
      if (finalMessage) {
        this._emit("finalMessage", __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this));
      }
    }
    async _fromReadableStream(readableStream, options) {
      const signal = options?.signal;
      let abortHandler;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        abortHandler = this.controller.abort.bind(this.controller);
        signal.addEventListener("abort", abortHandler);
      }
      try {
        __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
        this._connected(null);
        const stream = Stream.fromReadableStream(readableStream, this.controller);
        for await (const event of stream) {
          __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
        }
        if (stream.controller.signal?.aborted) {
          throw new APIUserAbortError;
        }
        __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
      } finally {
        if (signal && abortHandler) {
          signal.removeEventListener("abort", abortHandler);
        }
      }
    }
    [(_MessageStream_currentMessageSnapshot = new WeakMap, _MessageStream_params = new WeakMap, _MessageStream_connectedPromise = new WeakMap, _MessageStream_resolveConnectedPromise = new WeakMap, _MessageStream_rejectConnectedPromise = new WeakMap, _MessageStream_endPromise = new WeakMap, _MessageStream_resolveEndPromise = new WeakMap, _MessageStream_rejectEndPromise = new WeakMap, _MessageStream_listeners = new WeakMap, _MessageStream_ended = new WeakMap, _MessageStream_errored = new WeakMap, _MessageStream_aborted = new WeakMap, _MessageStream_catchingPromiseCreated = new WeakMap, _MessageStream_response = new WeakMap, _MessageStream_request_id = new WeakMap, _MessageStream_logger = new WeakMap, _MessageStream_handleError = new WeakMap, _MessageStream_instances = new WeakSet, _MessageStream_getFinalMessage = function _MessageStream_getFinalMessage2() {
      if (this.receivedMessages.length === 0) {
        throw new AnthropicError("stream ended without producing a Message with role=assistant");
      }
      return this.receivedMessages.at(-1);
    }, _MessageStream_getFinalText = function _MessageStream_getFinalText2() {
      if (this.receivedMessages.length === 0) {
        throw new AnthropicError("stream ended without producing a Message with role=assistant");
      }
      const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
      if (textBlocks.length === 0) {
        throw new AnthropicError("stream ended without producing a content block with type=text");
      }
      return textBlocks.join(" ");
    }, _MessageStream_beginRequest = function _MessageStream_beginRequest2() {
      if (this.ended)
        return;
      __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, undefined, "f");
    }, _MessageStream_addStreamEvent = function _MessageStream_addStreamEvent2(event) {
      if (this.ended)
        return;
      const messageSnapshot = __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_accumulateMessage).call(this, event);
      this._emit("streamEvent", event, messageSnapshot);
      switch (event.type) {
        case "content_block_delta": {
          const content = messageSnapshot.content.at(-1);
          switch (event.delta.type) {
            case "text_delta": {
              if (content.type === "text") {
                this._emit("text", event.delta.text, content.text || "");
              }
              break;
            }
            case "citations_delta": {
              if (content.type === "text") {
                this._emit("citation", event.delta.citation, content.citations ?? []);
              }
              break;
            }
            case "input_json_delta": {
              if (tracksToolInput2(content) && content.input) {
                this._emit("inputJson", event.delta.partial_json, content.input);
              }
              break;
            }
            case "thinking_delta": {
              if (content.type === "thinking") {
                this._emit("thinking", event.delta.thinking, content.thinking);
              }
              break;
            }
            case "signature_delta": {
              if (content.type === "thinking") {
                this._emit("signature", content.signature);
              }
              break;
            }
            default:
              checkNever2(event.delta);
          }
          break;
        }
        case "message_stop": {
          this._addMessageParam(messageSnapshot);
          this._addMessage(maybeParseMessage(messageSnapshot, __classPrivateFieldGet(this, _MessageStream_params, "f"), { logger: __classPrivateFieldGet(this, _MessageStream_logger, "f") }), true);
          break;
        }
        case "content_block_stop": {
          this._emit("contentBlock", messageSnapshot.content.at(-1));
          break;
        }
        case "message_start": {
          __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, messageSnapshot, "f");
          break;
        }
        case "content_block_start":
        case "message_delta":
          break;
      }
    }, _MessageStream_endRequest = function _MessageStream_endRequest2() {
      if (this.ended) {
        throw new AnthropicError(`stream has ended, this shouldn't happen`);
      }
      const snapshot = __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, "f");
      if (!snapshot) {
        throw new AnthropicError(`request ended without sending any chunks`);
      }
      __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, undefined, "f");
      return maybeParseMessage(snapshot, __classPrivateFieldGet(this, _MessageStream_params, "f"), { logger: __classPrivateFieldGet(this, _MessageStream_logger, "f") });
    }, _MessageStream_accumulateMessage = function _MessageStream_accumulateMessage2(event) {
      let snapshot = __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, "f");
      if (event.type === "message_start") {
        if (snapshot) {
          throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
        }
        return event.message;
      }
      if (!snapshot) {
        throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
      }
      switch (event.type) {
        case "message_stop":
          return snapshot;
        case "message_delta":
          snapshot.stop_reason = event.delta.stop_reason;
          snapshot.stop_sequence = event.delta.stop_sequence;
          snapshot.usage.output_tokens = event.usage.output_tokens;
          if (event.usage.input_tokens != null) {
            snapshot.usage.input_tokens = event.usage.input_tokens;
          }
          if (event.usage.cache_creation_input_tokens != null) {
            snapshot.usage.cache_creation_input_tokens = event.usage.cache_creation_input_tokens;
          }
          if (event.usage.cache_read_input_tokens != null) {
            snapshot.usage.cache_read_input_tokens = event.usage.cache_read_input_tokens;
          }
          if (event.usage.server_tool_use != null) {
            snapshot.usage.server_tool_use = event.usage.server_tool_use;
          }
          return snapshot;
        case "content_block_start":
          snapshot.content.push({ ...event.content_block });
          return snapshot;
        case "content_block_delta": {
          const snapshotContent = snapshot.content.at(event.index);
          switch (event.delta.type) {
            case "text_delta": {
              if (snapshotContent?.type === "text") {
                snapshot.content[event.index] = {
                  ...snapshotContent,
                  text: (snapshotContent.text || "") + event.delta.text
                };
              }
              break;
            }
            case "citations_delta": {
              if (snapshotContent?.type === "text") {
                snapshot.content[event.index] = {
                  ...snapshotContent,
                  citations: [...snapshotContent.citations ?? [], event.delta.citation]
                };
              }
              break;
            }
            case "input_json_delta": {
              if (snapshotContent && tracksToolInput2(snapshotContent)) {
                let jsonBuf = snapshotContent[JSON_BUF_PROPERTY2] || "";
                jsonBuf += event.delta.partial_json;
                const newContent = { ...snapshotContent };
                Object.defineProperty(newContent, JSON_BUF_PROPERTY2, {
                  value: jsonBuf,
                  enumerable: false,
                  writable: true
                });
                if (jsonBuf) {
                  newContent.input = partialParse(jsonBuf);
                }
                snapshot.content[event.index] = newContent;
              }
              break;
            }
            case "thinking_delta": {
              if (snapshotContent?.type === "thinking") {
                snapshot.content[event.index] = {
                  ...snapshotContent,
                  thinking: snapshotContent.thinking + event.delta.thinking
                };
              }
              break;
            }
            case "signature_delta": {
              if (snapshotContent?.type === "thinking") {
                snapshot.content[event.index] = {
                  ...snapshotContent,
                  signature: event.delta.signature
                };
              }
              break;
            }
            default:
              checkNever2(event.delta);
          }
          return snapshot;
        }
        case "content_block_stop":
          return snapshot;
      }
    }, Symbol.asyncIterator)]() {
      const pushQueue = [];
      const readQueue = [];
      let done = false;
      this.on("streamEvent", (event) => {
        const reader = readQueue.shift();
        if (reader) {
          reader.resolve(event);
        } else {
          pushQueue.push(event);
        }
      });
      this.on("end", () => {
        done = true;
        for (const reader of readQueue) {
          reader.resolve(undefined);
        }
        readQueue.length = 0;
      });
      this.on("abort", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      this.on("error", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      return {
        next: async () => {
          if (!pushQueue.length) {
            if (done) {
              return { value: undefined, done: true };
            }
            return new Promise((resolve3, reject) => readQueue.push({ resolve: resolve3, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: undefined, done: true });
          }
          const chunk = pushQueue.shift();
          return { value: chunk, done: false };
        },
        return: async () => {
          this.abort();
          return { value: undefined, done: true };
        }
      };
    }
    toReadableStream() {
      const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
      return stream.toReadableStream();
    }
  };
});

// node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs
var Batches2;
var init_batches2 = __esm(() => {
  init_pagination();
  init_headers();
  init_jsonl();
  init_error2();
  init_path();
  Batches2 = class Batches2 extends APIResource {
    create(body, options) {
      return this._client.post("/v1/messages/batches", { body, ...options });
    }
    retrieve(messageBatchID, options) {
      return this._client.get(path`/v1/messages/batches/${messageBatchID}`, options);
    }
    list(query = {}, options) {
      return this._client.getAPIList("/v1/messages/batches", Page, { query, ...options });
    }
    delete(messageBatchID, options) {
      return this._client.delete(path`/v1/messages/batches/${messageBatchID}`, options);
    }
    cancel(messageBatchID, options) {
      return this._client.post(path`/v1/messages/batches/${messageBatchID}/cancel`, options);
    }
    async results(messageBatchID, options) {
      const batch = await this.retrieve(messageBatchID);
      if (!batch.results_url) {
        throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
      }
      return this._client.get(batch.results_url, {
        ...options,
        headers: buildHeaders([{ Accept: "application/binary" }, options?.headers]),
        stream: true,
        __binaryResponse: true
      })._thenUnwrap((_3, props) => JSONLDecoder.fromResponse(props.response, props.controller));
    }
  };
});

// node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs
var Messages2, DEPRECATED_MODELS2, MODELS_TO_WARN_WITH_THINKING_ENABLED2;
var init_messages2 = __esm(() => {
  init_headers();
  init_stainless_helper_header();
  init_MessageStream();
  init_parser3();
  init_batches2();
  init_batches2();
  init_constants();
  Messages2 = class Messages2 extends APIResource {
    constructor() {
      super(...arguments);
      this.batches = new Batches2(this._client);
    }
    create(body, options) {
      if (body.model in DEPRECATED_MODELS2) {
        console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS2[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
      }
      if (body.model in MODELS_TO_WARN_WITH_THINKING_ENABLED2 && body.thinking && body.thinking.type === "enabled") {
        console.warn(`Using Claude with ${body.model} and 'thinking.type=enabled' is deprecated. Use 'thinking.type=adaptive' instead which results in better model performance in our testing: https://platform.claude.com/docs/en/build-with-claude/adaptive-thinking`);
      }
      let timeout = this._client._options.timeout;
      if (!body.stream && timeout == null) {
        const maxNonstreamingTokens = MODEL_NONSTREAMING_TOKENS[body.model] ?? undefined;
        timeout = this._client.calculateNonstreamingTimeout(body.max_tokens, maxNonstreamingTokens);
      }
      const helperHeader = stainlessHelperHeader(body.tools, body.messages);
      return this._client.post("/v1/messages", {
        body,
        timeout: timeout ?? 600000,
        ...options,
        headers: buildHeaders([helperHeader, options?.headers]),
        stream: body.stream ?? false
      });
    }
    parse(params, options) {
      return this.create(params, options).then((message) => parseMessage(message, params, { logger: this._client.logger ?? console }));
    }
    stream(body, options) {
      return MessageStream.createMessage(this, body, options, { logger: this._client.logger ?? console });
    }
    countTokens(body, options) {
      return this._client.post("/v1/messages/count_tokens", { body, ...options });
    }
  };
  DEPRECATED_MODELS2 = {
    "claude-1.3": "November 6th, 2024",
    "claude-1.3-100k": "November 6th, 2024",
    "claude-instant-1.1": "November 6th, 2024",
    "claude-instant-1.1-100k": "November 6th, 2024",
    "claude-instant-1.2": "November 6th, 2024",
    "claude-3-sonnet-20240229": "July 21st, 2025",
    "claude-3-opus-20240229": "January 5th, 2026",
    "claude-2.1": "July 21st, 2025",
    "claude-2.0": "July 21st, 2025",
    "claude-3-7-sonnet-latest": "February 19th, 2026",
    "claude-3-7-sonnet-20250219": "February 19th, 2026",
    "claude-3-5-haiku-latest": "February 19th, 2026",
    "claude-3-5-haiku-20241022": "February 19th, 2026"
  };
  MODELS_TO_WARN_WITH_THINKING_ENABLED2 = ["claude-opus-4-6"];
  Messages2.Batches = Batches2;
});

// node_modules/@anthropic-ai/sdk/resources/models.mjs
var Models2;
var init_models2 = __esm(() => {
  init_pagination();
  init_headers();
  init_path();
  Models2 = class Models2 extends APIResource {
    retrieve(modelID, params = {}, options) {
      const { betas } = params ?? {};
      return this._client.get(path`/v1/models/${modelID}`, {
        ...options,
        headers: buildHeaders([
          { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : undefined },
          options?.headers
        ])
      });
    }
    list(params = {}, options) {
      const { betas, ...query } = params ?? {};
      return this._client.getAPIList("/v1/models", Page, {
        query,
        ...options,
        headers: buildHeaders([
          { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : undefined },
          options?.headers
        ])
      });
    }
  };
});

// node_modules/@anthropic-ai/sdk/resources/index.mjs
var init_resources = __esm(() => {
  init_beta();
  init_completions();
  init_messages2();
  init_models2();
  init_shared();
});

// node_modules/@anthropic-ai/sdk/internal/utils/env.mjs
var readEnv = (env) => {
  if (typeof globalThis.process !== "undefined") {
    return globalThis.process.env?.[env]?.trim() ?? undefined;
  }
  if (typeof globalThis.Deno !== "undefined") {
    return globalThis.Deno.env?.get?.(env)?.trim();
  }
  return;
};

// node_modules/@anthropic-ai/sdk/client.mjs
class BaseAnthropic {
  constructor({ baseURL = readEnv("ANTHROPIC_BASE_URL"), apiKey = readEnv("ANTHROPIC_API_KEY") ?? null, authToken = readEnv("ANTHROPIC_AUTH_TOKEN") ?? null, ...opts } = {}) {
    _BaseAnthropic_instances.add(this);
    _BaseAnthropic_encoder.set(this, undefined);
    const options = {
      apiKey,
      authToken,
      ...opts,
      baseURL: baseURL || `https://api.anthropic.com`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new AnthropicError(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new Anthropic({ apiKey, dangerouslyAllowBrowser: true });
`);
    }
    this.baseURL = options.baseURL;
    this.timeout = options.timeout ?? _a.DEFAULT_TIMEOUT;
    this.logger = options.logger ?? console;
    const defaultLogLevel = "warn";
    this.logLevel = defaultLogLevel;
    this.logLevel = parseLogLevel(options.logLevel, "ClientOptions.logLevel", this) ?? parseLogLevel(readEnv("ANTHROPIC_LOG"), "process.env['ANTHROPIC_LOG']", this) ?? defaultLogLevel;
    this.fetchOptions = options.fetchOptions;
    this.maxRetries = options.maxRetries ?? 2;
    this.fetch = options.fetch ?? getDefaultFetch();
    __classPrivateFieldSet(this, _BaseAnthropic_encoder, FallbackEncoder, "f");
    this._options = options;
    this.apiKey = typeof apiKey === "string" ? apiKey : null;
    this.authToken = authToken;
  }
  withOptions(options) {
    const client = new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      authToken: this.authToken,
      ...options
    });
    return client;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values, nulls }) {
    if (values.get("x-api-key") || values.get("authorization")) {
      return;
    }
    if (this.apiKey && values.get("x-api-key")) {
      return;
    }
    if (nulls.has("x-api-key")) {
      return;
    }
    if (this.authToken && values.get("authorization")) {
      return;
    }
    if (nulls.has("authorization")) {
      return;
    }
    throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the "X-Api-Key" or "Authorization" headers to be explicitly omitted');
  }
  async authHeaders(opts) {
    return buildHeaders([await this.apiKeyAuth(opts), await this.bearerAuth(opts)]);
  }
  async apiKeyAuth(opts) {
    if (this.apiKey == null) {
      return;
    }
    return buildHeaders([{ "X-Api-Key": this.apiKey }]);
  }
  async bearerAuth(opts) {
    if (this.authToken == null) {
      return;
    }
    return buildHeaders([{ Authorization: `Bearer ${this.authToken}` }]);
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_3, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new AnthropicError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION10}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  makeStatusError(status, error2, message, headers) {
    return APIError.generate(status, error2, message, headers);
  }
  buildURL(path2, query, defaultBaseURL) {
    const baseURL = !__classPrivateFieldGet(this, _BaseAnthropic_instances, "m", _BaseAnthropic_baseURLOverridden).call(this) && defaultBaseURL || this.baseURL;
    const url = isAbsoluteURL(path2) ? new URL(path2) : new URL(baseURL + (baseURL.endsWith("/") && path2.startsWith("/") ? path2.slice(1) : path2));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  _calculateNonstreamingTimeout(maxTokens) {
    const defaultTimeout = 10 * 60;
    const expectedTimeout = 60 * 60 * maxTokens / 128000;
    if (expectedTimeout > defaultTimeout) {
      throw new AnthropicError("Streaming is required for operations that may take longer than 10 minutes. " + "See https://github.com/anthropics/anthropic-sdk-typescript#streaming-responses for more details");
    }
    return defaultTimeout * 1000;
  }
  async prepareOptions(options) {}
  async prepareRequest(request2, { url, options }) {}
  get(path2, opts) {
    return this.methodRequest("get", path2, opts);
  }
  post(path2, opts) {
    return this.methodRequest("post", path2, opts);
  }
  patch(path2, opts) {
    return this.methodRequest("patch", path2, opts);
  }
  put(path2, opts) {
    return this.methodRequest("put", path2, opts);
  }
  delete(path2, opts) {
    return this.methodRequest("delete", path2, opts);
  }
  methodRequest(method, path2, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => {
      return { method, path: path2, ...opts2 };
    }));
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this, this.makeRequest(options, remainingRetries, undefined));
  }
  async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = await this.buildRequest(options, {
      retryCount: maxRetries - retriesRemaining
    });
    await this.prepareRequest(req, { url, options });
    const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
    const retryLogStr = retryOfRequestLogID === undefined ? "" : `, retryOf: ${retryOfRequestLogID}`;
    const startTime = Date.now();
    loggerFor(this).debug(`[${requestLogID}] sending request`, formatRequestDetails({
      retryOfRequestLogID,
      method: options.method,
      url,
      options,
      headers: req.headers
    }));
    if (options.signal?.aborted) {
      throw new APIUserAbortError;
    }
    const controller = new AbortController;
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    const headersTime = Date.now();
    if (response instanceof globalThis.Error) {
      const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
      if (options.signal?.aborted) {
        throw new APIUserAbortError;
      }
      const isTimeout = isAbortError(response) || /timed? ?out/i.test(String(response) + ("cause" in response ? String(response.cause) : ""));
      if (retriesRemaining) {
        loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
        loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, formatRequestDetails({
          retryOfRequestLogID,
          url,
          durationMs: headersTime - startTime,
          message: response.message
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID);
      }
      loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
      loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, formatRequestDetails({
        retryOfRequestLogID,
        url,
        durationMs: headersTime - startTime,
        message: response.message
      }));
      if (isTimeout) {
        throw new APIConnectionTimeoutError;
      }
      throw new APIConnectionError({ cause: response });
    }
    const specialHeaders = [...response.headers.entries()].filter(([name]) => name === "request-id").map(([name, value]) => ", " + name + ": " + JSON.stringify(value)).join("");
    const responseInfo = `[${requestLogID}${retryLogStr}${specialHeaders}] ${req.method} ${url} ${response.ok ? "succeeded" : "failed"} with status ${response.status} in ${headersTime - startTime}ms`;
    if (!response.ok) {
      const shouldRetry = await this.shouldRetry(response);
      if (retriesRemaining && shouldRetry) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        await CancelReadableStream(response.body);
        loggerFor(this).info(`${responseInfo} - ${retryMessage2}`);
        loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage2})`, formatRequestDetails({
          retryOfRequestLogID,
          url: response.url,
          status: response.status,
          headers: response.headers,
          durationMs: headersTime - startTime
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);
      }
      const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
      loggerFor(this).info(`${responseInfo} - ${retryMessage}`);
      const errText = await response.text().catch((err2) => castToError(err2).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? undefined : errText;
      loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({
        retryOfRequestLogID,
        url: response.url,
        status: response.status,
        headers: response.headers,
        message: errMessage,
        durationMs: Date.now() - startTime
      }));
      const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
      throw err;
    }
    loggerFor(this).info(responseInfo);
    loggerFor(this).debug(`[${requestLogID}] response start`, formatRequestDetails({
      retryOfRequestLogID,
      url: response.url,
      status: response.status,
      headers: response.headers,
      durationMs: headersTime - startTime
    }));
    return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
  }
  getAPIList(path2, Page2, opts) {
    return this.requestAPIList(Page2, opts && "then" in opts ? opts.then((opts2) => ({ method: "get", path: path2, ...opts2 })) : { method: "get", path: path2, ...opts });
  }
  requestAPIList(Page2, options) {
    const request2 = this.makeRequest(options, null, undefined);
    return new PagePromise(this, request2, Page2);
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, method, ...options } = init || {};
    const abort = this._makeAbort(controller);
    if (signal)
      signal.addEventListener("abort", abort, { once: true });
    const timeout = setTimeout(abort, ms);
    const isReadableBody = globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream || typeof options.body === "object" && options.body !== null && Symbol.asyncIterator in options.body;
    const fetchOptions = {
      signal: controller.signal,
      ...isReadableBody ? { duplex: "half" } : {},
      method: "GET",
      ...options
    };
    if (method) {
      fetchOptions.method = method.toUpperCase();
    }
    try {
      return await this.fetch.call(undefined, url, fetchOptions);
    } finally {
      clearTimeout(timeout);
    }
  }
  async shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders?.get("retry-after-ms");
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders?.get("retry-after");
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1000;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep2(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1, requestLogID);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1000;
  }
  calculateNonstreamingTimeout(maxTokens, maxNonstreamingTokens) {
    const maxTime = 60 * 60 * 1000;
    const defaultTime = 60 * 10 * 1000;
    const expectedTime = maxTime * maxTokens / 128000;
    if (expectedTime > defaultTime || maxNonstreamingTokens != null && maxTokens > maxNonstreamingTokens) {
      throw new AnthropicError("Streaming is required for operations that may take longer than 10 minutes. See https://github.com/anthropics/anthropic-sdk-typescript#long-requests for more details");
    }
    return defaultTime;
  }
  async buildRequest(inputOptions, { retryCount = 0 } = {}) {
    const options = { ...inputOptions };
    const { method, path: path2, query, defaultBaseURL } = options;
    const url = this.buildURL(path2, query, defaultBaseURL);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    options.timeout = options.timeout ?? this.timeout;
    const { bodyHeaders, body } = this.buildBody({ options });
    const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
    const req = {
      method,
      headers: reqHeaders,
      ...options.signal && { signal: options.signal },
      ...globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" },
      ...body && { body },
      ...this.fetchOptions ?? {},
      ...options.fetchOptions ?? {}
    };
    return { req, url, timeout: options.timeout };
  }
  async buildHeaders({ options, method, bodyHeaders, retryCount }) {
    let idempotencyHeaders = {};
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
    }
    const headers = buildHeaders([
      idempotencyHeaders,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(retryCount),
        ...options.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options.timeout / 1000)) } : {},
        ...getPlatformHeaders(),
        ...this._options.dangerouslyAllowBrowser ? { "anthropic-dangerous-direct-browser-access": "true" } : undefined,
        "anthropic-version": "2023-06-01"
      },
      await this.authHeaders(options),
      this._options.defaultHeaders,
      bodyHeaders,
      options.headers
    ]);
    this.validateHeaders(headers);
    return headers.values;
  }
  _makeAbort(controller) {
    return () => controller.abort();
  }
  buildBody({ options: { body, headers: rawHeaders } }) {
    if (!body) {
      return { bodyHeaders: undefined, body: undefined };
    }
    const headers = buildHeaders([rawHeaders]);
    if (ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && headers.values.has("content-type") || globalThis.Blob && body instanceof globalThis.Blob || body instanceof FormData || body instanceof URLSearchParams || globalThis.ReadableStream && body instanceof globalThis.ReadableStream) {
      return { bodyHeaders: undefined, body };
    } else if (typeof body === "object" && ((Symbol.asyncIterator in body) || (Symbol.iterator in body) && ("next" in body) && typeof body.next === "function")) {
      return { bodyHeaders: undefined, body: ReadableStreamFrom(body) };
    } else {
      return __classPrivateFieldGet(this, _BaseAnthropic_encoder, "f").call(this, { body, headers });
    }
  }
}
var _BaseAnthropic_instances, _a, _BaseAnthropic_encoder, _BaseAnthropic_baseURLOverridden, HUMAN_PROMPT = "\\n\\nHuman:", AI_PROMPT = "\\n\\nAssistant:", Anthropic;
var init_client2 = __esm(() => {
  init_tslib();
  init_values();
  init_detect_platform();
  init_error();
  init_pagination();
  init_uploads2();
  init_resources();
  init_api_promise();
  init_completions();
  init_models2();
  init_beta();
  init_messages2();
  init_detect_platform();
  init_headers();
  init_log();
  init_values();
  _a = BaseAnthropic, _BaseAnthropic_encoder = new WeakMap, _BaseAnthropic_instances = new WeakSet, _BaseAnthropic_baseURLOverridden = function _BaseAnthropic_baseURLOverridden2() {
    return this.baseURL !== "https://api.anthropic.com";
  };
  BaseAnthropic.Anthropic = _a;
  BaseAnthropic.HUMAN_PROMPT = HUMAN_PROMPT;
  BaseAnthropic.AI_PROMPT = AI_PROMPT;
  BaseAnthropic.DEFAULT_TIMEOUT = 600000;
  BaseAnthropic.AnthropicError = AnthropicError;
  BaseAnthropic.APIError = APIError;
  BaseAnthropic.APIConnectionError = APIConnectionError;
  BaseAnthropic.APIConnectionTimeoutError = APIConnectionTimeoutError;
  BaseAnthropic.APIUserAbortError = APIUserAbortError;
  BaseAnthropic.NotFoundError = NotFoundError;
  BaseAnthropic.ConflictError = ConflictError;
  BaseAnthropic.RateLimitError = RateLimitError;
  BaseAnthropic.BadRequestError = BadRequestError;
  BaseAnthropic.AuthenticationError = AuthenticationError;
  BaseAnthropic.InternalServerError = InternalServerError;
  BaseAnthropic.PermissionDeniedError = PermissionDeniedError;
  BaseAnthropic.UnprocessableEntityError = UnprocessableEntityError;
  BaseAnthropic.toFile = toFile;
  Anthropic = class Anthropic extends BaseAnthropic {
    constructor() {
      super(...arguments);
      this.completions = new Completions(this);
      this.messages = new Messages2(this);
      this.models = new Models2(this);
      this.beta = new Beta(this);
    }
  };
  Anthropic.Completions = Completions;
  Anthropic.Messages = Messages2;
  Anthropic.Models = Models2;
  Anthropic.Beta = Beta;
});

// node_modules/@anthropic-ai/sdk/index.mjs
var init_sdk = __esm(() => {
  init_client2();
  init_uploads2();
  init_api_promise();
  init_client2();
  init_pagination();
  init_error();
});

// src/interview/errors.ts
var InterviewError, AnthropicKeyNotFoundError, AnthropicAPIError, ContextOverflowError, SessionLoadError, SessionSaveError, PRDFileError, InterviewCancelledError, InvestigationError, ReviewError;
var init_errors10 = __esm(() => {
  InterviewError = class InterviewError extends Error {
    constructor(message) {
      super(message);
      this.name = "InterviewError";
    }
  };
  AnthropicKeyNotFoundError = class AnthropicKeyNotFoundError extends InterviewError {
    constructor() {
      super("Anthropic API key not found. Set ANTHROPIC_API_KEY environment variable.");
      this.name = "AnthropicKeyNotFoundError";
    }
  };
  AnthropicAPIError = class AnthropicAPIError extends InterviewError {
    statusCode;
    details;
    constructor(statusCode, details) {
      super(`Anthropic API error (${statusCode ?? "unknown"}): ${details}`);
      this.statusCode = statusCode;
      this.details = details;
      this.name = "AnthropicAPIError";
    }
  };
  ContextOverflowError = class ContextOverflowError extends InterviewError {
    currentTokens;
    maxTokens;
    constructor(currentTokens, maxTokens) {
      super(`Context overflow: ${currentTokens} tokens exceeds ${maxTokens} maximum.`);
      this.currentTokens = currentTokens;
      this.maxTokens = maxTokens;
      this.name = "ContextOverflowError";
    }
  };
  SessionLoadError = class SessionLoadError extends InterviewError {
    prdSlug;
    details;
    constructor(prdSlug, details) {
      super(`Failed to load interview session for ${prdSlug}: ${details}`);
      this.prdSlug = prdSlug;
      this.details = details;
      this.name = "SessionLoadError";
    }
  };
  SessionSaveError = class SessionSaveError extends InterviewError {
    prdSlug;
    details;
    constructor(prdSlug, details) {
      super(`Failed to save interview session for ${prdSlug}: ${details}`);
      this.prdSlug = prdSlug;
      this.details = details;
      this.name = "SessionSaveError";
    }
  };
  PRDFileError = class PRDFileError extends InterviewError {
    path;
    operation;
    details;
    constructor(path2, operation, details) {
      super(`Failed to ${operation} PRD file at ${path2}: ${details}`);
      this.path = path2;
      this.operation = operation;
      this.details = details;
      this.name = "PRDFileError";
    }
  };
  InterviewCancelledError = class InterviewCancelledError extends InterviewError {
    round;
    reason;
    constructor(round, reason = "User cancelled") {
      super(`Interview cancelled during ${round}: ${reason}`);
      this.round = round;
      this.reason = reason;
      this.name = "InterviewCancelledError";
    }
  };
  InvestigationError = class InvestigationError extends InterviewError {
    query;
    details;
    constructor(query, details) {
      super(`Investigation failed for "${query}": ${details}`);
      this.query = query;
      this.details = details;
      this.name = "InvestigationError";
    }
  };
  ReviewError = class ReviewError extends InterviewError {
    details;
    constructor(details) {
      super(`Review failed: ${details}`);
      this.details = details;
      this.name = "ReviewError";
    }
  };
});

// src/interview/conversation.ts
function getAnthropicClient() {
  if (anthropicClient) {
    return anthropicClient;
  }
  const apiKey = process.env["ANTHROPIC_API_KEY"];
  if (!apiKey) {
    throw new AnthropicKeyNotFoundError;
  }
  anthropicClient = new Anthropic({ apiKey });
  return anthropicClient;
}
function toAnthropicMessages(messages) {
  return messages.map((msg) => ({
    role: msg.role,
    content: msg.content
  }));
}
async function sendMessage(systemPrompt, messages, options) {
  const client = getAnthropicClient();
  const {
    model = DEFAULT_MODEL,
    maxTokens = MAX_RESPONSE_TOKENS,
    temperature = 0.7
  } = options ?? {};
  try {
    const response = await client.messages.create({
      model,
      max_tokens: maxTokens,
      temperature,
      system: systemPrompt,
      messages: toAnthropicMessages(messages)
    });
    const textBlocks = response.content.filter((block) => block.type === "text");
    if (textBlocks.length === 0) {
      throw new AnthropicAPIError(undefined, "No text content in response");
    }
    return textBlocks.map((block) => block.text).join(`
`);
  } catch (error2) {
    if (error2 instanceof AnthropicAPIError) {
      throw error2;
    }
    if (error2 instanceof Anthropic.APIError) {
      throw new AnthropicAPIError(error2.status, error2.message);
    }
    throw new AnthropicAPIError(undefined, error2.message);
  }
}
async function* streamMessage(systemPrompt, messages, options) {
  const client = getAnthropicClient();
  const {
    model = DEFAULT_MODEL,
    maxTokens = MAX_RESPONSE_TOKENS,
    temperature = 0.7
  } = options ?? {};
  try {
    const stream = await client.messages.stream({
      model,
      max_tokens: maxTokens,
      temperature,
      system: systemPrompt,
      messages: toAnthropicMessages(messages)
    });
    for await (const event of stream) {
      if (event.type === "content_block_delta" && event.delta.type === "text_delta") {
        yield event.delta.text;
      }
    }
  } catch (error2) {
    if (error2 instanceof Anthropic.APIError) {
      throw new AnthropicAPIError(error2.status, error2.message);
    }
    throw new AnthropicAPIError(undefined, error2.message);
  }
}
async function collectStreamedResponse(systemPrompt, messages, onChunk, options) {
  const chunks = [];
  for await (const chunk of streamMessage(systemPrompt, messages, options)) {
    chunks.push(chunk);
    onChunk?.(chunk);
  }
  return chunks.join("");
}
async function sendMessageWithThinking(systemPrompt, messages, options) {
  const client = getAnthropicClient();
  const { model = DEFAULT_MODEL, maxTokens = MAX_RESPONSE_TOKENS, thinking } = options ?? {};
  const temperature = thinking ? 1 : options?.temperature ?? 0.7;
  try {
    const requestParams = {
      model,
      max_tokens: maxTokens,
      temperature,
      system: systemPrompt,
      messages: toAnthropicMessages(messages)
    };
    if (thinking) {
      const paramsWithThinking = requestParams;
      paramsWithThinking["thinking"] = thinking;
    }
    const response = await client.messages.create(requestParams);
    let text = "";
    let thinkingContent;
    for (const block of response.content) {
      if (block.type === "text") {
        text += block.text;
      } else if (block.type === "thinking") {
        thinkingContent = block.thinking;
      }
    }
    if (!text) {
      throw new AnthropicAPIError(undefined, "No text content in response");
    }
    const result = { text };
    if (thinkingContent !== undefined) {
      result.thinking = thinkingContent;
    }
    if (response.usage) {
      result.usage = {
        inputTokens: response.usage.input_tokens,
        outputTokens: response.usage.output_tokens
      };
    }
    return result;
  } catch (error2) {
    if (error2 instanceof AnthropicAPIError) {
      throw error2;
    }
    if (error2 instanceof Anthropic.APIError) {
      throw new AnthropicAPIError(error2.status, error2.message);
    }
    throw new AnthropicAPIError(undefined, error2.message);
  }
}
async function sendMessageWithTools(systemPrompt, messages, tools, options) {
  const client = getAnthropicClient();
  const {
    model = DEFAULT_MODEL,
    maxTokens = MAX_RESPONSE_TOKENS,
    temperature = 0.7
  } = options ?? {};
  try {
    const response = await client.messages.create({
      model,
      max_tokens: maxTokens,
      temperature,
      system: systemPrompt,
      messages: toAnthropicMessages(messages),
      tools: tools.map((tool) => ({
        name: tool.name,
        description: tool.description,
        input_schema: tool.input_schema
      }))
    });
    const results = [];
    for (const block of response.content) {
      if (block.type === "text") {
        results.push({ type: "text", content: block.text });
      } else if (block.type === "tool_use") {
        results.push({
          type: "tool_use",
          id: block.id,
          name: block.name,
          input: block.input
        });
      }
    }
    return results;
  } catch (error2) {
    if (error2 instanceof Anthropic.APIError) {
      throw new AnthropicAPIError(error2.status, error2.message);
    }
    throw new AnthropicAPIError(undefined, error2.message);
  }
}
async function continueWithToolResults(systemPrompt, messages, toolUseId, toolResult, tools, options) {
  const updatedMessages = [
    ...toAnthropicMessages(messages),
    {
      role: "user",
      content: [
        {
          type: "tool_result",
          tool_use_id: toolUseId,
          content: toolResult
        }
      ]
    }
  ];
  const client = getAnthropicClient();
  const {
    model = DEFAULT_MODEL,
    maxTokens = MAX_RESPONSE_TOKENS,
    temperature = 0.7
  } = options ?? {};
  try {
    const response = await client.messages.create({
      model,
      max_tokens: maxTokens,
      temperature,
      system: systemPrompt,
      messages: updatedMessages,
      tools: tools.map((tool) => ({
        name: tool.name,
        description: tool.description,
        input_schema: tool.input_schema
      }))
    });
    const results = [];
    for (const block of response.content) {
      if (block.type === "text") {
        results.push({ type: "text", content: block.text });
      } else if (block.type === "tool_use") {
        results.push({
          type: "tool_use",
          id: block.id,
          name: block.name,
          input: block.input
        });
      }
    }
    return results;
  } catch (error2) {
    if (error2 instanceof Anthropic.APIError) {
      throw new AnthropicAPIError(error2.status, error2.message);
    }
    throw new AnthropicAPIError(undefined, error2.message);
  }
}
async function streamMessageWithTools(systemPrompt, messages, tools, onChunk, options) {
  const client = getAnthropicClient();
  const {
    model = DEFAULT_MODEL,
    maxTokens = MAX_RESPONSE_TOKENS,
    temperature = 0.7
  } = options ?? {};
  try {
    const stream = await client.messages.stream({
      model,
      max_tokens: maxTokens,
      temperature,
      system: systemPrompt,
      messages,
      tools: tools.map((tool) => ({
        name: tool.name,
        description: tool.description,
        input_schema: tool.input_schema
      }))
    });
    const textChunks = [];
    const toolUse = [];
    let currentToolId = null;
    let currentToolName = null;
    let currentToolInputJson = "";
    for await (const event of stream) {
      if (event.type === "content_block_start") {
        const block = event.content_block;
        if (block.type === "tool_use") {
          currentToolId = block.id;
          currentToolName = block.name;
          currentToolInputJson = "";
        }
      } else if (event.type === "content_block_delta") {
        if (event.delta.type === "text_delta") {
          textChunks.push(event.delta.text);
          onChunk?.(event.delta.text);
        } else if (event.delta.type === "input_json_delta") {
          currentToolInputJson += event.delta.partial_json;
        }
      } else if (event.type === "content_block_stop") {
        if (currentToolId && currentToolName) {
          try {
            const input = currentToolInputJson ? JSON.parse(currentToolInputJson) : {};
            toolUse.push({
              type: "tool_use",
              id: currentToolId,
              name: currentToolName,
              input
            });
          } catch {}
          currentToolId = null;
          currentToolName = null;
          currentToolInputJson = "";
        }
      }
    }
    return {
      response: textChunks.join(""),
      toolUse
    };
  } catch (error2) {
    if (error2 instanceof Anthropic.APIError) {
      throw new AnthropicAPIError(error2.status, error2.message);
    }
    throw new AnthropicAPIError(undefined, error2.message);
  }
}
async function streamContinueWithToolResults(systemPrompt, messages, assistantContent, toolResults, tools, onChunk, options) {
  const client = getAnthropicClient();
  const {
    model = DEFAULT_MODEL,
    maxTokens = MAX_RESPONSE_TOKENS,
    temperature = 0.7
  } = options ?? {};
  const updatedMessages = [
    ...messages,
    {
      role: "assistant",
      content: assistantContent
    },
    {
      role: "user",
      content: toolResults.map((tr) => ({
        type: "tool_result",
        tool_use_id: tr.toolUseId,
        content: tr.content
      }))
    }
  ];
  try {
    const stream = await client.messages.stream({
      model,
      max_tokens: maxTokens,
      temperature,
      system: systemPrompt,
      messages: updatedMessages,
      tools: tools.map((tool) => ({
        name: tool.name,
        description: tool.description,
        input_schema: tool.input_schema
      }))
    });
    const textChunks = [];
    const toolUse = [];
    let currentToolId = null;
    let currentToolName = null;
    let currentToolInputJson = "";
    for await (const event of stream) {
      if (event.type === "content_block_start") {
        const block = event.content_block;
        if (block.type === "tool_use") {
          currentToolId = block.id;
          currentToolName = block.name;
          currentToolInputJson = "";
        }
      } else if (event.type === "content_block_delta") {
        if (event.delta.type === "text_delta") {
          textChunks.push(event.delta.text);
          onChunk?.(event.delta.text);
        } else if (event.delta.type === "input_json_delta") {
          currentToolInputJson += event.delta.partial_json;
        }
      } else if (event.type === "content_block_stop") {
        if (currentToolId && currentToolName) {
          try {
            const input = currentToolInputJson ? JSON.parse(currentToolInputJson) : {};
            toolUse.push({
              type: "tool_use",
              id: currentToolId,
              name: currentToolName,
              input
            });
          } catch {}
          currentToolId = null;
          currentToolName = null;
          currentToolInputJson = "";
        }
      }
    }
    return {
      response: textChunks.join(""),
      toolUse
    };
  } catch (error2) {
    if (error2 instanceof Anthropic.APIError) {
      throw new AnthropicAPIError(error2.status, error2.message);
    }
    throw new AnthropicAPIError(undefined, error2.message);
  }
}
var DEFAULT_MODEL = "claude-sonnet-4-20250514", MAX_RESPONSE_TOKENS = 8192, anthropicClient = null;
var init_conversation = __esm(() => {
  init_sdk();
  init_errors10();
});

// src/interview/types.ts
function createDefaultSession(prdSlug, prdPath) {
  return {
    id: crypto.randomUUID(),
    prdSlug,
    prdPath,
    status: "not-started",
    currentRound: "framing",
    completedRounds: [],
    messages: [],
    summaries: [],
    estimatedTokens: 0,
    startedAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    subagentHistory: [],
    subagentUsage: {
      model: "claude-sonnet-4-20250514",
      inputTokens: 0,
      outputTokens: 0,
      cacheReadTokens: 0
    }
  };
}
var PRD_SECTIONS;
var init_types3 = __esm(() => {
  PRD_SECTIONS = [
    {
      id: "executive-summary",
      title: "Executive Summary",
      prdSection: 1,
      status: "empty",
      confidence: 0,
      weight: 15,
      lastUpdated: null
    },
    {
      id: "problem-context",
      title: "Problem & Context",
      prdSection: 2,
      status: "empty",
      confidence: 0,
      weight: 10,
      lastUpdated: null
    },
    {
      id: "goals-metrics",
      title: "Goals & Metrics",
      prdSection: 3,
      status: "empty",
      confidence: 0,
      weight: 15,
      lastUpdated: null
    },
    {
      id: "requirements",
      title: "Requirements",
      prdSection: 4,
      status: "empty",
      confidence: 0,
      weight: 20,
      lastUpdated: null
    },
    {
      id: "ux-notes",
      title: "UX Notes",
      prdSection: 5,
      status: "empty",
      confidence: 0,
      weight: 10,
      lastUpdated: null
    },
    {
      id: "dependencies-risks",
      title: "Dependencies & Risks",
      prdSection: 6,
      status: "empty",
      confidence: 0,
      weight: 10,
      lastUpdated: null
    },
    {
      id: "rollout",
      title: "Rollout",
      prdSection: 7,
      status: "empty",
      confidence: 0,
      weight: 5,
      lastUpdated: null
    },
    {
      id: "milestones",
      title: "Milestones",
      prdSection: 8,
      status: "empty",
      confidence: 0,
      weight: 5,
      lastUpdated: null
    },
    {
      id: "open-questions",
      title: "Open Questions",
      prdSection: 9,
      status: "empty",
      confidence: 0,
      weight: 0,
      lastUpdated: null
    },
    {
      id: "checkpoint-learnings",
      title: "Checkpoint Learnings",
      prdSection: 10,
      status: "empty",
      confidence: 0,
      weight: 5,
      lastUpdated: null
    },
    {
      id: "agent-boundaries",
      title: "Agent Boundaries",
      prdSection: 11,
      status: "empty",
      confidence: 0,
      weight: 5,
      lastUpdated: null
    }
  ];
});

// src/interview/section-tracker.ts
class SectionTracker {
  sections;
  conflicts;
  constructor() {
    this.sections = new Map;
    this.conflicts = [];
    for (const section of PRD_SECTIONS) {
      this.sections.set(section.id, { ...section });
    }
  }
  getProgress() {
    const sections = Array.from(this.sections.values());
    const totalSections = sections.length;
    let weightedComplete = 0;
    let completeSections = 0;
    for (const section of sections) {
      if (section.status === "complete") {
        weightedComplete += section.weight;
        completeSections++;
      } else if (section.status === "partial") {
        weightedComplete += section.weight * section.confidence / 100;
      }
    }
    const suggestedNextTopics = this.getSuggestedNextTopics();
    return {
      sections,
      overallPercent: Math.round(weightedComplete),
      completeSections,
      totalSections,
      suggestedNextTopics,
      conflicts: [...this.conflicts]
    };
  }
  updateSection(sectionId, status, confidence) {
    const section = this.sections.get(sectionId);
    if (!section) {
      throw new Error(`Unknown section: ${sectionId}`);
    }
    section.status = status;
    section.confidence = Math.min(100, Math.max(0, confidence));
    section.lastUpdated = new Date;
    this.sections.set(sectionId, section);
  }
  completeSection(sectionId) {
    this.updateSection(sectionId, "complete", 100);
  }
  partialSection(sectionId, confidence) {
    this.updateSection(sectionId, "partial", confidence);
  }
  getSection(sectionId) {
    return this.sections.get(sectionId);
  }
  getAllSections() {
    return Array.from(this.sections.values());
  }
  getSuggestedNextTopics() {
    const sections = Array.from(this.sections.values());
    const prioritized = sections.filter((s) => s.weight > 0 && s.status !== "complete").sort((a3, b3) => {
      if (a3.status === "empty" && b3.status !== "empty")
        return -1;
      if (b3.status === "empty" && a3.status !== "empty")
        return 1;
      if (a3.weight !== b3.weight)
        return b3.weight - a3.weight;
      return a3.confidence - b3.confidence;
    }).slice(0, 3);
    return prioritized.map((s) => s.title);
  }
  addConflict(type, description, sectionAffected, earlierStatement, laterStatement) {
    const conflict = {
      id: crypto.randomUUID(),
      type,
      description,
      sectionAffected,
      earlierStatement,
      laterStatement,
      resolution: "unresolved",
      detectedAt: new Date
    };
    this.conflicts.push(conflict);
    return conflict;
  }
  resolveConflict(conflictId, resolvedAs) {
    const conflict = this.conflicts.find((c2) => c2.id === conflictId);
    if (!conflict) {
      throw new Error(`Unknown conflict: ${conflictId}`);
    }
    conflict.resolution = "resolved";
    conflict.resolvedAs = resolvedAs;
  }
  getUnresolvedConflicts() {
    return this.conflicts.filter((c2) => c2.resolution === "unresolved");
  }
  getAllConflicts() {
    return [...this.conflicts];
  }
  hasUnresolvedConflicts() {
    return this.conflicts.some((c2) => c2.resolution === "unresolved");
  }
  getConflictsForSection(sectionId) {
    return this.conflicts.filter((c2) => c2.sectionAffected === sectionId);
  }
  toJSON() {
    return {
      sections: Array.from(this.sections.values()),
      conflicts: this.conflicts
    };
  }
  static fromJSON(data) {
    const tracker = new SectionTracker;
    for (const section of data.sections) {
      tracker.sections.set(section.id, {
        ...section,
        lastUpdated: section.lastUpdated ? new Date(section.lastUpdated) : null
      });
    }
    tracker.conflicts = data.conflicts.map((c2) => ({
      ...c2,
      detectedAt: new Date(c2.detectedAt)
    }));
    return tracker;
  }
  isReadyForFinalizationOffer() {
    return this.getProgress().overallPercent >= 80;
  }
  shouldSuggestFinalization() {
    return this.getProgress().overallPercent >= 95 && !this.hasUnresolvedConflicts();
  }
  canFinalize() {
    return !this.hasUnresolvedConflicts();
  }
}
function createSectionTracker() {
  return new SectionTracker;
}
function formatProgressBar(percent, width = 20) {
  const filled = Math.round(percent / 100 * width);
  const empty = width - filled;
  const bar = "\u2588".repeat(filled) + "\u2591".repeat(empty);
  return `[${bar}] ${percent}%`;
}
function formatConflict(conflict) {
  const typeLabels = {
    "user-vs-user": "Earlier vs. Now",
    "user-vs-codebase": "User vs. Codebase",
    "user-vs-prd": "User vs. PRD"
  };
  return `\u26A0  CONFLICT (${typeLabels[conflict.type]})
   Earlier: "${conflict.earlierStatement}"
   Now:     "${conflict.laterStatement}"
   Affects: \xA7${conflict.sectionAffected}`;
}
function formatSectionIcon(status) {
  switch (status) {
    case "complete":
      return "\u2713";
    case "partial":
      return "\u25D0";
    case "empty":
      return "\u25CB";
  }
}
function formatProgressSummary(progress) {
  const lines = [];
  lines.push(formatProgressBar(progress.overallPercent));
  lines.push(`${progress.completeSections}/${progress.totalSections} sections complete`);
  if (progress.conflicts.length > 0) {
    const unresolved = progress.conflicts.filter((c2) => c2.resolution === "unresolved").length;
    if (unresolved > 0) {
      lines.push(`\u26A0  ${unresolved} unresolved conflict${unresolved > 1 ? "s" : ""}`);
    }
  }
  if (progress.suggestedNextTopics.length > 0) {
    lines.push(`
Next: ${progress.suggestedNextTopics.join(", ")}`);
  }
  return lines.join(`
`);
}
var init_section_tracker = __esm(() => {
  init_types3();
});

// src/interview/tools/section-tools.ts
function zodToJsonSchema(schema) {
  const shape = schema.shape;
  const properties = {};
  const required = [];
  for (const [key, value] of Object.entries(shape)) {
    const zodType = value;
    const description = zodType.description;
    if (!zodType.isOptional()) {
      required.push(key);
    }
    const innerType = zodType instanceof exports_external.ZodOptional ? zodType.unwrap() : zodType;
    if (innerType instanceof exports_external.ZodString) {
      properties[key] = { type: "string", description };
    } else if (innerType instanceof exports_external.ZodNumber) {
      properties[key] = { type: "number", description };
    } else if (innerType instanceof exports_external.ZodBoolean) {
      properties[key] = { type: "boolean", description };
    } else if (innerType instanceof exports_external.ZodEnum) {
      properties[key] = {
        type: "string",
        enum: innerType.options,
        description
      };
    } else if (innerType instanceof exports_external.ZodArray) {
      properties[key] = {
        type: "array",
        items: { type: "string" },
        description
      };
    } else if (innerType instanceof exports_external.ZodDefault) {
      const defaultInner = innerType._def.innerType;
      if (defaultInner instanceof exports_external.ZodEnum) {
        properties[key] = {
          type: "string",
          enum: defaultInner.options,
          description
        };
      } else if (defaultInner instanceof exports_external.ZodNumber) {
        properties[key] = { type: "number", description };
      } else {
        properties[key] = { type: "string", description };
      }
    } else {
      properties[key] = { type: "string", description };
    }
  }
  const result = {
    type: "object",
    properties
  };
  if (required.length > 0) {
    result.required = required;
  }
  return result;
}
var CaptureSectionInputSchema, CaptureRequirementInputSchema, FlagConflictInputSchema, ReportProgressInputSchema, INTERVIEW_TOOLS;
var init_section_tools = __esm(() => {
  init_zod();
  CaptureSectionInputSchema = exports_external.object({
    sectionId: exports_external.string().describe('The PRD section ID (e.g., "executive-summary", "requirements")'),
    content: exports_external.string().describe("The content to write to this section"),
    mode: exports_external.enum(["replace", "append", "refine"]).default("replace").describe("How to update the section: replace (overwrite), append (add to end), refine (improve existing)"),
    confidence: exports_external.number().min(0).max(100).default(70).describe("Confidence level in this content (0-100)")
  });
  CaptureRequirementInputSchema = exports_external.object({
    description: exports_external.string().describe("Description of the requirement"),
    priority: exports_external.enum(["must", "should", "could"]).describe("Priority level"),
    acceptanceCriteria: exports_external.array(exports_external.string()).optional().describe("Acceptance criteria for this requirement")
  });
  FlagConflictInputSchema = exports_external.object({
    type: exports_external.enum(["user-vs-user", "user-vs-codebase", "user-vs-prd"]).describe("Type of conflict detected"),
    description: exports_external.string().describe("Description of the conflict"),
    sectionAffected: exports_external.string().describe("Which section this conflict affects"),
    earlierStatement: exports_external.string().describe("The earlier/original statement"),
    laterStatement: exports_external.string().describe("The later/conflicting statement")
  });
  ReportProgressInputSchema = exports_external.object({
    milestone: exports_external.enum(["25", "50", "75", "100"]).optional().describe("Optional milestone being reported (25%, 50%, 75%, 100%)"),
    message: exports_external.string().optional().describe("Optional message to accompany the progress report")
  });
  INTERVIEW_TOOLS = [
    {
      name: "capture_section",
      description: `Write or update content in a PRD section. Use this to capture information as you hear it from the user.

Modes:
- replace: Overwrite the entire section with new content
- append: Add content to the end of existing section
- refine: Improve/polish existing content

Available sections: executive-summary, problem-context, goals-metrics, requirements, ux-notes, dependencies-risks, rollout, milestones, open-questions, checkpoint-learnings, agent-boundaries`,
      input_schema: zodToJsonSchema(CaptureSectionInputSchema)
    },
    {
      name: "capture_requirement",
      description: `Add a requirement to the requirements table. Use this when the user mentions something that should be a formal requirement.

Priority levels:
- must: Critical for MVP, blocks launch if missing
- should: Important but not launch-blocking
- could: Nice to have, can be deferred`,
      input_schema: zodToJsonSchema(CaptureRequirementInputSchema)
    },
    {
      name: "flag_conflict",
      description: `Flag a contradiction or conflict that needs user resolution. ALWAYS use this immediately when you detect:

Types:
- user-vs-user: User said one thing earlier, now saying something different
- user-vs-codebase: User describes something that doesn't match the codebase
- user-vs-prd: New information contradicts what's already in the PRD

After flagging, present the conflict to the user and ask which direction they want to take.`,
      input_schema: zodToJsonSchema(FlagConflictInputSchema)
    },
    {
      name: "report_progress",
      description: "Report current PRD completion progress. Use this at milestones (25%, 50%, 75%) to keep the user informed of progress.",
      input_schema: zodToJsonSchema(ReportProgressInputSchema)
    }
  ];
});

// src/interview/prd-file.ts
import { existsSync as existsSync16, mkdirSync as mkdirSync6, readFileSync as readFileSync6 } from "fs";
import { join as join20 } from "path";
function getPRDsDir(projectRoot) {
  return join20(projectRoot, PRDS_DIR2);
}
function getPRDPath(projectRoot, slug) {
  return join20(getPRDsDir(projectRoot), `${slug}.md`);
}
function ensurePRDsDir(projectRoot) {
  const prdsDir = getPRDsDir(projectRoot);
  if (!existsSync16(prdsDir)) {
    mkdirSync6(prdsDir, { recursive: true });
  }
}
function generatePRDSlug(number, featureName) {
  const slug = featureName.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "").slice(0, 50);
  return `${number}_${slug}`;
}
async function createPRDFile(projectRoot, slug, frontmatter) {
  ensurePRDsDir(projectRoot);
  const prdPath = getPRDPath(projectRoot, slug);
  if (existsSync16(prdPath)) {
    throw new PRDFileError(prdPath, "create", "File already exists");
  }
  const templatePath = join20(projectRoot, TEMPLATE_PATH);
  let template;
  if (existsSync16(templatePath)) {
    template = readFileSync6(templatePath, "utf-8");
  } else {
    template = getMinimalTemplate();
  }
  const frontmatterYaml = $stringify(frontmatter, {
    indent: 2,
    lineWidth: 100
  }).trim();
  const content = template.replace(/```yaml\n# =+\n# PRD METADATA[\s\S]*?---\n```/, `\`\`\`yaml
---
${frontmatterYaml}
---
\`\`\``);
  try {
    await Bun.write(prdPath, content);
    return prdPath;
  } catch (error2) {
    throw new PRDFileError(prdPath, "create", error2.message);
  }
}
async function readPRDFile(projectRoot, slug) {
  const prdPath = getPRDPath(projectRoot, slug);
  if (!existsSync16(prdPath)) {
    throw new PRDFileError(prdPath, "read", "File not found");
  }
  try {
    return await Bun.file(prdPath).text();
  } catch (error2) {
    throw new PRDFileError(prdPath, "read", error2.message);
  }
}
async function updatePRDSection(projectRoot, slug, sectionNumber, sectionTitle, content) {
  const prdPath = getPRDPath(projectRoot, slug);
  let currentContent;
  try {
    currentContent = await readPRDFile(projectRoot, slug);
  } catch (error2) {
    throw new PRDFileError(prdPath, "update", error2.message);
  }
  const sectionPattern = new RegExp(`(## ${sectionNumber}\\. ${sectionTitle}[\\s\\S]*?)(?=## \\d+\\.|$)`, "g");
  const newContent = currentContent.replace(sectionPattern, `## ${sectionNumber}. ${sectionTitle}

${content}

`);
  try {
    await Bun.write(prdPath, newContent);
  } catch (error2) {
    throw new PRDFileError(prdPath, "update", error2.message);
  }
}
async function updatePRDStatus(projectRoot, slug, status) {
  const prdPath = getPRDPath(projectRoot, slug);
  let content;
  try {
    content = await readPRDFile(projectRoot, slug);
  } catch (error2) {
    throw new PRDFileError(prdPath, "update", error2.message);
  }
  const newContent = content.replace(/status:\s*["']?(?:draft|active|complete)["']?/, `status: "${status}"`);
  try {
    await Bun.write(prdPath, newContent);
  } catch (error2) {
    throw new PRDFileError(prdPath, "update", error2.message);
  }
}
async function appendTasks(projectRoot, slug, tasks, config) {
  const prdPath = getPRDPath(projectRoot, slug);
  let content;
  try {
    content = await readPRDFile(projectRoot, slug);
  } catch (error2) {
    throw new PRDFileError(prdPath, "update", error2.message);
  }
  const tasksYaml = tasks.map((task) => {
    const costCeiling = task.complexity * config.cost_multiplier;
    const estimatedIterations = config.base_iterations + task.complexity * config.iteration_multiplier;
    const revisionBudget = costCeiling * (config.revision_budget_percent / 100);
    return {
      id: task.id,
      title: task.title,
      description: task.description,
      depends_on: task.dependsOn,
      complexity: task.complexity,
      estimated_iterations: estimatedIterations,
      cost_ceiling: costCeiling,
      revision_budget: revisionBudget,
      priority: task.priority,
      assigned_to: "",
      success_criteria: task.successCriteria,
      files_affected: task.filesAffected,
      agent_context: task.agentContext ?? ""
    };
  });
  const tasksYamlStr = $stringify({ tasks: tasksYaml }, {
    indent: 2,
    lineWidth: 100
  });
  const tasksSection = `## Agent Tasks

\`\`\`yaml
# ============================================================
# AGENT TASKS
# This section is parsed by the KARIMO orchestrator.
# Each task becomes a GitHub Issue with custom fields.
# ============================================================

${tasksYamlStr}
\`\`\``;
  if (content.includes("## Agent Tasks")) {
    const newContent = content.replace(/## Agent Tasks[\s\S]*?```yaml[\s\S]*?```/, tasksSection);
    try {
      await Bun.write(prdPath, newContent);
    } catch (error2) {
      throw new PRDFileError(prdPath, "update", error2.message);
    }
  } else {
    const newContent = `${content.trim()}

---

${tasksSection}
`;
    try {
      await Bun.write(prdPath, newContent);
    } catch (error2) {
      throw new PRDFileError(prdPath, "update", error2.message);
    }
  }
}
function getMinimalTemplate() {
  return `# PRD

\`\`\`yaml
---
feature_name: ""
feature_slug: ""
owner: ""
status: "draft"
created_date: ""
---
\`\`\`

---

## 1. Executive Summary

**One-liner:**

**What's changing:**

**Who it's for:**

**Why now:**

**Done looks like:**

**Primary risk:**

---

## 2. Problem & Context

**Problem statement:**

**Supporting data / evidence:**

**What happens if we don't build this:**

**Strategic fit:**

---

## 3. Goals, Non-Goals & Success Metrics

### Goals

1.

### Non-Goals

-

### Success Metrics

| Metric | Baseline | Target | How Measured |
| ------ | -------- | ------ | ------------ |
|        |          |        |              |

---

## 4. Requirements

### Must Have (blocks launch)

| ID | Requirement | Acceptance Criteria |
| -- | ----------- | ------------------- |
|    |             |                     |

### Should Have (important, not blocking)

| ID | Requirement | Acceptance Criteria |
| -- | ----------- | ------------------- |
|    |             |                     |

### Could Have (nice to have, cut first)

| ID | Requirement | Acceptance Criteria |
| -- | ----------- | ------------------- |
|    |             |                     |

---

## 5. UX & Interaction Notes

**Design references:**

**Key screens & states:**

- Empty state:
- Loading state:
- Error state:
- Success state:

---

## 6. Dependencies & Risks

### External Blockers

| Blocker | Status | Fallback |
| ------- | ------ | -------- |
|         |        |          |

### Internal Dependencies

-

### Risks & Mitigations

| Risk | Likelihood | Impact | Mitigation |
| ---- | ---------- | ------ | ---------- |
|      |            |        |            |

---

## 7. Rollout Plan

**Phase/level:**

**Deployment strategy:**

**Rollback plan:**

**Monitoring:**

---

## 8. Milestones & Release Criteria

| Milestone | What's True When Done | Target Date |
| --------- | --------------------- | ----------- |
|           |                       |             |

**Release criteria (what must be true to ship):**

-

---

## 9. Open Questions

| # | Question | Status | Resolution |
| - | -------- | ------ | ---------- |
|   |          |        |            |

---

## 10. Checkpoint Learnings

**Patterns to reinforce (from previous checkpoints):**

-

**Anti-patterns to avoid:**

-

**Estimate calibration notes:**

-

---

## 11. Agent Boundaries (Phase-Specific)

**Files the agent should reference for patterns:**

-

**Files the agent should NOT touch (beyond the global \`never_touch\` list):**

-

**Architecture decisions already made (don't re-decide):**

-

**Known gotchas discovered since the implementation plan:**

-
`;
}
var PRDS_DIR2 = ".karimo/prds", TEMPLATE_PATH = "templates/PRD_TEMPLATE.md";
var init_prd_file = __esm(() => {
  init_dist();
  init_errors10();
});

// src/interview/tools/section-executor.ts
async function executeTool(toolName, input, context) {
  try {
    switch (toolName) {
      case "capture_section":
        return await executeCaptureSectionTool(input, context);
      case "capture_requirement":
        return await executeCaptureRequirementTool(input, context);
      case "flag_conflict":
        return await executeFlagConflictTool(input, context);
      case "report_progress":
        return executeReportProgressTool(input, context);
      default:
        return {
          success: false,
          toolName,
          message: "",
          error: `Unknown tool: ${toolName}`
        };
    }
  } catch (error2) {
    return {
      success: false,
      toolName,
      message: "",
      error: error2 instanceof Error ? error2.message : String(error2)
    };
  }
}
async function executeCaptureSectionTool(input, context) {
  const parsed = CaptureSectionInputSchema.safeParse(input);
  if (!parsed.success) {
    return {
      success: false,
      toolName: "capture_section",
      message: "",
      error: `Invalid input: ${parsed.error.message}`
    };
  }
  const { sectionId, content, confidence } = parsed.data;
  const sectionInfo = getSectionInfo(sectionId);
  if (!sectionInfo) {
    return {
      success: false,
      toolName: "capture_section",
      message: "",
      error: `Unknown section: ${sectionId}`
    };
  }
  await updatePRDSection(context.projectRoot, context.prdSlug, sectionInfo.number, sectionInfo.title, content);
  const status = confidence >= 90 ? "complete" : "partial";
  context.tracker.updateSection(sectionId, status, confidence);
  const progress = context.tracker.getProgress();
  return {
    success: true,
    toolName: "capture_section",
    message: `\u2713 Captured ${sectionInfo.heading} (${confidence}% confidence)`,
    progress
  };
}
async function executeCaptureRequirementTool(input, context) {
  const parsed = CaptureRequirementInputSchema.safeParse(input);
  if (!parsed.success) {
    return {
      success: false,
      toolName: "capture_requirement",
      message: "",
      error: `Invalid input: ${parsed.error.message}`
    };
  }
  const { description, priority, acceptanceCriteria } = parsed.data;
  const acText = acceptanceCriteria?.length ? `
  - Acceptance: ${acceptanceCriteria.join("; ")}` : "";
  const reqText = `- **[${priority.toUpperCase()}]** ${description}${acText}`;
  const sectionInfo = getSectionInfo("requirements");
  if (!sectionInfo) {
    return {
      success: false,
      toolName: "capture_requirement",
      message: "",
      error: "Could not find requirements section"
    };
  }
  await updatePRDSection(context.projectRoot, context.prdSlug, sectionInfo.number, sectionInfo.title, reqText);
  const currentSection = context.tracker.getSection("requirements");
  const newConfidence = Math.min(100, (currentSection?.confidence ?? 0) + 10);
  context.tracker.updateSection("requirements", "partial", newConfidence);
  const progress = context.tracker.getProgress();
  return {
    success: true,
    toolName: "capture_requirement",
    message: `\u2713 Added ${priority} requirement: "${description.slice(0, 50)}..."`,
    progress
  };
}
async function executeFlagConflictTool(input, context) {
  const parsed = FlagConflictInputSchema.safeParse(input);
  if (!parsed.success) {
    return {
      success: false,
      toolName: "flag_conflict",
      message: "",
      error: `Invalid input: ${parsed.error.message}`
    };
  }
  const { type, description, sectionAffected, earlierStatement, laterStatement } = parsed.data;
  const conflict = context.tracker.addConflict(type, description, sectionAffected, earlierStatement, laterStatement);
  const progress = context.tracker.getProgress();
  const formattedConflict = formatConflict(conflict);
  return {
    success: true,
    toolName: "flag_conflict",
    message: formattedConflict,
    progress,
    isConflict: true
  };
}
function executeReportProgressTool(input, context) {
  const parsed = ReportProgressInputSchema.safeParse(input);
  if (!parsed.success) {
    return {
      success: false,
      toolName: "report_progress",
      message: "",
      error: `Invalid input: ${parsed.error.message}`
    };
  }
  const { milestone, message } = parsed.data;
  const progress = context.tracker.getProgress();
  let progressMessage = formatProgressBar(progress.overallPercent);
  if (milestone) {
    progressMessage = `\uD83C\uDF1F ${milestone}% Milestone: ${progressMessage}`;
  }
  if (message) {
    progressMessage += `
   ${message}`;
  }
  return {
    success: true,
    toolName: "report_progress",
    message: progressMessage,
    progress
  };
}
function getSectionInfo(sectionId) {
  const sections = {
    "executive-summary": { number: 1, title: "Executive Summary", heading: "1. Executive Summary" },
    "problem-context": { number: 2, title: "Problem & Context", heading: "2. Problem & Context" },
    "goals-metrics": { number: 3, title: "Goals & Metrics", heading: "3. Goals & Metrics" },
    requirements: { number: 4, title: "Requirements", heading: "4. Requirements" },
    "ux-notes": { number: 5, title: "UX Notes", heading: "5. UX Notes" },
    "dependencies-risks": {
      number: 6,
      title: "Dependencies & Risks",
      heading: "6. Dependencies & Risks"
    },
    rollout: { number: 7, title: "Rollout", heading: "7. Rollout" },
    milestones: { number: 8, title: "Milestones", heading: "8. Milestones" },
    "open-questions": { number: 9, title: "Open Questions", heading: "9. Open Questions" },
    "checkpoint-learnings": {
      number: 10,
      title: "Checkpoint Learnings",
      heading: "10. Checkpoint Learnings"
    },
    "agent-boundaries": { number: 11, title: "Agent Boundaries", heading: "11. Agent Boundaries" }
  };
  return sections[sectionId] ?? null;
}
function createToolExecutor(context) {
  return {
    execute: (toolName, input) => executeTool(toolName, input, context),
    getProgress: () => context.tracker.getProgress(),
    getTracker: () => context.tracker
  };
}
var init_section_executor = __esm(() => {
  init_prd_file();
  init_section_tracker();
  init_section_tools();
  init_section_tools();
});

// src/interview/tools/index.ts
var init_tools = __esm(() => {
  init_section_tools();
  init_section_executor();
});

// src/interview/agents/conversational-agent.ts
async function processConversationalMessage(messages, userMessage, options) {
  const {
    projectRoot,
    prdSlug,
    prdContent,
    projectConfig,
    tracker,
    onChunk,
    onToolResult,
    onProgress
  } = options;
  const progress = tracker.getProgress();
  const progressSummary = formatProgressSummary(progress);
  const systemPrompt = `${CONVERSATIONAL_SYSTEM_PROMPT}

## Current State
${progressSummary}

## Project Config
${projectConfig}

## Current PRD Content
${prdContent}`;
  const updatedMessages = [
    ...messages,
    {
      role: "user",
      content: userMessage
    }
  ];
  const executionContext = {
    projectRoot,
    prdSlug,
    tracker,
    currentPrdContent: prdContent
  };
  const toolCalls = [];
  let response = "";
  const toolDefs = INTERVIEW_TOOLS.map((t) => ({
    name: t.name,
    description: t.description,
    input_schema: t.input_schema
  }));
  const result = await streamMessageWithTools(systemPrompt, updatedMessages, toolDefs, onChunk);
  response = result.response;
  if (result.toolUse && result.toolUse.length > 0) {
    const toolResults = [];
    const assistantContent = [];
    if (result.response) {
      assistantContent.push({ type: "text", text: result.response });
    }
    for (const toolCall of result.toolUse) {
      assistantContent.push({
        type: "tool_use",
        id: toolCall.id,
        name: toolCall.name,
        input: toolCall.input
      });
      if (isValidToolName2(toolCall.name)) {
        const toolResult = await executeTool(toolCall.name, toolCall.input, executionContext);
        toolCalls.push(toolResult);
        onToolResult?.(toolResult);
        toolResults.push({
          toolUseId: toolCall.id,
          content: toolResult.success ? toolResult.message : `Error: ${toolResult.error}`
        });
      }
    }
    if (toolResults.length > 0) {
      const continuation = await streamContinueWithToolResults(systemPrompt, updatedMessages, assistantContent, toolResults, toolDefs, onChunk);
      if (continuation.response) {
        response = response ? `${response}

${continuation.response}` : continuation.response;
      }
    }
  }
  const finalProgress = tracker.getProgress();
  onProgress?.(finalProgress);
  return {
    response,
    toolCalls,
    progress: finalProgress,
    offerFinalize: tracker.isReadyForFinalizationOffer(),
    suggestFinalize: tracker.shouldSuggestFinalization()
  };
}
function isValidToolName2(name) {
  return ["capture_section", "capture_requirement", "flag_conflict", "report_progress"].includes(name);
}
async function startConversationalInterview(options) {
  const tracker = options.tracker ?? new SectionTracker;
  const greeting = `I'm here to help you define your product requirements. Tell me about what you're building - you can share as much context as you'd like, whether it's a rough idea, meeting notes, or detailed specs. I'll extract the key information as we talk.

What feature or project are you working on?`;
  return {
    response: greeting,
    toolCalls: [],
    progress: tracker.getProgress(),
    offerFinalize: false,
    suggestFinalize: false
  };
}
var CONVERSATIONAL_SYSTEM_PROMPT = `You are KARIMO's Interview Agent. You help users define their product requirements through natural conversation.

## Your Approach
- LISTEN first, then extract. Do not interrogate.
- Use tools to capture AS YOU HEAR IT. Don't wait.
- SUMMARIZE what you captured, PROBE for gaps.
- Report progress at 25%, 50%, 75%, completion.

## Available Tools
You have access to these tools - use them frequently:

1. **capture_section** - Write/update PRD section content as you hear it
   - Use mode "replace" to overwrite, "append" to add, "refine" to improve
   - Set confidence based on how sure you are (70+ for clear info)

2. **capture_requirement** - Add requirements to the table
   - Categorize as must/should/could priority
   - Include acceptance criteria when the user specifies them

3. **flag_conflict** - Flag contradictions IMMEDIATELY
   - Never silently resolve conflicts
   - Present both statements to user and ask which direction

4. **report_progress** - Report completion at milestones
   - Use at 25%, 50%, 75%, and when nearing completion

## Conflict Detection \u2014 CRITICAL
You MUST flag contradictions immediately. Never silently resolve.

Types of conflicts:
- **user-vs-user**: User said one thing earlier, now saying something different
  Example: "MVP quality" then later "polished animations on every state"
- **user-vs-codebase**: User describes something that doesn't match the codebase
  Example: References a component that doesn't exist
- **user-vs-prd**: New information contradicts what's already in the PRD
  Example: Changing scope after sections are filled

When conflict detected:
1. Call flag_conflict tool immediately
2. Tell user: "I noticed [X] vs [Y]. Which direction?"
3. Do NOT write conflicting info until resolved

## Conversation Flow
1. User provides context (may be stream-of-consciousness)
2. You extract and capture using tools
3. You summarize what you captured
4. You probe for gaps
5. Repeat until PRD is complete

## Rules
- Never fabricate. Only capture what user said.
- If unsure, set confidence low and ask.
- Parse stream-of-consciousness input - users may ramble.
- If 3+ exchanges without capturing anything, you're interrogating. Stop.
- Keep responses concise. Don't repeat what user said back verbatim.

## PRD Sections (weights)
- Executive Summary (15%) - One-liner, what's changing, who it's for
- Problem & Context (10%) - Problem statement, why now
- Goals & Metrics (15%) - Goals, non-goals, success metrics
- Requirements (20%) - Must/should/could with acceptance criteria
- UX Notes (10%) - User experience considerations
- Dependencies & Risks (10%) - Blockers, dependencies, risks
- Rollout (5%) - Release strategy
- Milestones (5%) - Key milestones
- Checkpoint Learnings (5%) - Patterns to reinforce/avoid
- Agent Boundaries (5%) - Files to reference/protect`;
var init_conversational_agent = __esm(() => {
  init_conversation();
  init_section_tracker();
  init_tools();
});

// src/interview/agents/intake-agent.ts
async function processIntake(userContext, options = {}) {
  const { onChunk } = options;
  const messages = [
    {
      role: "user",
      content: userContext,
      timestamp: new Date().toISOString()
    }
  ];
  const response = await collectStreamedResponse(INTAKE_SYSTEM_PROMPT, messages, onChunk);
  const result = parseIntakeResponse(response);
  return result;
}
function parseIntakeResponse(response) {
  let jsonStr = response.trim();
  const jsonMatch = response.match(/```(?:json)?\s*([\s\S]*?)```/);
  if (jsonMatch?.[1]) {
    jsonStr = jsonMatch[1].trim();
  }
  let parsed;
  try {
    parsed = JSON.parse(jsonStr);
  } catch {
    const objectMatch = response.match(/\{[\s\S]*\}/);
    if (objectMatch) {
      try {
        parsed = JSON.parse(objectMatch[0]);
      } catch {
        throw new Error(`Failed to parse intake response as JSON: ${response.slice(0, 200)}`);
      }
    } else {
      throw new Error(`No JSON object found in intake response: ${response.slice(0, 200)}`);
    }
  }
  const validated = IntakeResultSchema.parse(parsed);
  return validated;
}
var IntakeResultSchema, INTAKE_SYSTEM_PROMPT = `You are KARIMO's Intake Agent. Your job is to process initial context from users and extract structured information for a Product Requirements Document (PRD).

## Your Task
The user will provide context about a feature they want to build. This could be:
- A stream-of-consciousness brain dump
- Notes from a meeting
- A rough idea with some details
- A detailed specification

From their input, extract and synthesize:

1. **suggestedTitle**: A concise, descriptive title for the feature (2-5 words)
2. **suggestedSlug**: A URL-safe slug derived from the title (lowercase, hyphens only)
3. **executiveSummary**: A one-sentence summary of what this feature does
4. **scopeType**: One of: "new-feature", "refactor", "migration", "integration"
5. **identifiedTopics**: Key topics/areas mentioned in their input
6. **gapsToExplore**: Questions or areas that need clarification
7. **initialSections**: Pre-fill any PRD sections you can from their input

## PRD Sections You Can Pre-fill
- executive-summary: One-liner, what's changing, who it's for, why now
- problem-context: Problem statement, supporting data, cost of inaction
- goals-metrics: Goals, non-goals, success metrics
- requirements: Must-have, should-have, could-have requirements
- ux-notes: User experience considerations
- dependencies-risks: External blockers, dependencies, risks
- rollout: Release strategy
- milestones: Key milestones
- agent-boundaries: Files to reference, files to protect, architecture decisions

## Output Format
Respond with valid JSON matching this structure:
\`\`\`json
{
  "suggestedTitle": "Feature Name",
  "suggestedSlug": "feature-name",
  "executiveSummary": "One sentence describing the feature",
  "scopeType": "new-feature",
  "identifiedTopics": ["topic1", "topic2"],
  "gapsToExplore": ["What is unclear?", "Need more info on..."],
  "initialSections": {
    "executive-summary": "Pre-filled content...",
    "requirements": "Pre-filled content..."
  }
}
\`\`\`

## Rules
1. Extract only what the user explicitly said - never fabricate
2. If unsure, list it as a gap to explore rather than guessing
3. Be concise - this is initial extraction, not final content
4. The slug must be URL-safe (lowercase letters, numbers, hyphens only)
5. Respond ONLY with the JSON object, no additional text`;
var init_intake_agent = __esm(() => {
  init_zod();
  init_conversation();
  IntakeResultSchema = exports_external.object({
    suggestedTitle: exports_external.string().min(1),
    suggestedSlug: exports_external.string().min(1).regex(/^[a-z0-9-]+$/),
    executiveSummary: exports_external.string().min(1),
    scopeType: exports_external.enum(["new-feature", "refactor", "migration", "integration"]),
    identifiedTopics: exports_external.array(exports_external.string()),
    gapsToExplore: exports_external.array(exports_external.string()),
    initialSections: exports_external.record(exports_external.string())
  });
});

// src/interview/context-manager.ts
function estimateTokens(text) {
  return Math.ceil(text.length / CHARS_PER_TOKEN);
}
function estimateMessagesTokens(messages) {
  let total = 0;
  for (const msg of messages) {
    total += estimateTokens(msg.content) + 10;
  }
  return total;
}
function estimateSummariesTokens(summaries) {
  let total = 0;
  for (const summary of summaries) {
    total += estimateTokens(summary.summary) + 20;
  }
  return total;
}
function calculateContextTokens(session, systemPromptTokens, prdContentTokens) {
  const messagesTokens = estimateMessagesTokens(session.messages);
  const summariesTokens = estimateSummariesTokens(session.summaries);
  return systemPromptTokens + prdContentTokens + messagesTokens + summariesTokens;
}
function isNearCapacity(currentTokens, threshold = SUMMARIZATION_THRESHOLD) {
  const effectiveMax = MAX_CONTEXT_TOKENS - RESERVED_TOKENS;
  return currentTokens >= effectiveMax * threshold;
}
function getAvailableTokens(currentTokens) {
  return Math.max(0, MAX_CONTEXT_TOKENS - currentTokens - RESERVED_TOKENS);
}
function getContextState(session, systemPromptTokens, prdContentTokens) {
  const currentTokens = calculateContextTokens(session, systemPromptTokens, prdContentTokens);
  const effectiveMax = MAX_CONTEXT_TOKENS - RESERVED_TOKENS;
  return {
    currentTokens,
    maxTokens: MAX_CONTEXT_TOKENS,
    needsSummarization: isNearCapacity(currentTokens),
    availableTokens: getAvailableTokens(currentTokens),
    utilizationPercent: Math.round(currentTokens / effectiveMax * 100)
  };
}
function buildSummarizationPrompt(messages, currentRound) {
  const conversation = messages.map((m2) => `${m2.role === "user" ? "User" : "Assistant"}: ${m2.content}`).join(`

`);
  return `Summarize the following interview conversation from the "${currentRound}" round.
Capture:
- Key decisions made
- Requirements discussed
- Important context provided
- Any questions that were answered
- Outstanding items or concerns

Keep the summary concise but preserve critical details that would be needed to continue the interview.

Conversation:
${conversation}

Summary:`;
}
function buildHandoffContext(session, prdContent, roundContext, recentMessageCount = 4) {
  const previousSummaries = session.summaries.map((s) => `[${s.round}] ${s.summary}`).join(`

`);
  const recentMessages = session.messages.slice(-recentMessageCount);
  return {
    previousSummaries,
    prdContent,
    recentMessages,
    roundContext
  };
}
function formatHandoffContext(context) {
  const parts = [];
  if (context.previousSummaries) {
    parts.push(`## Previous Conversation Summary

${context.previousSummaries}`);
  }
  if (context.prdContent) {
    parts.push(`## Current PRD State

${context.prdContent}`);
  }
  if (context.roundContext) {
    parts.push(`## Current Round Context

${context.roundContext}`);
  }
  return parts.join(`

---

`);
}
var CHARS_PER_TOKEN = 4, MAX_CONTEXT_TOKENS = 180000, SUMMARIZATION_THRESHOLD = 0.9, RESERVED_TOKENS = 1e4;

// src/interview/section-mapper.ts
function getRoundSystemPrompt(round, projectConfig, checkpointData) {
  const basePrompt = `You are KARIMO, an expert product manager conducting a PRD interview.
Your goal is to gather all the information needed to create an agent-executable PRD.

## Project Configuration
${projectConfig}

## Your Style
- Be conversational but efficient
- Ask one main question at a time, with follow-ups as needed
- Summarize what you've captured before moving on
- If something is unclear, ask for clarification
- When the user provides enough information, acknowledge it and move to the next topic

## Interview Protocol
You are conducting Round ${getRoundNumber(round)} of 5: ${getRoundDisplayName(round)}
`;
  const roundPrompts = {
    framing: `${basePrompt}

## Round 1: Framing (~5 minutes)

Your goal is to establish scope, success criteria, and risk.

### Questions to Cover
1. **What are we building?** - Get a plain language description of the feature
2. **What would you demo when this is done?** - Understand the tangible outcome
3. **What's the biggest risk?** - Identify what could go wrong
4. **Is this MVP or polished?** - Understand the ambition level
5. **Who uses this?** - Understand the target user and their workflow change

### Conditional Follow-Ups
- If it touches data models: Ask about migration risk and rollback
- If there are external dependencies: Ask if they're ready and what the fallback is
- If there's a tight deadline: Ask what can be cut

### After This Round
- Summarize in 2-3 sentences
- State the scope classification: new feature / refactor / migration / integration
- Confirm with the user before proceeding

Start by greeting the user and asking about what we're building.`,
    requirements: `${basePrompt}

## Round 2: Requirements (~10 minutes)

Your goal is to break the feature into concrete requirements with priorities and acceptance criteria.

### Questions to Cover
1. Walk through each component from Round 1
2. For each: Is it Must (blocks launch), Should (important), or Could (nice to have)?
3. For Must items: What are the specific acceptance criteria?
4. For Should/Could: Is this the first thing to cut if over budget?
5. Are there requirements being assumed that weren't said?
6. What should the agent definitely NOT do?

### Conditional Follow-Ups
- If complexity > 6: Suggest splitting into multiple tasks
- If boundaries unclear: Draw a hard line on scope
- If UI work: Ask about design refs and responsive requirements
- If data work: Ask about validation and error states

### After This Round
- Read back the prioritized requirement list
- Flag any requirements too large for a single task
- Confirm before proceeding`,
    dependencies: `${basePrompt}

## Round 3: Dependencies & Architecture (~5 minutes)

Your goal is to establish task ordering, parallel opportunities, and file-level scope.

### Questions to Cover
1. Which requirements can be worked on independently?
2. Which must complete before others start? What's the dependency chain?
3. Are there files multiple requirements will touch? (Explain file-overlap detection)
4. Are there external blockers? APIs not ready? Design decisions not made?
5. What's the testing strategy? Existing tests? New tests needed?

### Conditional Follow-Ups
- If file overlap detected: Suggest restructuring or sequential execution
- If shared service needed: Suggest extracting as its own task
- If external blockers: Ask about fallback/stub strategy

### After This Round
- Present the dependency graph in text form
- Flag file overlaps
- Confirm ordering makes sense`,
    "agent-context": `${basePrompt}

## Round 4: Agent Context (~5 minutes)

Your goal is to give agents specific guidance to produce mergeable code on the first attempt.

### Questions to Cover
1. For each task, are there existing files or patterns to follow?
2. Any gotchas that aren't documented?
3. How should edge cases be handled? Fail loudly, degrade gracefully, or leave TODO?
4. Are there design tokens, component libraries, or style patterns to use?
5. What would make you reject a PR? What's your code review checklist?

### Conditional Follow-Ups
- If UI: Component structure? Accessibility? Responsive breakpoints?
- If data/database: Validation rules? Row-level security? Migrations?
- If API routes: Auth pattern? Error format? Rate limiting?

### After This Round
- Summarize agent context per task
- Flag under-specified tasks
- Confirm if there's anything else to tell a developer`,
    retrospective: `${basePrompt}

## Round 5: Retrospective Input (~3 minutes)

Your goal is to feed compound learning data into the current plan.

${checkpointData ? `### Checkpoint Data Available
${checkpointData}

### Questions to Cover
1. Summarize the patterns that worked and anti-patterns that were flagged
2. Note cost estimate accuracy from previous phases
3. Does any of this change how we should approach this feature?
4. Are there new rules to add? Things agents should always/never do?
5. Does the cost multiplier feel right?

### After This Round
- Note adjustments to estimates or context
- Confirm you'll incorporate learnings into the PRD` : `### No Checkpoint Data
No checkpoint data from previous phases. This will be collected after the first task completes.

Let the user know this and ask if they have any general learnings from previous work they'd like to incorporate.`}`
  };
  return roundPrompts[round];
}
function getRoundDisplayName(round) {
  const names = {
    framing: "Framing",
    requirements: "Requirements",
    dependencies: "Dependencies & Architecture",
    "agent-context": "Agent Context",
    retrospective: "Retrospective Input"
  };
  return names[round];
}
function getRoundNumber(round) {
  const rounds = [
    "framing",
    "requirements",
    "dependencies",
    "agent-context",
    "retrospective"
  ];
  return rounds.indexOf(round) + 1;
}
function getRoundContext(round, projectConfig, checkpointData) {
  const sections = ROUND_TO_SECTIONS[round];
  const dataFields = sections.flatMap((s) => s.fields);
  const estimatedMinutes = {
    framing: 5,
    requirements: 10,
    dependencies: 5,
    "agent-context": 5,
    retrospective: 3
  };
  const questions = {
    framing: [
      "What are we building?",
      "What would you demo when this is done?",
      "What's the biggest risk?",
      "Is this MVP or polished?",
      "Who uses this and how does their workflow change?"
    ],
    requirements: [
      "What are the Must Have requirements?",
      "What are the Should Have requirements?",
      "What are the Could Have requirements?",
      "What are the acceptance criteria for each Must Have?",
      "What should the agent definitely NOT do?"
    ],
    dependencies: [
      "Which requirements can be worked on independently?",
      "What's the dependency chain?",
      "Are there files multiple requirements will touch?",
      "Are there external blockers?",
      "What's the testing strategy?"
    ],
    "agent-context": [
      "Are there existing files or patterns to follow?",
      "Any undocumented gotchas?",
      "How should edge cases be handled?",
      "What design tokens or libraries should be used?",
      "What would make you reject a PR?"
    ],
    retrospective: [
      "What patterns worked well in previous work?",
      "What anti-patterns should be avoided?",
      "How accurate were previous cost estimates?",
      "Should any new rules be added?",
      "Does the cost multiplier feel right?"
    ]
  };
  return {
    round,
    systemPrompt: getRoundSystemPrompt(round, projectConfig, checkpointData),
    questions: questions[round],
    dataFields,
    estimatedMinutes: estimatedMinutes[round]
  };
}
function getReviewSystemPrompt(prdContent) {
  return `You are KARIMO's PRD Review Agent.
Your job is to review a completed PRD and identify issues before it's finalized.

## The PRD to Review
${prdContent}

## What to Check

### Critical Issues (Errors)
- Missing acceptance criteria for Must Have requirements
- Tasks with no success criteria
- Circular dependencies
- Missing required fields

### Important Issues (Warnings)
- High complexity tasks (>6) not broken down
- Vague or unmeasurable success metrics
- Missing edge case handling
- Unclear scope boundaries

### Suggestions
- Conflicting requirements
- Missing test coverage
- Potential parallelization opportunities
- Risk mitigations that could be stronger

## Output Format
Provide a structured review with:
1. Overall score (1-10)
2. List of issues with severity, category, description, location, and suggestion
3. Summary of PRD quality
4. Recommendations before finalization

Be thorough but constructive. The goal is to help create a better PRD.`;
}
var ROUND_TO_SECTIONS;
var init_section_mapper = __esm(() => {
  ROUND_TO_SECTIONS = {
    framing: [
      {
        sectionNumber: 1,
        sectionTitle: "Executive Summary",
        fields: [
          "one_liner",
          "whats_changing",
          "who_its_for",
          "why_now",
          "done_looks_like",
          "primary_risk"
        ]
      }
    ],
    requirements: [
      {
        sectionNumber: 3,
        sectionTitle: "Goals, Non-Goals & Success Metrics",
        fields: ["goals", "non_goals", "success_metrics"]
      },
      {
        sectionNumber: 4,
        sectionTitle: "Requirements",
        fields: ["must_have", "should_have", "could_have"]
      },
      {
        sectionNumber: 5,
        sectionTitle: "UX & Interaction Notes",
        fields: ["design_refs", "screens_states", "accessibility", "responsive"]
      }
    ],
    dependencies: [
      {
        sectionNumber: 6,
        sectionTitle: "Dependencies & Risks",
        fields: ["external_blockers", "internal_deps", "risks"]
      },
      {
        sectionNumber: 7,
        sectionTitle: "Rollout Plan",
        fields: ["phase", "deployment", "rollback", "monitoring"]
      },
      {
        sectionNumber: 8,
        sectionTitle: "Milestones & Release Criteria",
        fields: ["milestones", "release_criteria"]
      }
    ],
    "agent-context": [
      {
        sectionNumber: 11,
        sectionTitle: "Agent Boundaries (Phase-Specific)",
        fields: ["reference_files", "protected_files", "arch_decisions", "gotchas"]
      }
    ],
    retrospective: [
      {
        sectionNumber: 10,
        sectionTitle: "Checkpoint Learnings",
        fields: ["patterns_to_reinforce", "anti_patterns", "estimate_calibration"]
      }
    ]
  };
});

// src/interview/session.ts
import { existsSync as existsSync17, mkdirSync as mkdirSync7 } from "fs";
import { join as join21 } from "path";
function getSessionPath(projectRoot, prdSlug) {
  return join21(projectRoot, SESSIONS_DIR, `${prdSlug}.json`);
}
function getSessionsDir(projectRoot) {
  return join21(projectRoot, SESSIONS_DIR);
}
function sessionExists(projectRoot, prdSlug) {
  return existsSync17(getSessionPath(projectRoot, prdSlug));
}
async function loadSession(projectRoot, prdSlug) {
  const sessionPath = getSessionPath(projectRoot, prdSlug);
  if (!existsSync17(sessionPath)) {
    throw new SessionLoadError(prdSlug, "Session file not found");
  }
  try {
    const content = await Bun.file(sessionPath).text();
    const session = JSON.parse(content);
    return session;
  } catch (error2) {
    throw new SessionLoadError(prdSlug, error2.message);
  }
}
async function saveSession(projectRoot, session) {
  const sessionsDir = getSessionsDir(projectRoot);
  const sessionPath = getSessionPath(projectRoot, session.prdSlug);
  if (!existsSync17(sessionsDir)) {
    mkdirSync7(sessionsDir, { recursive: true });
  }
  session.updatedAt = new Date().toISOString();
  try {
    const content = JSON.stringify(session, null, 2);
    await Bun.write(sessionPath, content);
  } catch (error2) {
    throw new SessionSaveError(session.prdSlug, error2.message);
  }
}
async function createSession(projectRoot, prdSlug, prdPath) {
  const session = createDefaultSession(prdSlug, prdPath);
  await saveSession(projectRoot, session);
  return session;
}
function addMessage(session, role, content) {
  const message = {
    role,
    content,
    timestamp: new Date().toISOString()
  };
  return {
    ...session,
    messages: [...session.messages, message],
    updatedAt: new Date().toISOString()
  };
}
function addSummary(session, summary, messageCount) {
  const conversationSummary = {
    summary,
    round: session.currentRound,
    messageCount,
    timestamp: new Date().toISOString()
  };
  return {
    ...session,
    summaries: [...session.summaries, conversationSummary],
    messages: [],
    updatedAt: new Date().toISOString()
  };
}
function advanceRound(session) {
  const currentIndex = ROUND_ORDER.indexOf(session.currentRound);
  if (currentIndex === -1) {
    throw new Error(`Invalid round: ${session.currentRound}`);
  }
  const nextIndex = currentIndex + 1;
  if (nextIndex >= ROUND_ORDER.length) {
    return {
      ...session,
      completedRounds: [...session.completedRounds, session.currentRound],
      status: "reviewing",
      updatedAt: new Date().toISOString()
    };
  }
  const nextRound = ROUND_ORDER[nextIndex];
  if (!nextRound) {
    throw new Error(`Invalid round index: ${nextIndex}`);
  }
  return {
    ...session,
    completedRounds: [...session.completedRounds, session.currentRound],
    currentRound: nextRound,
    updatedAt: new Date().toISOString()
  };
}
function updateTokenCount(session, tokens) {
  return {
    ...session,
    estimatedTokens: tokens,
    updatedAt: new Date().toISOString()
  };
}
function isLastRound(round) {
  return round === ROUND_ORDER[ROUND_ORDER.length - 1];
}
function getRoundDisplayName2(round) {
  const names = {
    framing: "Framing",
    requirements: "Requirements",
    dependencies: "Dependencies",
    "agent-context": "Agent Context",
    retrospective: "Retrospective"
  };
  return names[round];
}
function getRoundNumber2(round) {
  return ROUND_ORDER.indexOf(round) + 1;
}
function getRoundEstimatedMinutes(round) {
  const minutes = {
    framing: 5,
    requirements: 10,
    dependencies: 5,
    "agent-context": 5,
    retrospective: 3
  };
  return minutes[round];
}
function addSubagentExecution(session, entry) {
  return {
    ...session,
    subagentHistory: [...session.subagentHistory, entry],
    updatedAt: new Date().toISOString()
  };
}
function updateSubagentUsage(session, usage) {
  const current = session.subagentUsage;
  return {
    ...session,
    subagentUsage: {
      model: usage.model,
      inputTokens: current.inputTokens + usage.inputTokens,
      outputTokens: current.outputTokens + usage.outputTokens,
      cacheReadTokens: (current.cacheReadTokens ?? 0) + (usage.cacheReadTokens ?? 0)
    },
    updatedAt: new Date().toISOString()
  };
}
function recordSubagentExecution(session, entry) {
  const withHistory = addSubagentExecution(session, entry);
  return updateSubagentUsage(withHistory, entry.result.usage);
}
function getSubagentUsageSummary(session) {
  const summary = {
    totalExecutions: session.subagentHistory.length,
    successfulExecutions: 0,
    failedExecutions: 0,
    byType: {},
    byParent: {},
    totalInputTokens: session.subagentUsage.inputTokens,
    totalOutputTokens: session.subagentUsage.outputTokens,
    totalTokens: session.subagentUsage.inputTokens + session.subagentUsage.outputTokens
  };
  for (const entry of session.subagentHistory) {
    if (entry.result.status === "completed") {
      summary.successfulExecutions++;
    } else if (entry.result.status === "failed") {
      summary.failedExecutions++;
    }
    summary.byType[entry.request.type] = (summary.byType[entry.request.type] ?? 0) + 1;
    summary.byParent[entry.request.parent] = (summary.byParent[entry.request.parent] ?? 0) + 1;
  }
  return summary;
}
function clearSubagentHistory(session) {
  return {
    ...session,
    subagentHistory: [],
    subagentUsage: {
      model: "claude-sonnet-4-20250514",
      inputTokens: 0,
      outputTokens: 0,
      cacheReadTokens: 0
    },
    updatedAt: new Date().toISOString()
  };
}
var SESSIONS_DIR = ".karimo/sessions", ROUND_ORDER;
var init_session = __esm(() => {
  init_errors10();
  init_types3();
  ROUND_ORDER = [
    "framing",
    "requirements",
    "dependencies",
    "agent-context",
    "retrospective"
  ];
});

// src/interview/agents/interview-agent.ts
function isRoundComplete(response) {
  const completionIndicators = [
    /ready to move on/i,
    /proceed to (?:the )?next round/i,
    /let's move on to/i,
    /that covers (?:round|the framing|requirements|dependencies)/i,
    /shall we proceed/i,
    /move forward/i
  ];
  return completionIndicators.some((pattern) => pattern.test(response));
}
async function processMessage(session, userMessage, options) {
  const {
    projectRoot,
    projectConfig,
    checkpointData,
    prdContent,
    onChunk,
    onRoundComplete,
    onSummarization
  } = options;
  let updatedSession = addMessage(session, "user", userMessage);
  const systemPrompt = getRoundSystemPrompt(updatedSession.currentRound, projectConfig, checkpointData);
  const systemTokens = estimateTokens(systemPrompt);
  const prdTokens = estimateTokens(prdContent);
  const contextState = getContextState(updatedSession, systemTokens, prdTokens);
  if (contextState.needsSummarization) {
    onSummarization?.();
    const summaryPrompt = buildSummarizationPrompt(updatedSession.messages, updatedSession.currentRound);
    const summaryMessages = [
      { role: "user", content: summaryPrompt, timestamp: new Date().toISOString() }
    ];
    const summary = await collectStreamedResponse("You are a helpful assistant that summarizes conversations concisely.", summaryMessages);
    updatedSession = addSummary(updatedSession, summary, updatedSession.messages.length);
  }
  let fullSystemPrompt = systemPrompt;
  if (updatedSession.summaries.length > 0) {
    const summaryContext = updatedSession.summaries.map((s) => `[${s.round}] ${s.summary}`).join(`

`);
    fullSystemPrompt = `${systemPrompt}

## Previous Conversation Summary
${summaryContext}

## Current PRD State
${prdContent}

Continue the interview from where we left off.`;
  } else if (prdContent) {
    fullSystemPrompt = `${systemPrompt}

## Current PRD State
${prdContent}`;
  }
  const response = await collectStreamedResponse(fullSystemPrompt, updatedSession.messages, onChunk);
  updatedSession = addMessage(updatedSession, "assistant", response);
  const newContextState = getContextState(updatedSession, estimateTokens(fullSystemPrompt), prdTokens);
  updatedSession = updateTokenCount(updatedSession, newContextState.currentTokens);
  const roundComplete = isRoundComplete(response);
  let allComplete = false;
  if (roundComplete) {
    onRoundComplete?.(updatedSession.currentRound);
    if (isLastRound(updatedSession.currentRound)) {
      allComplete = true;
      updatedSession = { ...updatedSession, status: "reviewing" };
    } else {
      updatedSession = advanceRound(updatedSession);
    }
  }
  await saveSession(projectRoot, updatedSession);
  return {
    session: updatedSession,
    response,
    roundComplete,
    allComplete
  };
}
async function startInterview(session, options) {
  const { projectConfig, checkpointData, prdContent, onChunk } = options;
  const systemPrompt = getRoundSystemPrompt(session.currentRound, projectConfig, checkpointData);
  let fullSystemPrompt = systemPrompt;
  if (prdContent) {
    fullSystemPrompt = `${systemPrompt}

## Current PRD State
${prdContent}`;
  }
  const initialMessages = [
    {
      role: "user",
      content: "Hello! I'm ready to start the PRD interview.",
      timestamp: new Date().toISOString()
    }
  ];
  const response = await collectStreamedResponse(fullSystemPrompt, initialMessages, onChunk);
  const firstMessage = initialMessages[0];
  if (!firstMessage) {
    throw new Error("No initial message provided");
  }
  let updatedSession = addMessage(session, "user", firstMessage.content);
  updatedSession = addMessage(updatedSession, "assistant", response);
  updatedSession = { ...updatedSession, status: "in-progress" };
  await saveSession(options.projectRoot, updatedSession);
  return {
    session: updatedSession,
    response,
    roundComplete: false,
    allComplete: false
  };
}
async function resumeInterview(session, options) {
  const { projectConfig, checkpointData, prdContent, onChunk } = options;
  const systemPrompt = getRoundSystemPrompt(session.currentRound, projectConfig, checkpointData);
  let fullSystemPrompt = systemPrompt;
  if (session.summaries.length > 0) {
    const summaryContext = session.summaries.map((s) => `[${s.round}] ${s.summary}`).join(`

`);
    fullSystemPrompt = `${systemPrompt}

## Previous Conversation Summary
${summaryContext}

## Current PRD State
${prdContent}

The user is resuming the interview. Briefly acknowledge where we are and continue.`;
  } else {
    fullSystemPrompt = `${systemPrompt}

## Current PRD State
${prdContent}

The user is resuming the interview. Briefly acknowledge where we are and continue.`;
  }
  const resumeMessage = {
    role: "user",
    content: "I'm back to continue the interview.",
    timestamp: new Date().toISOString()
  };
  let updatedSession = addMessage(session, "user", resumeMessage.content);
  const response = await collectStreamedResponse(fullSystemPrompt, updatedSession.messages, onChunk);
  updatedSession = addMessage(updatedSession, "assistant", response);
  await saveSession(options.projectRoot, updatedSession);
  return {
    session: updatedSession,
    response,
    roundComplete: false,
    allComplete: false
  };
}
var init_interview_agent = __esm(() => {
  init_conversation();
  init_section_mapper();
  init_session();
});

// src/structured-output/types.ts
function zodErrorToValidationErrors(zodError) {
  return zodError.errors.map((error2) => {
    const validationError = {
      path: error2.path.map(String),
      message: error2.message
    };
    if ("expected" in error2) {
      validationError.expected = String(error2.expected);
    }
    if ("received" in error2) {
      validationError.received = truncateValue(error2.received);
    }
    return validationError;
  });
}
function truncateValue(value) {
  const str = String(value);
  if (str.length > 100) {
    return `${str.slice(0, 100)}...`;
  }
  return str;
}
var DEFAULT_VALIDATION_OPTIONS;
var init_types4 = __esm(() => {
  DEFAULT_VALIDATION_OPTIONS = {
    allowFallback: true,
    maxParseAttempts: 3,
    stripMarkdownBlocks: true
  };
});

// src/structured-output/converter.ts
var init_converter = () => {};

// src/structured-output/validator.ts
function extractJson(content, stripMarkdown) {
  let text = content.trim();
  if (stripMarkdown) {
    const jsonBlockMatch = text.match(/```(?:json)?\s*([\s\S]*?)```/);
    if (jsonBlockMatch?.[1]) {
      text = jsonBlockMatch[1].trim();
    }
  }
  const jsonMatch = text.match(/(\{[\s\S]*\}|\[[\s\S]*\])/);
  if (jsonMatch?.[1]) {
    return jsonMatch[1];
  }
  return null;
}
function parseJsonWithRetry(content, maxAttempts) {
  const attempts = [
    content,
    content.trim(),
    content.replace(/,\s*([}\]])/g, "$1"),
    extractJson(content, true) ?? content
  ];
  for (let i = 0;i < Math.min(maxAttempts, attempts.length); i++) {
    const attempt = attempts[i];
    if (!attempt)
      continue;
    try {
      return JSON.parse(attempt);
    } catch {}
  }
  return null;
}
function validateOutput(output, schema, options) {
  const opts = { ...DEFAULT_VALIDATION_OPTIONS, ...options };
  const jsonString = opts.stripMarkdownBlocks ? extractJson(output, true) : output;
  const parsed = parseJsonWithRetry(jsonString ?? output, opts.maxParseAttempts ?? 3);
  if (parsed === null) {
    if (opts.allowFallback) {
      return {
        success: false,
        raw: output,
        errors: [
          {
            path: [],
            message: "Failed to parse JSON from output",
            expected: "valid JSON",
            received: output.slice(0, 100) + (output.length > 100 ? "..." : "")
          }
        ],
        usedFallback: true
      };
    }
    return {
      success: false,
      raw: output,
      errors: [
        {
          path: [],
          message: "Failed to parse JSON from output"
        }
      ],
      usedFallback: false
    };
  }
  const validationResult = schema.safeParse(parsed);
  if (validationResult.success) {
    return {
      success: true,
      data: validationResult.data,
      raw: output,
      usedFallback: false
    };
  }
  const errors3 = zodErrorToValidationErrors(validationResult.error);
  if (opts.allowFallback) {
    return {
      success: false,
      raw: output,
      errors: errors3,
      usedFallback: true
    };
  }
  return {
    success: false,
    raw: output,
    errors: errors3,
    usedFallback: false
  };
}
var init_validator = __esm(() => {
  init_types4();
});

// src/structured-output/schemas/common.ts
var SeveritySchema, ConfidenceSchema, FileReferenceSchema, CodeSnippetSchema, TokenUsageSchema, RecommendationSchema, CompletionStatusSchema, OutputMetadataSchema;
var init_common = __esm(() => {
  init_zod();
  SeveritySchema = exports_external.enum(["error", "warning", "suggestion", "info"]);
  ConfidenceSchema = exports_external.enum(["high", "medium", "low", "none"]);
  FileReferenceSchema = exports_external.object({
    path: exports_external.string(),
    startLine: exports_external.number().int().positive().optional(),
    endLine: exports_external.number().int().positive().optional()
  });
  CodeSnippetSchema = exports_external.object({
    file: FileReferenceSchema,
    content: exports_external.string(),
    language: exports_external.string().optional()
  });
  TokenUsageSchema = exports_external.object({
    inputTokens: exports_external.number().int().nonnegative(),
    outputTokens: exports_external.number().int().nonnegative(),
    cacheReadTokens: exports_external.number().int().nonnegative().optional(),
    cacheWriteTokens: exports_external.number().int().nonnegative().optional()
  });
  RecommendationSchema = exports_external.object({
    title: exports_external.string(),
    description: exports_external.string(),
    priority: exports_external.enum(["critical", "high", "medium", "low"]).optional(),
    files: exports_external.array(exports_external.string()).optional()
  });
  CompletionStatusSchema = exports_external.enum([
    "completed",
    "partial",
    "failed",
    "blocked",
    "skipped"
  ]);
  OutputMetadataSchema = exports_external.object({
    generatedAt: exports_external.string().datetime().optional(),
    model: exports_external.string().optional(),
    agentVersion: exports_external.string().optional(),
    durationMs: exports_external.number().int().nonnegative().optional(),
    tokenUsage: TokenUsageSchema.optional()
  });
});

// src/structured-output/schemas/review.ts
var ReviewIssueCategorySchema, ReviewIssueSchema, ReviewResultSchema, SectionReviewSchema, ComplexityValidationSchema, FullPRDReviewSchema;
var init_review = __esm(() => {
  init_zod();
  init_common();
  ReviewIssueCategorySchema = exports_external.enum([
    "missing-acceptance-criteria",
    "high-complexity-not-split",
    "conflicting-requirements",
    "missing-edge-cases",
    "unclear-scope",
    "insufficient-context",
    "security-concern",
    "performance-concern",
    "maintainability-concern",
    "other"
  ]);
  ReviewIssueSchema = exports_external.object({
    severity: SeveritySchema,
    category: ReviewIssueCategorySchema,
    description: exports_external.string(),
    location: exports_external.string(),
    suggestion: exports_external.string().optional(),
    affectedFiles: exports_external.array(exports_external.string()).optional()
  });
  ReviewResultSchema = exports_external.object({
    score: exports_external.number().int().min(1).max(10),
    issues: exports_external.array(ReviewIssueSchema),
    summary: exports_external.string(),
    recommendations: exports_external.array(exports_external.string()),
    readyForFinalization: exports_external.boolean(),
    strengths: exports_external.array(exports_external.string()).optional(),
    metadata: OutputMetadataSchema.optional()
  });
  SectionReviewSchema = exports_external.object({
    sectionId: exports_external.string(),
    sectionName: exports_external.string(),
    score: exports_external.number().int().min(1).max(10),
    issues: exports_external.array(ReviewIssueSchema),
    summary: exports_external.string(),
    suggestions: exports_external.array(exports_external.string())
  });
  ComplexityValidationSchema = exports_external.object({
    taskId: exports_external.string(),
    originalComplexity: exports_external.number().int().min(1).max(10),
    validatedComplexity: exports_external.number().int().min(1).max(10),
    isAccurate: exports_external.boolean(),
    reasoning: exports_external.string(),
    factors: exports_external.array(exports_external.object({
      factor: exports_external.string(),
      impact: exports_external.enum(["increases", "decreases", "neutral"]),
      weight: exports_external.number().min(0).max(1)
    }))
  });
  FullPRDReviewSchema = exports_external.object({
    overall: ReviewResultSchema,
    sections: exports_external.array(SectionReviewSchema).optional(),
    complexityValidations: exports_external.array(ComplexityValidationSchema).optional(),
    crossCuttingConcerns: exports_external.array(exports_external.object({
      concern: exports_external.string(),
      affectedSections: exports_external.array(exports_external.string()),
      recommendation: exports_external.string()
    })).optional()
  });
});

// src/structured-output/schemas/agent.ts
var FileModificationSchema, ValidationCheckSchema, TaskResultSchema, PatternSchema, InvestigationResultSchema, DependencyMapSchema, ClarificationQuestionSchema, ScopeValidationSchema, TaskFindingSchema;
var init_agent = __esm(() => {
  init_zod();
  init_common();
  FileModificationSchema = exports_external.object({
    path: exports_external.string(),
    modificationType: exports_external.enum(["created", "modified", "deleted", "renamed"]),
    oldPath: exports_external.string().optional(),
    linesAdded: exports_external.number().int().nonnegative().optional(),
    linesRemoved: exports_external.number().int().nonnegative().optional()
  });
  ValidationCheckSchema = exports_external.object({
    name: exports_external.string(),
    passed: exports_external.boolean(),
    output: exports_external.string().optional(),
    durationMs: exports_external.number().int().nonnegative().optional()
  });
  TaskResultSchema = exports_external.object({
    taskId: exports_external.string(),
    status: CompletionStatusSchema,
    summary: exports_external.string(),
    filesModified: exports_external.array(FileModificationSchema),
    validationChecks: exports_external.array(ValidationCheckSchema),
    successCriteriaMet: exports_external.boolean(),
    criteriaResults: exports_external.array(exports_external.object({
      criterion: exports_external.string(),
      met: exports_external.boolean(),
      evidence: exports_external.string().optional()
    })).optional(),
    issues: exports_external.array(exports_external.object({
      severity: SeveritySchema,
      message: exports_external.string(),
      file: exports_external.string().optional()
    })).optional(),
    recommendations: exports_external.array(exports_external.string()).optional(),
    metadata: OutputMetadataSchema.optional()
  });
  PatternSchema = exports_external.object({
    name: exports_external.string(),
    description: exports_external.string(),
    examples: exports_external.array(FileReferenceSchema),
    frequency: exports_external.enum(["common", "occasional", "rare"])
  });
  InvestigationResultSchema = exports_external.object({
    query: exports_external.string(),
    files: exports_external.array(exports_external.string()),
    snippets: exports_external.array(CodeSnippetSchema),
    summary: exports_external.string(),
    patterns: exports_external.array(PatternSchema).optional(),
    confidence: ConfidenceSchema,
    furtherInvestigation: exports_external.array(exports_external.string()).optional(),
    metadata: OutputMetadataSchema.optional()
  });
  DependencyMapSchema = exports_external.object({
    file: exports_external.string(),
    imports: exports_external.array(exports_external.object({
      source: exports_external.string(),
      specifiers: exports_external.array(exports_external.string()),
      isTypeOnly: exports_external.boolean().optional()
    })),
    importedBy: exports_external.array(exports_external.string()),
    externalDependencies: exports_external.array(exports_external.string()),
    circularDependencies: exports_external.array(exports_external.array(exports_external.string())).optional()
  });
  ClarificationQuestionSchema = exports_external.object({
    id: exports_external.string(),
    question: exports_external.string(),
    reason: exports_external.string(),
    suggestedAnswers: exports_external.array(exports_external.string()).optional(),
    relatedTo: exports_external.string().optional(),
    priority: exports_external.enum(["blocking", "important", "nice-to-have"])
  });
  ScopeValidationSchema = exports_external.object({
    isValid: exports_external.boolean(),
    concerns: exports_external.array(exports_external.object({
      type: exports_external.enum(["too-broad", "too-narrow", "overlapping", "unclear", "missing-context"]),
      description: exports_external.string(),
      suggestion: exports_external.string()
    })),
    relatedCode: exports_external.array(FileReferenceSchema).optional(),
    potentialConflicts: exports_external.array(exports_external.string()).optional()
  });
  TaskFindingSchema = exports_external.object({
    fromTaskId: exports_external.string(),
    toTaskId: exports_external.string(),
    type: exports_external.enum(["affects-file", "interface-change", "discovered-dependency", "warning", "info"]),
    message: exports_external.string(),
    files: exports_external.array(exports_external.string()).optional(),
    blocking: exports_external.boolean().optional()
  });
});

// src/structured-output/schemas/index.ts
var init_schemas = __esm(() => {
  init_common();
  init_review();
  init_agent();
});

// src/structured-output/index.ts
var init_structured_output = __esm(() => {
  init_types4();
  init_converter();
  init_validator();
  init_schemas();
});

// src/thinking/types.ts
var DEFAULT_SIGNAL_WEIGHTS, DEFAULT_THRESHOLDS, DEFAULT_TOKEN_TIERS, ARCHITECTURE_KEYWORDS, REFACTOR_KEYWORDS;
var init_types5 = __esm(() => {
  DEFAULT_SIGNAL_WEIGHTS = {
    complexity: 25,
    filesAffected: 15,
    successCriteria: 15,
    architectureKeywords: 20,
    refactorKeywords: 15,
    reviewAgent: 30
  };
  DEFAULT_THRESHOLDS = {
    complexityMin: 7,
    filesAffectedMin: 8,
    successCriteriaMin: 6
  };
  DEFAULT_TOKEN_TIERS = {
    disabled: { max: 30, tokens: 0 },
    minimal: { max: 50, tokens: 1024 },
    moderate: { max: 70, tokens: 4096 },
    deep: { max: 100, tokens: 16384 }
  };
  ARCHITECTURE_KEYWORDS = [
    "architecture",
    "design pattern",
    "refactor",
    "restructure",
    "migrate",
    "integration",
    "api design",
    "schema",
    "database",
    "performance",
    "scalability",
    "security",
    "authentication",
    "authorization",
    "caching",
    "infrastructure",
    "deployment",
    "ci/cd",
    "microservice",
    "monolith",
    "distributed",
    "concurrent",
    "async",
    "parallel"
  ];
  REFACTOR_KEYWORDS = [
    "refactor",
    "rewrite",
    "restructure",
    "reorganize",
    "consolidate",
    "simplify",
    "extract",
    "inline",
    "rename",
    "move",
    "split",
    "merge",
    "deduplicate",
    "generalize",
    "abstract",
    "encapsulate",
    "decouple",
    "modularize"
  ];
});

// src/thinking/analyzer.ts
function analyzePrompt(content) {
  const lowerContent = content.toLowerCase();
  const foundArchitectureKeywords = [];
  const foundRefactorKeywords = [];
  for (const keyword of ARCHITECTURE_KEYWORDS) {
    if (lowerContent.includes(keyword.toLowerCase())) {
      foundArchitectureKeywords.push(keyword);
    }
  }
  for (const keyword of REFACTOR_KEYWORDS) {
    if (lowerContent.includes(keyword.toLowerCase())) {
      foundRefactorKeywords.push(keyword);
    }
  }
  const keywordCount = foundArchitectureKeywords.length + foundRefactorKeywords.length;
  return {
    architectureKeywords: foundArchitectureKeywords,
    refactorKeywords: foundRefactorKeywords,
    keywordCount,
    hasSignificantKeywords: keywordCount >= 2
  };
}
function buildThinkingContext(params) {
  const {
    complexity,
    filesAffected,
    successCriteria,
    prompt,
    isReviewAgent = false,
    taskDescription
  } = params;
  const combinedContent = [prompt, taskDescription ?? ""].filter(Boolean).join(" ");
  const analysis = analyzePrompt(combinedContent);
  const context = {
    complexity,
    filesAffectedCount: filesAffected.length,
    successCriteriaCount: successCriteria.length,
    promptContent: prompt,
    isReviewAgent,
    additionalKeywords: [...analysis.architectureKeywords, ...analysis.refactorKeywords]
  };
  if (taskDescription !== undefined) {
    context.taskDescription = taskDescription;
  }
  return context;
}
var init_analyzer = __esm(() => {
  init_types5();
});

// src/thinking/decision.ts
function calculateThinkingScore(context, weights, thresholds) {
  let score = 0;
  const reasons = [];
  if (context.complexity >= thresholds.complexityMin) {
    const complexityContribution = weights.complexity;
    score += complexityContribution;
    reasons.push(`High complexity (${context.complexity}/10) +${complexityContribution}`);
  }
  if (context.filesAffectedCount >= thresholds.filesAffectedMin) {
    const filesContribution = weights.filesAffected;
    score += filesContribution;
    reasons.push(`Many files affected (${context.filesAffectedCount}) +${filesContribution}`);
  }
  if (context.successCriteriaCount >= thresholds.successCriteriaMin) {
    const criteriaContribution = weights.successCriteria;
    score += criteriaContribution;
    reasons.push(`Many success criteria (${context.successCriteriaCount}) +${criteriaContribution}`);
  }
  const analysis = analyzePrompt(`${context.promptContent} ${context.taskDescription ?? ""}`);
  if (analysis.architectureKeywords.length > 0) {
    const archContribution = weights.architectureKeywords;
    score += archContribution;
    reasons.push(`Architecture keywords found (${analysis.architectureKeywords.slice(0, 3).join(", ")}) +${archContribution}`);
  }
  if (analysis.refactorKeywords.length > 0) {
    const refactorContribution = weights.refactorKeywords;
    score += refactorContribution;
    reasons.push(`Refactor keywords found (${analysis.refactorKeywords.slice(0, 3).join(", ")}) +${refactorContribution}`);
  }
  if (context.isReviewAgent) {
    const reviewContribution = weights.reviewAgent;
    score += reviewContribution;
    reasons.push(`Review agent call +${reviewContribution}`);
  }
  return { score: Math.min(100, score), reasons };
}
function determineTokenBudget(score, tiers) {
  if (score <= tiers.disabled.max) {
    return tiers.disabled.tokens;
  }
  if (score <= tiers.minimal.max) {
    return tiers.minimal.tokens;
  }
  if (score <= tiers.moderate.max) {
    return tiers.moderate.tokens;
  }
  return tiers.deep.tokens;
}
function shouldEnableExtendedThinking(context, options) {
  const weights = {
    ...DEFAULT_SIGNAL_WEIGHTS,
    ...options?.weights
  };
  const thresholds = {
    ...DEFAULT_THRESHOLDS,
    ...options?.thresholds
  };
  const tiers = {
    ...DEFAULT_TOKEN_TIERS,
    ...options?.tokenTiers
  };
  const { score, reasons } = calculateThinkingScore(context, weights, thresholds);
  const budgetTokens = determineTokenBudget(score, tiers);
  const enabled = budgetTokens > 0;
  return {
    enabled,
    budgetTokens,
    score,
    reasons: enabled ? reasons : ["Score below threshold"]
  };
}
function getThinkingConfig(context, options) {
  const decision = shouldEnableExtendedThinking(context, options);
  if (!decision.enabled) {
    return;
  }
  return {
    type: "enabled",
    budget_tokens: decision.budgetTokens
  };
}
var init_decision = __esm(() => {
  init_analyzer();
  init_types5();
});

// src/thinking/index.ts
var init_thinking = __esm(() => {
  init_types5();
  init_analyzer();
  init_decision();
});

// src/interview/agents/review-agent.ts
function parseReviewResult(response) {
  const result = {
    score: 5,
    issues: [],
    summary: "",
    recommendations: []
  };
  const scoreMatch = response.match(/(?:score|rating):\s*(\d+)/i);
  if (scoreMatch) {
    const scoreStr = scoreMatch[1];
    if (scoreStr) {
      result.score = Math.min(10, Math.max(1, Number.parseInt(scoreStr, 10)));
    }
  }
  const issuesSection = response.match(/(?:issues|problems|findings):([\s\S]*?)(?=##|summary|recommendations|$)/i);
  if (issuesSection) {
    const issuesContent = issuesSection[1];
    if (issuesContent) {
      const issueLines = issuesContent.split(`
`).filter((line) => line.trim());
      for (const line of issueLines) {
        const severityMatch = line.match(/\[(error|warning|suggestion)\]/i);
        const categoryMatch = line.match(/\(([\w-]+)\)/i);
        if (severityMatch) {
          const severityStr = severityMatch[1];
          if (severityStr) {
            const issue = {
              severity: severityStr.toLowerCase(),
              category: "other",
              description: line.replace(/\[.*?\]|\(.*?\)/g, "").trim(),
              location: ""
            };
            if (categoryMatch) {
              const categoryStr = categoryMatch[1];
              if (categoryStr) {
                const category = categoryStr.toLowerCase().replace(/\s+/g, "-");
                if (isValidCategory(category)) {
                  issue.category = category;
                }
              }
            }
            result.issues.push(issue);
          }
        }
      }
    }
  }
  const summaryMatch = response.match(/##?\s*summary[:\s]*([\s\S]*?)(?=##|recommendations|$)/i);
  if (summaryMatch) {
    const summaryContent = summaryMatch[1];
    if (summaryContent) {
      result.summary = summaryContent.trim();
    }
  } else {
    const firstParagraph = response.split(`

`)[0];
    if (firstParagraph) {
      result.summary = firstParagraph.slice(0, 500);
    }
  }
  const recsMatch = response.match(/##?\s*recommendations[:\s]*([\s\S]*?)$/i);
  if (recsMatch) {
    const recsContent = recsMatch[1];
    if (recsContent) {
      const recLines = recsContent.split(`
`).filter((line) => line.trim().startsWith("-") || line.trim().match(/^\d+\./)).map((line) => line.replace(/^[-\d.]\s*/, "").trim()).filter((line) => line.length > 0);
      result.recommendations = recLines;
    }
  }
  return result;
}
function isValidCategory(category) {
  const validCategories = [
    "missing-acceptance-criteria",
    "high-complexity-not-split",
    "conflicting-requirements",
    "missing-edge-cases",
    "unclear-scope",
    "other"
  ];
  return validCategories.includes(category);
}
async function reviewPRD(prdContent, options) {
  const { enableThinking, useStructuredOutput = true, thinkingBudget } = options ?? {};
  const thinkingContext = buildThinkingContext({
    complexity: 8,
    filesAffected: [],
    successCriteria: [],
    prompt: prdContent,
    isReviewAgent: true
  });
  const thinkingConfig = enableThinking === false ? undefined : thinkingBudget ? { type: "enabled", budget_tokens: thinkingBudget } : getThinkingConfig(thinkingContext);
  const systemPrompt = getReviewSystemPromptWithStructure(prdContent, useStructuredOutput);
  const messages = [
    {
      role: "user",
      content: useStructuredOutput ? "Please review this PRD and provide a structured JSON assessment." : "Please review this PRD and provide a structured assessment.",
      timestamp: new Date().toISOString()
    }
  ];
  try {
    if (thinkingConfig) {
      const response2 = await sendMessageWithThinking(systemPrompt, messages, {
        thinking: thinkingConfig
      });
      if (useStructuredOutput) {
        const validated = validateOutput(response2.text, ReviewResultSchema);
        if (validated.success && validated.data) {
          return convertStructuredToLegacy(validated.data);
        }
        console.warn("Structured output validation failed, falling back to text parsing");
      }
      return parseReviewResult(response2.text);
    }
    const response = await sendMessage(systemPrompt, messages, {
      temperature: 0.3
    });
    if (useStructuredOutput) {
      const validated = validateOutput(response, ReviewResultSchema);
      if (validated.success && validated.data) {
        return convertStructuredToLegacy(validated.data);
      }
    }
    return parseReviewResult(response);
  } catch (error2) {
    throw new ReviewError(error2.message);
  }
}
function getReviewSystemPromptWithStructure(prdContent, useStructuredOutput) {
  const basePrompt = getReviewSystemPrompt(prdContent);
  if (!useStructuredOutput) {
    return basePrompt;
  }
  return `${basePrompt}

## Output Format

You MUST respond with a valid JSON object matching this schema:

\`\`\`json
{
  "score": <number 1-10>,
  "issues": [
    {
      "severity": "error" | "warning" | "suggestion",
      "category": "missing-acceptance-criteria" | "high-complexity-not-split" | "conflicting-requirements" | "missing-edge-cases" | "unclear-scope" | "insufficient-context" | "security-concern" | "performance-concern" | "maintainability-concern" | "other",
      "description": "<string>",
      "location": "<section or task ID>",
      "suggestion": "<optional fix suggestion>"
    }
  ],
  "summary": "<overall assessment>",
  "recommendations": ["<action item 1>", "<action item 2>"],
  "readyForFinalization": <boolean>,
  "strengths": ["<optional strength 1>"]
}
\`\`\`

Respond ONLY with the JSON object, no additional text.`;
}
function convertStructuredToLegacy(structured) {
  return {
    score: structured.score,
    issues: structured.issues.map((issue) => {
      const reviewIssue = {
        severity: issue.severity,
        category: isValidCategory(issue.category) ? issue.category : "other",
        description: issue.description,
        location: issue.location
      };
      if (issue.suggestion !== undefined) {
        reviewIssue.suggestion = issue.suggestion;
      }
      return reviewIssue;
    }),
    summary: structured.summary,
    recommendations: structured.recommendations
  };
}
async function generateSuggestions(prdContent, issues) {
  const suggestions = new Map;
  if (issues.length === 0) {
    return suggestions;
  }
  const issueList = issues.map((issue, index) => `${index + 1}. [${issue.severity}] ${issue.description}`).join(`
`);
  const systemPrompt = `You are KARIMO's PRD Review Agent.
Given the following PRD and identified issues, provide specific suggestions for fixing each issue.

## PRD Content
${prdContent}

## Issues Found
${issueList}

For each issue, provide a brief, actionable suggestion on how to fix it.
Format your response as:
1. [suggestion for issue 1]
2. [suggestion for issue 2]
etc.`;
  const messages = [
    {
      role: "user",
      content: "Please provide suggestions for fixing each issue.",
      timestamp: new Date().toISOString()
    }
  ];
  try {
    const response = await sendMessage(systemPrompt, messages, {
      temperature: 0.3
    });
    const lines = response.split(`
`);
    for (const line of lines) {
      const match = line.match(/^(\d+)\.\s*(.+)/);
      if (match) {
        const indexStr = match[1];
        const suggestionStr = match[2];
        if (indexStr && suggestionStr) {
          const index = Number.parseInt(indexStr, 10) - 1;
          const suggestion = suggestionStr.trim();
          if (index >= 0 && index < issues.length) {
            suggestions.set(index, suggestion);
          }
        }
      }
    }
    return suggestions;
  } catch (error2) {
    throw new ReviewError(`Failed to generate suggestions: ${error2.message}`);
  }
}
function isReadyForFinalization(result) {
  const hasErrors = result.issues.some((issue) => issue.severity === "error");
  if (hasErrors) {
    return false;
  }
  if (result.score < 6) {
    return false;
  }
  return true;
}
function formatReviewResult(result) {
  const lines = [];
  const scoreEmoji = result.score >= 8 ? "\u2705" : result.score >= 6 ? "\u26A0\uFE0F" : "\u274C";
  lines.push(`${scoreEmoji} Score: ${result.score}/10`);
  lines.push("");
  const errors3 = result.issues.filter((i) => i.severity === "error");
  const warnings = result.issues.filter((i) => i.severity === "warning");
  const suggestions = result.issues.filter((i) => i.severity === "suggestion");
  if (errors3.length > 0) {
    lines.push("\u274C Errors (must fix):");
    for (const error2 of errors3) {
      lines.push(`  \u2022 ${error2.description}`);
    }
    lines.push("");
  }
  if (warnings.length > 0) {
    lines.push("\u26A0\uFE0F Warnings (should fix):");
    for (const warning of warnings) {
      lines.push(`  \u2022 ${warning.description}`);
    }
    lines.push("");
  }
  if (suggestions.length > 0) {
    lines.push("\uD83D\uDCA1 Suggestions:");
    for (const suggestion of suggestions) {
      lines.push(`  \u2022 ${suggestion.description}`);
    }
    lines.push("");
  }
  if (result.summary) {
    lines.push("Summary:");
    lines.push(result.summary);
    lines.push("");
  }
  if (result.recommendations.length > 0) {
    lines.push("Recommendations:");
    for (const rec of result.recommendations) {
      lines.push(`  \u2022 ${rec}`);
    }
  }
  return lines.join(`
`);
}
var init_review_agent = __esm(() => {
  init_structured_output();
  init_thinking();
  init_conversation();
  init_errors10();
  init_section_mapper();
});

// src/interview/agents/investigation-agent.ts
import { existsSync as existsSync18, readFileSync as readFileSync7, readdirSync as readdirSync3, statSync as statSync4 } from "fs";
import { join as join22, relative } from "path";
function matchGlob(pattern, path2) {
  const regexPattern = pattern.replace(/\*\*/g, ".*").replace(/\*/g, "[^/]*").replace(/\?/g, ".").replace(/\./g, "\\.");
  const regex2 = new RegExp(`^${regexPattern}$`);
  return regex2.test(path2);
}
function findFiles(projectRoot, pattern, exclude = ["node_modules", "dist", ".git", "coverage"]) {
  const results = [];
  function walk(dir) {
    if (results.length >= MAX_GLOB_RESULTS)
      return;
    try {
      const entries = readdirSync3(dir);
      for (const entry of entries) {
        if (results.length >= MAX_GLOB_RESULTS)
          break;
        const fullPath = join22(dir, entry);
        const relativePath = relative(projectRoot, fullPath);
        if (exclude.some((ex) => relativePath.includes(ex))) {
          continue;
        }
        const stat = statSync4(fullPath);
        if (stat.isDirectory()) {
          walk(fullPath);
        } else if (matchGlob(pattern, relativePath)) {
          results.push(relativePath);
        }
      }
    } catch {}
  }
  walk(projectRoot);
  return results;
}
function readFile(projectRoot, path2, startLine, endLine) {
  const fullPath = join22(projectRoot, path2);
  if (!existsSync18(fullPath)) {
    throw new Error(`File not found: ${path2}`);
  }
  const stat = statSync4(fullPath);
  if (stat.size > MAX_FILE_SIZE) {
    const content2 = readFileSync7(fullPath, "utf-8");
    const lines = content2.split(`
`);
    const start = (startLine ?? 1) - 1;
    const end = endLine ?? Math.min(lines.length, start + 100);
    const selectedLines = lines.slice(start, end);
    return {
      content: selectedLines.join(`
`),
      truncated: end < lines.length
    };
  }
  const content = readFileSync7(fullPath, "utf-8");
  if (startLine !== undefined || endLine !== undefined) {
    const lines = content.split(`
`);
    const start = (startLine ?? 1) - 1;
    const end = endLine ?? lines.length;
    const selectedLines = lines.slice(start, end);
    return {
      content: selectedLines.join(`
`),
      truncated: end < lines.length
    };
  }
  return { content, truncated: false };
}
function searchContent(projectRoot, pattern, filePattern = "**/*", caseSensitive = false) {
  const results = [];
  const files = findFiles(projectRoot, filePattern);
  const regex2 = new RegExp(pattern, caseSensitive ? "" : "i");
  for (const file of files) {
    if (results.length >= 50)
      break;
    try {
      const { content } = readFile(projectRoot, file);
      const lines = content.split(`
`);
      for (let i = 0;i < lines.length; i++) {
        if (results.length >= 50)
          break;
        const line = lines[i];
        if (line !== undefined && regex2.test(line)) {
          results.push({
            file,
            line: i + 1,
            content: line.trim()
          });
        }
      }
    } catch {}
  }
  return results;
}
function listDirectory(projectRoot, path2, recursive = false) {
  const fullPath = join22(projectRoot, path2);
  if (!existsSync18(fullPath)) {
    throw new Error(`Directory not found: ${path2}`);
  }
  const results = [];
  function walk(dir) {
    try {
      const entries = readdirSync3(dir);
      for (const entry of entries) {
        if (results.length >= 100)
          break;
        const entryPath = join22(dir, entry);
        const relativePath = relative(projectRoot, entryPath);
        if (["node_modules", ".git", "dist", "coverage"].includes(entry)) {
          continue;
        }
        const stat = statSync4(entryPath);
        results.push({
          name: entry,
          type: stat.isDirectory() ? "directory" : "file",
          path: relativePath
        });
        if (recursive && stat.isDirectory()) {
          walk(entryPath);
        }
      }
    } catch {}
  }
  walk(fullPath);
  return results;
}
function executeTool2(projectRoot, toolName, input) {
  switch (toolName) {
    case "find_files": {
      const pattern = input["pattern"];
      const exclude = input["exclude"] ?? [];
      const files = findFiles(projectRoot, pattern, exclude);
      return JSON.stringify({ files, count: files.length });
    }
    case "read_file": {
      const path2 = input["path"];
      const startLine = input["startLine"];
      const endLine = input["endLine"];
      const result = readFile(projectRoot, path2, startLine, endLine);
      return JSON.stringify(result);
    }
    case "search_content": {
      const pattern = input["pattern"];
      const filePattern = input["filePattern"];
      const caseSensitive = input["caseSensitive"];
      const results = searchContent(projectRoot, pattern, filePattern, caseSensitive);
      return JSON.stringify({ matches: results, count: results.length });
    }
    case "list_directory": {
      const path2 = input["path"];
      const recursive = input["recursive"];
      const results = listDirectory(projectRoot, path2, recursive);
      return JSON.stringify({ entries: results, count: results.length });
    }
    default:
      return JSON.stringify({ error: `Unknown tool: ${toolName}` });
  }
}
async function investigate(projectRoot, query) {
  const systemPrompt = `You are KARIMO's Investigation Agent.
Your job is to explore the codebase to answer questions and gather context.

## Available Tools
- find_files: Search for files matching glob patterns
- read_file: Read file contents
- search_content: Search for text/regex in files
- list_directory: List directory contents

## Guidelines
- Use tools to explore the codebase
- Focus on finding relevant files and patterns
- Summarize your findings clearly
- Note any important patterns or conventions you discover

## Project Root
${projectRoot}

Answer the following investigation query by exploring the codebase.`;
  const messages = [
    {
      role: "user",
      content: query,
      timestamp: new Date().toISOString()
    }
  ];
  const files = [];
  const snippets = [];
  let summary = "";
  try {
    let results = await sendMessageWithTools(systemPrompt, messages, INVESTIGATION_TOOLS);
    let iterations = 0;
    const maxIterations = 10;
    while (iterations < maxIterations) {
      iterations++;
      const toolUses = results.filter((r2) => r2.type === "tool_use");
      if (toolUses.length === 0) {
        const textResults = results.filter((r2) => r2.type === "text");
        if (textResults.length > 0) {
          summary = textResults.map((r2) => r2.content).join(`
`);
        }
        break;
      }
      for (const toolUse of toolUses) {
        const toolResult = executeTool2(projectRoot, toolUse.name, toolUse.input);
        try {
          const parsed = JSON.parse(toolResult);
          if (parsed.files) {
            files.push(...parsed.files);
          }
          if (parsed.matches) {
            for (const match of parsed.matches) {
              snippets.push({
                file: match.file,
                content: match.content,
                startLine: match.line,
                endLine: match.line
              });
            }
          }
        } catch {}
        results = await continueWithToolResults(systemPrompt, messages, toolUse.id, toolResult, INVESTIGATION_TOOLS);
      }
    }
    return {
      query,
      files: [...new Set(files)],
      snippets: snippets.slice(0, 20),
      summary: summary || "Investigation complete."
    };
  } catch (error2) {
    throw new InvestigationError(query, error2.message);
  }
}
var MAX_FILE_SIZE, MAX_GLOB_RESULTS = 20, INVESTIGATION_TOOLS, COMMON_QUERIES;
var init_investigation_agent = __esm(() => {
  init_conversation();
  init_errors10();
  MAX_FILE_SIZE = 50 * 1024;
  INVESTIGATION_TOOLS = [
    {
      name: "find_files",
      description: "Search for files matching a glob pattern. Returns file paths.",
      input_schema: {
        type: "object",
        properties: {
          pattern: {
            type: "string",
            description: 'Glob pattern to match (e.g., "**/*.ts", "src/components/*.tsx")'
          },
          exclude: {
            type: "array",
            items: { type: "string" },
            description: 'Patterns to exclude (e.g., ["node_modules", "dist"])'
          }
        },
        required: ["pattern"]
      }
    },
    {
      name: "read_file",
      description: "Read the contents of a file. Returns file content as text.",
      input_schema: {
        type: "object",
        properties: {
          path: {
            type: "string",
            description: "Path to the file to read (relative to project root)"
          },
          startLine: {
            type: "number",
            description: "Line to start reading from (optional, 1-indexed)"
          },
          endLine: {
            type: "number",
            description: "Line to end reading at (optional, 1-indexed)"
          }
        },
        required: ["path"]
      }
    },
    {
      name: "search_content",
      description: "Search for text/regex pattern in files. Returns matching files and snippets.",
      input_schema: {
        type: "object",
        properties: {
          pattern: {
            type: "string",
            description: "Text or regex pattern to search for"
          },
          filePattern: {
            type: "string",
            description: 'Glob pattern to filter files (e.g., "**/*.ts")'
          },
          caseSensitive: {
            type: "boolean",
            description: "Whether search is case sensitive (default: false)"
          }
        },
        required: ["pattern"]
      }
    },
    {
      name: "list_directory",
      description: "List contents of a directory. Returns files and subdirectories.",
      input_schema: {
        type: "object",
        properties: {
          path: {
            type: "string",
            description: "Path to the directory (relative to project root)"
          },
          recursive: {
            type: "boolean",
            description: "Whether to list recursively (default: false)"
          }
        },
        required: ["path"]
      }
    }
  ];
  COMMON_QUERIES = {
    projectStructure: "What is the overall structure of this project? List main directories and their purposes.",
    existingPatterns: "What patterns and conventions are used in this codebase? Look at file structure, naming, imports.",
    componentLibrary: "Is there a component library or design system in use? What UI components exist?",
    dataModels: "What data models or database schemas exist? What are the main entities?",
    apiRoutes: "What API routes or endpoints exist? How is the API structured?",
    testPatterns: "How are tests organized? What testing patterns are used?",
    configFiles: "What configuration files exist? What tools and frameworks are configured?"
  };
});

// src/interview/subagents/registry.ts
class AgentRegistry {
  executions = new Map;
  register(request2) {
    const execution = {
      request: request2,
      status: "pending"
    };
    this.executions.set(request2.id, execution);
    return execution;
  }
  markRunning(spawnId) {
    const execution = this.executions.get(spawnId);
    if (execution) {
      execution.status = "running";
      execution.startedAt = new Date;
    }
  }
  complete(spawnId, result) {
    const execution = this.executions.get(spawnId);
    if (execution) {
      execution.status = result.status === "completed" ? "completed" : "failed";
      execution.completedAt = new Date;
      execution.result = result;
    }
  }
  cancel(spawnId) {
    const execution = this.executions.get(spawnId);
    if (execution && (execution.status === "pending" || execution.status === "running")) {
      execution.status = "cancelled";
      execution.completedAt = new Date;
    }
  }
  get(spawnId) {
    return this.executions.get(spawnId);
  }
  getByStatus(status) {
    return Array.from(this.executions.values()).filter((e2) => e2.status === status);
  }
  getByParent(parent) {
    return Array.from(this.executions.values()).filter((e2) => e2.request.parent === parent);
  }
  getCompletedResults() {
    return Array.from(this.executions.values()).filter((e2) => e2.result !== undefined).map((e2) => e2.result);
  }
  getAggregatedUsage() {
    const usage = {
      totalInputTokens: 0,
      totalOutputTokens: 0,
      totalCacheReadTokens: 0,
      byModel: {},
      executionCount: 0,
      failedCount: 0
    };
    for (const execution of this.executions.values()) {
      if (execution.result) {
        usage.executionCount++;
        if (execution.result.status !== "completed") {
          usage.failedCount++;
        }
        const resultUsage = execution.result.usage;
        usage.totalInputTokens += resultUsage.inputTokens;
        usage.totalOutputTokens += resultUsage.outputTokens;
        usage.totalCacheReadTokens += resultUsage.cacheReadTokens ?? 0;
        const model = resultUsage.model;
        if (!usage.byModel[model]) {
          usage.byModel[model] = { input: 0, output: 0 };
        }
        const modelUsage = usage.byModel[model];
        if (modelUsage) {
          modelUsage.input += resultUsage.inputTokens;
          modelUsage.output += resultUsage.outputTokens;
        }
      }
    }
    return usage;
  }
  hasRunning() {
    return this.getByStatus("running").length > 0;
  }
  hasPending() {
    return this.getByStatus("pending").length > 0;
  }
  getCounts() {
    const counts = {
      pending: 0,
      running: 0,
      completed: 0,
      failed: 0,
      cancelled: 0
    };
    for (const execution of this.executions.values()) {
      counts[execution.status]++;
    }
    return counts;
  }
  clear() {
    this.executions.clear();
  }
  export() {
    return Array.from(this.executions.values()).map((e2) => {
      const exported = {
        request: e2.request
      };
      if (e2.result !== undefined) {
        exported.result = e2.result;
      }
      return exported;
    });
  }
  import(data) {
    for (const item of data) {
      const execution = {
        request: item.request,
        status: item.result ? item.result.status === "completed" ? "completed" : "failed" : "pending"
      };
      if (item.result !== undefined) {
        execution.result = item.result;
      }
      this.executions.set(item.request.id, execution);
    }
  }
}
function createAgentRegistry() {
  return new AgentRegistry;
}

// src/interview/subagents/prompts/index.ts
function getSubagentPrompt(type, context) {
  switch (type) {
    case "clarification":
      return getClarificationPrompt(context);
    case "research":
      return getResearchPrompt(context);
    case "scope-validator":
      return getScopeValidatorPrompt(context);
    case "pattern-analyzer":
      return getPatternAnalyzerPrompt(context);
    case "dependency-mapper":
      return getDependencyMapperPrompt(context);
    case "section-reviewer":
      return getSectionReviewerPrompt(context);
    case "complexity-validator":
      return getComplexityValidatorPrompt(context);
    default:
      return getDefaultPrompt(context);
  }
}
function getClarificationPrompt(context) {
  return `You are a Clarification Agent for KARIMO, an autonomous development framework.

Your job is to deeply analyze ambiguous or unclear requirements and generate clarifying questions.

## Guidelines

1. Focus on requirements that could be interpreted multiple ways
2. Identify implicit assumptions that need validation
3. Generate specific, actionable questions
4. Prioritize questions by their impact on implementation
5. Consider edge cases and error scenarios

## Output Format

Respond with a JSON object:

\`\`\`json
{
  "questions": [
    {
      "id": "q1",
      "question": "What should happen when...",
      "reason": "This is ambiguous because...",
      "priority": "blocking" | "important" | "nice-to-have"
    }
  ],
  "resolvedAmbiguities": ["Clarified that X means Y"]
}
\`\`\`

${formatContext(context)}`;
}
function getResearchPrompt(context) {
  return `You are a Research Agent for KARIMO, an autonomous development framework.

Your job is to investigate the codebase to gather information relevant to the current task.

## Guidelines

1. Focus on finding patterns, conventions, and existing implementations
2. Identify relevant files and code structures
3. Summarize findings clearly and concisely
4. Note any potential conflicts or considerations
5. Provide recommendations based on findings

## Output Format

Respond with a JSON object:

\`\`\`json
{
  "findings": [
    {
      "topic": "Authentication patterns",
      "summary": "The codebase uses...",
      "relevantFiles": ["src/auth/...", "src/middleware/..."],
      "confidence": "high" | "medium" | "low"
    }
  ],
  "recommendations": ["Consider using...", "Avoid..."]
}
\`\`\`

${formatContext(context)}`;
}
function getScopeValidatorPrompt(context) {
  return `You are a Scope Validation Agent for KARIMO, an autonomous development framework.

Your job is to validate the scope of a task or feature against the existing codebase.

## Guidelines

1. Identify if the scope is too broad, too narrow, or appropriately sized
2. Check for overlapping functionality with existing code
3. Identify potential conflicts or integration points
4. Suggest scope adjustments if needed
5. Note any missing context that affects scope assessment

## Output Format

Respond with a JSON object:

\`\`\`json
{
  "isValid": true | false,
  "concerns": [
    {
      "type": "too-broad" | "too-narrow" | "overlapping" | "unclear",
      "description": "The scope includes...",
      "suggestion": "Consider narrowing to..."
    }
  ],
  "relatedExistingCode": ["src/features/...", "src/utils/..."]
}
\`\`\`

${formatContext(context)}`;
}
function getPatternAnalyzerPrompt(context) {
  return `You are a Pattern Analysis Agent for KARIMO, an autonomous development framework.

Your job is to deeply analyze code patterns in the codebase.

## Guidelines

1. Identify recurring patterns and conventions
2. Note anti-patterns and technical debt
3. Assess pattern consistency across the codebase
4. Suggest improvements where appropriate
5. Consider maintainability and scalability implications

## Output Format

Respond with a JSON object:

\`\`\`json
{
  "patterns": [
    {
      "name": "Repository pattern",
      "description": "Data access is abstracted...",
      "locations": ["src/repositories/...", "src/data/..."],
      "frequency": "common" | "occasional" | "rare"
    }
  ],
  "antiPatterns": [
    {
      "name": "God object",
      "description": "The UserService class has too many responsibilities",
      "locations": ["src/services/UserService.ts"],
      "suggestion": "Split into smaller, focused services"
    }
  ]
}
\`\`\`

${formatContext(context)}`;
}
function getDependencyMapperPrompt(context) {
  return `You are a Dependency Mapping Agent for KARIMO, an autonomous development framework.

Your job is to analyze and map import/dependency chains in the codebase.

## Guidelines

1. Trace import relationships between files
2. Identify external dependencies used
3. Detect circular dependencies
4. Note unusually deep dependency chains
5. Suggest refactoring opportunities

## Output Format

Respond with a JSON object:

\`\`\`json
{
  "files": [
    {
      "path": "src/services/auth.ts",
      "imports": ["src/utils/crypto.ts", "src/models/user.ts"],
      "importedBy": ["src/controllers/auth.ts"],
      "externalDeps": ["bcrypt", "jsonwebtoken"]
    }
  ],
  "circularDependencies": [
    ["src/a.ts", "src/b.ts", "src/a.ts"]
  ],
  "suggestions": ["Consider extracting...", "Circular dependency could be broken by..."]
}
\`\`\`

${formatContext(context)}`;
}
function getSectionReviewerPrompt(context) {
  return `You are a Section Review Agent for KARIMO, an autonomous development framework.

Your job is to review a specific section of a PRD for quality, completeness, and clarity.

## Guidelines

1. Assess clarity and specificity of requirements
2. Check for missing acceptance criteria
3. Identify potential ambiguities
4. Evaluate complexity estimates
5. Provide actionable improvement suggestions

## Output Format

Respond with a JSON object:

\`\`\`json
{
  "sectionId": "requirements",
  "score": 7,
  "issues": [
    {
      "severity": "error" | "warning" | "suggestion",
      "description": "Missing acceptance criteria for...",
      "suggestion": "Add specific criteria such as..."
    }
  ],
  "summary": "This section provides good coverage but lacks..."
}
\`\`\`

${formatContext(context)}`;
}
function getComplexityValidatorPrompt(context) {
  return `You are a Complexity Validation Agent for KARIMO, an autonomous development framework.

Your job is to validate and potentially adjust task complexity scores.

## Guidelines

1. Analyze the actual complexity of the task
2. Consider codebase context and existing patterns
3. Account for hidden complexity (integration, testing, edge cases)
4. Provide reasoning for any adjustments
5. Identify specific factors that influence complexity

## Output Format

Respond with a JSON object:

\`\`\`json
{
  "taskId": "task-1a",
  "originalComplexity": 5,
  "validatedComplexity": 7,
  "isAccurate": false,
  "reasoning": "The complexity should be higher because...",
  "factors": [
    {
      "factor": "Integration with legacy system",
      "impact": "increases" | "decreases" | "neutral"
    }
  ]
}
\`\`\`

${formatContext(context)}`;
}
function getDefaultPrompt(context) {
  return `You are a Subagent for KARIMO, an autonomous development framework.

Complete the assigned task using the provided context.

${formatContext(context)}

Respond in a structured JSON format appropriate for the task.`;
}
function formatContext(context) {
  const sections = [];
  if (context.prdContent) {
    sections.push(`## PRD Content

${context.prdContent}`);
  }
  if (context.projectConfig) {
    sections.push(`## Project Configuration

- Name: ${context.projectConfig.name}
- Language: ${context.projectConfig.language}
${context.projectConfig.framework ? `- Framework: ${context.projectConfig.framework}` : ""}`);
  }
  if (context.relevantFiles && context.relevantFiles.length > 0) {
    sections.push(`## Relevant Files

${context.relevantFiles.map((f2) => `- ${f2}`).join(`
`)}`);
  }
  if (context.relevantMessages && context.relevantMessages.length > 0) {
    sections.push(`## Recent Conversation

${context.relevantMessages.map((m2) => `**${m2.role}**: ${m2.content.slice(0, 500)}`).join(`

`)}`);
  }
  return sections.join(`

`);
}

// src/interview/subagents/spawner.ts
class SubagentSpawner {
  registry;
  constructor(registry) {
    this.registry = registry;
  }
  async spawn(request2, options) {
    const { model = DEFAULT_MODEL2, temperature = 0.7, maxTokens = 4096 } = options ?? {};
    this.registry.register(request2);
    this.registry.markRunning(request2.id);
    const startTime = Date.now();
    try {
      const systemPrompt = getSubagentPrompt(request2.type, request2.context);
      const messages = [
        {
          role: "user",
          content: request2.task,
          timestamp: new Date().toISOString()
        }
      ];
      const timeout = request2.timeout ?? DEFAULT_TIMEOUT3;
      const response = await this.executeWithTimeout(systemPrompt, messages, { model, temperature, maxTokens }, timeout);
      const durationMs = Date.now() - startTime;
      const structuredData = this.extractStructuredData(request2.type, response.text);
      const result = {
        spawnId: request2.id,
        status: "completed",
        content: response.text,
        usage: response.usage,
        durationMs
      };
      if (structuredData !== undefined) {
        result.data = structuredData;
      }
      this.registry.complete(request2.id, result);
      return result;
    } catch (error2) {
      const durationMs = Date.now() - startTime;
      const errorMessage = error2 instanceof Error ? error2.message : String(error2);
      const isTimeout = errorMessage.includes("timeout") || errorMessage.includes("Timeout");
      const result = {
        spawnId: request2.id,
        status: isTimeout ? "timeout" : "failed",
        content: "",
        usage: {
          inputTokens: 0,
          outputTokens: 0,
          model
        },
        durationMs,
        error: errorMessage
      };
      this.registry.complete(request2.id, result);
      return result;
    }
  }
  async spawnParallel(requests, options) {
    const { maxConcurrency = 5, stopOnFailure = false, ...spawnOptions } = options ?? {};
    const results = new Array(requests.length);
    const pending = [...requests.entries()];
    const running = [];
    while (pending.length > 0 || running.length > 0) {
      while (pending.length > 0 && running.length < maxConcurrency) {
        const entry = pending.shift();
        if (!entry)
          break;
        const [index, request2] = entry;
        const promise = this.spawn(request2, spawnOptions).then((result) => {
          results[index] = result;
          if (stopOnFailure && result.status !== "completed") {
            for (const [, pendingRequest] of pending) {
              this.registry.cancel(pendingRequest.id);
            }
            pending.length = 0;
          }
        });
        running.push(promise);
      }
      if (running.length > 0) {
        await Promise.race(running);
        const completed = running.filter((p) => p.then(() => true).catch(() => true));
        for (const p of completed) {
          const index = running.indexOf(p);
          if (index > -1) {
            running.splice(index, 1);
          }
        }
        await new Promise((resolve3) => setTimeout(resolve3, 10));
      }
    }
    await Promise.all(running);
    return results;
  }
  async executeWithTimeout(systemPrompt, messages, options, timeout) {
    const client = getAnthropicClient();
    const timeoutPromise = new Promise((_3, reject) => {
      setTimeout(() => reject(new Error(`Subagent execution timeout after ${timeout}ms`)), timeout);
    });
    const executePromise = (async () => {
      const response = await client.messages.create({
        model: options.model,
        max_tokens: options.maxTokens,
        temperature: options.temperature,
        system: systemPrompt,
        messages: messages.map((m2) => ({ role: m2.role, content: m2.content }))
      });
      let text = "";
      for (const block of response.content) {
        if (block.type === "text") {
          text += block.text;
        }
      }
      return {
        text,
        usage: {
          inputTokens: response.usage.input_tokens,
          outputTokens: response.usage.output_tokens,
          model: options.model
        }
      };
    })();
    return Promise.race([executePromise, timeoutPromise]);
  }
  extractStructuredData(type, content) {
    try {
      const jsonMatch = content.match(/```json\s*([\s\S]*?)```/) ?? content.match(/(\{[\s\S]*\})/);
      if (jsonMatch?.[1]) {
        const parsed = JSON.parse(jsonMatch[1]);
        return { ...parsed, type: this.mapTypeToDataType(type) };
      }
    } catch {}
    return;
  }
  mapTypeToDataType(type) {
    const mapping = {
      clarification: "clarification",
      research: "research",
      "scope-validator": "scope-validation",
      "pattern-analyzer": "pattern-analysis",
      "dependency-mapper": "dependency-map",
      "section-reviewer": "section-review",
      "complexity-validator": "complexity-validation"
    };
    return mapping[type] ?? type;
  }
}
function createSubagentSpawner(registry) {
  return new SubagentSpawner(registry);
}
var DEFAULT_TIMEOUT3 = 60000, DEFAULT_MODEL2 = "claude-sonnet-4-20250514";
var init_spawner = __esm(() => {
  init_conversation();
});

// src/interview/subagents/cost.ts
class SubagentCostTracker {
  usages = [];
  recordUsage(usage) {
    this.usages.push(usage);
  }
  calculateCost() {
    let totalInputCost = 0;
    let totalOutputCost = 0;
    const byModel = {};
    for (const usage of this.usages) {
      const pricing = COST_PER_MILLION_TOKENS[usage.model] ?? COST_PER_MILLION_TOKENS["default"];
      if (!pricing) {
        continue;
      }
      const inputCost = usage.inputTokens / 1e6 * pricing.input;
      const outputCost = usage.outputTokens / 1e6 * pricing.output;
      totalInputCost += inputCost;
      totalOutputCost += outputCost;
      if (!byModel[usage.model]) {
        byModel[usage.model] = { inputCost: 0, outputCost: 0, totalCost: 0 };
      }
      const modelEntry = byModel[usage.model];
      if (modelEntry) {
        modelEntry.inputCost += inputCost;
        modelEntry.outputCost += outputCost;
        modelEntry.totalCost += inputCost + outputCost;
      }
    }
    return {
      inputCost: totalInputCost,
      outputCost: totalOutputCost,
      totalCost: totalInputCost + totalOutputCost,
      byModel
    };
  }
  getTotalTokens() {
    let input = 0;
    let output = 0;
    for (const usage of this.usages) {
      input += usage.inputTokens;
      output += usage.outputTokens;
    }
    return { input, output, total: input + output };
  }
  getExecutionCount() {
    return this.usages.length;
  }
  clear() {
    this.usages = [];
  }
  export() {
    return [...this.usages];
  }
  import(usages) {
    this.usages.push(...usages);
  }
}
function calculateSingleUsageCost(usage) {
  const pricing = COST_PER_MILLION_TOKENS[usage.model] ?? COST_PER_MILLION_TOKENS["default"];
  if (!pricing) {
    return 0;
  }
  const inputCost = usage.inputTokens / 1e6 * pricing.input;
  const outputCost = usage.outputTokens / 1e6 * pricing.output;
  return inputCost + outputCost;
}
function formatCost(cost) {
  if (cost < 0.01) {
    return `$${cost.toFixed(4)}`;
  }
  if (cost < 1) {
    return `$${cost.toFixed(3)}`;
  }
  return `$${cost.toFixed(2)}`;
}
function createCostTracker() {
  return new SubagentCostTracker;
}
var COST_PER_MILLION_TOKENS;
var init_cost = __esm(() => {
  COST_PER_MILLION_TOKENS = {
    "claude-sonnet-4-20250514": { input: 3, output: 15 },
    "claude-3-5-sonnet-20241022": { input: 3, output: 15 },
    "claude-3-haiku-20240307": { input: 0.25, output: 1.25 },
    "claude-3-opus-20240229": { input: 15, output: 75 },
    default: { input: 3, output: 15 }
  };
});

// src/interview/subagents/index.ts
var init_subagents = __esm(() => {
  init_spawner();
  init_cost();
});

// src/interview/index.ts
var exports_interview = {};
__export(exports_interview, {
  updateSubagentUsage: () => updateSubagentUsage,
  updatePRDStatus: () => updatePRDStatus,
  updatePRDSection: () => updatePRDSection,
  streamMessageWithTools: () => streamMessageWithTools,
  streamMessage: () => streamMessage,
  streamContinueWithToolResults: () => streamContinueWithToolResults,
  startNewInterview: () => startNewInterview,
  startInterviewAgent: () => startInterview,
  startInterview: () => startInterview2,
  startConversationalAgent: () => startConversationalInterview,
  sessionExists: () => sessionExists,
  sendMessageWithTools: () => sendMessageWithTools,
  sendMessage: () => sendMessage,
  saveSession: () => saveSession,
  reviewPRD: () => reviewPRD,
  resumeInterviewAgent: () => resumeInterview,
  resumeInterview: () => resumeInterview2,
  recordSubagentExecution: () => recordSubagentExecution,
  readPRDFile: () => readPRDFile,
  processMessage: () => processMessage,
  processIntake: () => processIntake,
  processConversationalMessage: () => processConversationalMessage,
  loadSession: () => loadSession,
  isReadyForFinalization: () => isReadyForFinalization,
  isNearCapacity: () => isNearCapacity,
  investigate: () => investigate,
  getSubagentUsageSummary: () => getSubagentUsageSummary,
  getSubagentPrompt: () => getSubagentPrompt,
  getRoundSystemPrompt: () => getRoundSystemPrompt,
  getRoundNumber: () => getRoundNumber2,
  getRoundEstimatedMinutes: () => getRoundEstimatedMinutes,
  getRoundDisplayName: () => getRoundDisplayName2,
  getRoundContext: () => getRoundContext,
  getReviewSystemPrompt: () => getReviewSystemPrompt,
  getPRDsDir: () => getPRDsDir,
  getPRDPath: () => getPRDPath,
  getContextState: () => getContextState,
  getAvailableTokens: () => getAvailableTokens,
  getAnthropicClient: () => getAnthropicClient,
  generateSuggestions: () => generateSuggestions,
  generatePRDSlug: () => generatePRDSlug,
  formatSectionIcon: () => formatSectionIcon,
  formatReviewResult: () => formatReviewResult,
  formatProgressSummary: () => formatProgressSummary,
  formatProgressBar: () => formatProgressBar,
  formatHandoffContext: () => formatHandoffContext,
  formatCost: () => formatCost,
  formatConflict: () => formatConflict,
  executeTool: () => executeTool,
  estimateTokens: () => estimateTokens,
  estimateMessagesTokens: () => estimateMessagesTokens,
  createToolExecutor: () => createToolExecutor,
  createSubagentSpawner: () => createSubagentSpawner,
  createSession: () => createSession,
  createSectionTracker: () => createSectionTracker,
  createPRDFile: () => createPRDFile,
  createCostTracker: () => createCostTracker,
  createAgentRegistry: () => createAgentRegistry,
  continueWithToolResults: () => continueWithToolResults,
  collectStreamedResponse: () => collectStreamedResponse,
  clearSubagentHistory: () => clearSubagentHistory,
  calculateSingleUsageCost: () => calculateSingleUsageCost,
  calculateContextTokens: () => calculateContextTokens,
  buildSummarizationPrompt: () => buildSummarizationPrompt,
  buildHandoffContext: () => buildHandoffContext,
  appendTasks: () => appendTasks,
  addSubagentExecution: () => addSubagentExecution,
  SubagentSpawner: () => SubagentSpawner,
  SubagentCostTracker: () => SubagentCostTracker,
  SessionSaveError: () => SessionSaveError,
  SessionLoadError: () => SessionLoadError,
  SectionTracker: () => SectionTracker,
  ReviewError: () => ReviewError,
  ROUND_TO_SECTIONS: () => ROUND_TO_SECTIONS,
  ROUND_ORDER: () => ROUND_ORDER,
  PRDFileError: () => PRDFileError,
  InvestigationError: () => InvestigationError,
  InterviewError: () => InterviewError,
  InterviewCancelledError: () => InterviewCancelledError,
  INTERVIEW_TOOLS: () => INTERVIEW_TOOLS,
  ContextOverflowError: () => ContextOverflowError,
  COMMON_QUERIES: () => COMMON_QUERIES,
  AnthropicKeyNotFoundError: () => AnthropicKeyNotFoundError,
  AnthropicAPIError: () => AnthropicAPIError,
  AgentRegistry: () => AgentRegistry
});
function createAgentStreamRenderer() {
  const renderer = createStreamRenderer({ margin: 2 });
  let fullResponse = "";
  return {
    renderer,
    onChunk: (chunk) => {
      fullResponse += chunk;
      renderer.handler(chunk);
    },
    getFullResponse: () => fullResponse
  };
}
async function startInterview2(projectRoot) {
  const config = await loadConfig(projectRoot);
  const configYaml = $stringify(config);
  const prdNumber = await getNextPRDNumber(projectRoot);
  const featureName = await ae({
    message: "What feature are you building?",
    placeholder: "e.g., Token Studio Integration",
    validate: (value) => {
      if (!value.trim())
        return "Feature name is required";
      return;
    }
  });
  if (lD(featureName)) {
    throw new InterviewCancelledError("framing", "User cancelled");
  }
  const prdSlug = generatePRDSlug(prdNumber, featureName);
  const owner = await ae({
    message: "Who owns this feature?",
    placeholder: "Your name or username"
  });
  if (lD(owner)) {
    throw new InterviewCancelledError("framing", "User cancelled");
  }
  const dateStr = new Date().toISOString().split("T")[0] ?? new Date().toISOString().slice(0, 10);
  const frontmatter = {
    feature_name: featureName,
    feature_slug: prdSlug,
    owner: owner || "unknown",
    status: "draft",
    created_date: dateStr
  };
  const prdPath = await createPRDFile(projectRoot, prdSlug, frontmatter);
  v2.success(`Created PRD: ${prdPath}`);
  const session = await createSession(projectRoot, prdSlug, prdPath);
  await setCurrentPRD(projectRoot, prdSlug, "framing");
  v2.step(`Starting interview for "${featureName}"`);
  v2.info("This will take approximately 28 minutes across 5 rounds.");
  const prdContent = await readPRDFile(projectRoot, prdSlug);
  const { renderer, onChunk } = createAgentStreamRenderer();
  const result = await startInterview(session, {
    projectRoot,
    projectConfig: configYaml,
    checkpointData: null,
    prdContent,
    onChunk,
    onRoundComplete: (round) => {
      renderer.flush();
      v2.success(`Round ${getRoundNumber2(round)} complete: ${getRoundDisplayName2(round)}`);
    }
  });
  renderer.flush();
  console.log(`
`);
  await runInterviewLoop(projectRoot, result.session, configYaml, null);
}
async function resumeInterview2(projectRoot) {
  const state = await loadState(projectRoot);
  if (!state.current_prd) {
    v2.error("No interview in progress");
    return;
  }
  const prdSlug = state.current_prd;
  if (!sessionExists(projectRoot, prdSlug)) {
    v2.error(`Session not found for ${prdSlug}`);
    return;
  }
  const session = await loadSession(projectRoot, prdSlug);
  v2.info(`Resuming interview for "${prdSlug}"`);
  v2.info(`Current round: ${getRoundDisplayName2(session.currentRound)}`);
  const config = await loadConfig(projectRoot);
  const configYaml = $stringify(config);
  const prdContent = await readPRDFile(projectRoot, prdSlug);
  const { renderer, onChunk } = createAgentStreamRenderer();
  const result = await resumeInterview(session, {
    projectRoot,
    projectConfig: configYaml,
    checkpointData: null,
    prdContent,
    onChunk,
    onRoundComplete: (round) => {
      renderer.flush();
      v2.success(`Round ${getRoundNumber2(round)} complete: ${getRoundDisplayName2(round)}`);
    }
  });
  renderer.flush();
  console.log(`
`);
  await runInterviewLoop(projectRoot, result.session, configYaml, null);
}
async function runInterviewLoop(projectRoot, initialSession, projectConfig, checkpointData) {
  let session = initialSession;
  const collapsible = createCollapsibleRenderer({ previewLines: 3 });
  const keypress = createKeypressManager();
  try {
    while (session.status === "in-progress") {
      keypress.deactivate();
      const input = await ae({
        message: `Round ${getRoundNumber2(session.currentRound)}`,
        placeholder: "Your response..."
      });
      if (lD(input)) {
        const shouldSave = await ce({
          message: "Save progress and exit?",
          initialValue: true
        });
        if (lD(shouldSave) || shouldSave) {
          await saveSession(projectRoot, session);
          v2.info("Progress saved. Run `karimo` to resume.");
        }
        return;
      }
      const processed = processUserInput(input);
      collapsible.render(processed);
      keypress.activate([{ key: "ctrl+o", callback: () => collapsible.toggleLast() }]);
      const prdContent = await readPRDFile(projectRoot, session.prdSlug);
      const { renderer, onChunk, getFullResponse } = createAgentStreamRenderer();
      keypress.pause();
      const result = await processMessage(session, processed.original, {
        projectRoot,
        projectConfig,
        checkpointData,
        prdContent,
        onChunk,
        onRoundComplete: (round) => {
          renderer.flush();
          console.log(`
`);
          v2.success(`Round ${getRoundNumber2(round)} complete: ${getRoundDisplayName2(round)}`);
        },
        onSummarization: () => {
          renderer.flush();
          v2.info("Context summarized to maintain quality.");
        }
      });
      renderer.flush();
      getFullResponse();
      console.log(`
`);
      session = result.session;
      keypress.resume();
      if (result.allComplete) {
        v2.success("All interview rounds complete!");
        break;
      }
    }
    if (session.status === "reviewing") {
      await runReview(projectRoot, session);
    }
  } finally {
    keypress.deactivate();
    collapsible.cleanup();
  }
}
async function runReview(projectRoot, session) {
  v2.step("Running PRD review...");
  const prdContent = await readPRDFile(projectRoot, session.prdSlug);
  const reviewSpinner = _2();
  reviewSpinner.start("Analyzing PRD...");
  const result = await reviewPRD(prdContent);
  reviewSpinner.stop("Review complete");
  console.log(`
`);
  console.log(formatReviewResult(result));
  console.log(`
`);
  if (isReadyForFinalization(result)) {
    const finalize = await ce({
      message: "PRD looks good! Finalize it?",
      initialValue: true
    });
    if (lD(finalize)) {
      await saveSession(projectRoot, { ...session, status: "reviewing" });
      return;
    }
    if (finalize) {
      await saveSession(projectRoot, { ...session, status: "finalized" });
      v2.success("PRD finalized! Ready for execution.");
    }
  } else {
    v2.warn("Please address the issues above before finalizing.");
    const action = await le({
      message: "What would you like to do?",
      options: [
        { value: "edit", label: "Edit the PRD manually" },
        { value: "continue", label: "Continue interview to address issues" },
        { value: "save", label: "Save and exit for now" }
      ]
    });
    if (lD(action)) {
      await saveSession(projectRoot, session);
      return;
    }
    switch (action) {
      case "edit":
        v2.info(`Edit the PRD at: ${session.prdPath}`);
        v2.info("Run `karimo` again when ready to re-review.");
        break;
      case "continue": {
        const updatedSession = { ...session, status: "in-progress" };
        await saveSession(projectRoot, updatedSession);
        v2.info("Session reset. Run `karimo` again to continue the interview.");
        break;
      }
      case "save":
        await saveSession(projectRoot, session);
        v2.info("Progress saved.");
        break;
    }
  }
}
async function startNewInterview(projectRoot) {
  const config = await loadConfig(projectRoot);
  const configYaml = $stringify(config);
  const prdNumber = await getNextPRDNumber(projectRoot);
  v2.step("Let's define your product requirements.");
  v2.info("Share as much context as you want - meeting notes, rough ideas, or detailed specs.");
  v2.info(`I'll extract the key information as we talk.
`);
  const initialContext = await ae({
    message: "What feature or project are you working on? Tell me everything you've got.",
    placeholder: "Paste context, describe the feature, or just start talking...",
    validate: (value) => {
      if (!value.trim())
        return "Please provide some context to get started";
      if (value.trim().length < 20)
        return "Please provide more context (at least a sentence or two)";
      return;
    }
  });
  if (lD(initialContext)) {
    throw new InterviewCancelledError("intake", "User cancelled");
  }
  const intakeSpinner = _2();
  intakeSpinner.start("Analyzing your context...");
  let intakeResult;
  try {
    intakeResult = await processIntake(initialContext);
    intakeSpinner.stop("Context analyzed");
  } catch (error2) {
    intakeSpinner.stop("Analysis failed");
    throw error2;
  }
  console.log(`
`);
  v2.info(`Suggested title: ${intakeResult.suggestedTitle}`);
  v2.info(`Scope: ${intakeResult.scopeType.replace("-", " ")}`);
  const featureName = await ae({
    message: "Feature name (press Enter to accept)",
    defaultValue: intakeResult.suggestedTitle,
    placeholder: intakeResult.suggestedTitle
  });
  if (lD(featureName)) {
    throw new InterviewCancelledError("intake", "User cancelled");
  }
  const finalName = featureName || intakeResult.suggestedTitle;
  const prdSlug = generatePRDSlug(prdNumber, finalName);
  const owner = await ae({
    message: "Who owns this feature?",
    placeholder: "Your name or username"
  });
  if (lD(owner)) {
    throw new InterviewCancelledError("intake", "User cancelled");
  }
  const dateStr = new Date().toISOString().split("T")[0] ?? new Date().toISOString().slice(0, 10);
  const frontmatter = {
    feature_name: finalName,
    feature_slug: prdSlug,
    owner: owner || "unknown",
    status: "draft",
    created_date: dateStr
  };
  const prdPath = await createPRDFile(projectRoot, prdSlug, frontmatter);
  v2.success(`Created PRD: ${prdPath}`);
  if (intakeResult.executiveSummary) {
    await updatePRDSection(projectRoot, prdSlug, 1, "Executive Summary", intakeResult.executiveSummary);
  }
  for (const [sectionId, content] of Object.entries(intakeResult.initialSections)) {
    const sectionNum = getSectionNumber(sectionId);
    if (sectionNum && content) {
      await updatePRDSection(projectRoot, prdSlug, sectionNum, getSectionTitle(sectionId), content);
    }
  }
  const tracker = new SectionTracker;
  if (intakeResult.executiveSummary) {
    tracker.updateSection("executive-summary", "partial", 60);
  }
  for (const sectionId of Object.keys(intakeResult.initialSections)) {
    tracker.updateSection(sectionId, "partial", 50);
  }
  await setCurrentPRD(projectRoot, prdSlug, "requirements");
  const progress = tracker.getProgress();
  console.log(`
`);
  v2.info("Initial progress:");
  console.log(`  ${formatProgressBar(progress.overallPercent)}`);
  console.log(`
`);
  if (intakeResult.gapsToExplore.length > 0) {
    v2.info(`Topics to explore: ${intakeResult.gapsToExplore.join(", ")}`);
    console.log(`
`);
  }
  const state = {
    projectRoot,
    prdSlug,
    prdPath,
    tracker,
    messages: [],
    configYaml
  };
  const { renderer, onChunk } = createAgentStreamRenderer();
  const greeting = await startConversationalInterview({
    projectRoot,
    prdSlug,
    prdContent: await readPRDFile(projectRoot, prdSlug),
    projectConfig: configYaml,
    tracker,
    onChunk
  });
  renderer.flush();
  console.log(greeting.response);
  console.log(`
`);
  state.messages.push({
    role: "assistant",
    content: greeting.response
  });
  await runConversationalLoop(state);
}
async function runConversationalLoop(state) {
  const { projectRoot, prdSlug, tracker, configYaml } = state;
  const collapsible = createCollapsibleRenderer({ previewLines: 3 });
  const keypress = createKeypressManager();
  try {
    while (true) {
      keypress.deactivate();
      const progress = tracker.getProgress();
      const promptMsg = progress.overallPercent >= 80 ? 'Your response (or "done" to finalize)' : "Your response";
      const input = await ae({
        message: promptMsg,
        placeholder: "Continue describing your feature..."
      });
      if (lD(input)) {
        v2.info("Progress saved to PRD file.");
        return;
      }
      if (input.toLowerCase().trim() === "done" && progress.overallPercent >= 80) {
        await handleFinalization(state);
        return;
      }
      const processed = processUserInput(input);
      collapsible.render(processed);
      keypress.activate([{ key: "ctrl+o", callback: () => collapsible.toggleLast() }]);
      state.messages.push({
        role: "user",
        content: processed.original
      });
      const prdContent = await readPRDFile(projectRoot, prdSlug);
      const { renderer, onChunk, getFullResponse } = createAgentStreamRenderer();
      keypress.pause();
      const result = await processConversationalMessage(state.messages, processed.original, {
        projectRoot,
        prdSlug,
        prdContent,
        projectConfig: configYaml,
        tracker,
        onChunk,
        onToolResult: (toolResult) => {
          renderer.flush();
          if (toolResult.isConflict) {
            console.log(`
`);
            v2.warn(toolResult.message);
          } else if (toolResult.success) {
            console.log(`
  ${toolResult.message}`);
          }
        },
        onProgress: (prog) => {
          const milestones = [25, 50, 75, 95];
          const lastPercent = state.tracker.getProgress().overallPercent;
          for (const milestone of milestones) {
            if (lastPercent < milestone && prog.overallPercent >= milestone) {
              console.log(`
  \uD83C\uDF1F ${milestone}% milestone: ${formatProgressBar(prog.overallPercent)}`);
            }
          }
        }
      });
      renderer.flush();
      getFullResponse();
      keypress.resume();
      if (result.response) {
        state.messages.push({
          role: "assistant",
          content: result.response
        });
        console.log(`
`);
      }
      if (result.suggestFinalize) {
        keypress.deactivate();
        const finalize = await ce({
          message: "PRD is looking comprehensive. Would you like to finalize it?",
          initialValue: true
        });
        if (!lD(finalize) && finalize) {
          await handleFinalization(state);
          return;
        }
      } else if (result.offerFinalize) {
        v2.info(`Tip: Type "done" when you're ready to finalize the PRD.`);
      }
    }
  } finally {
    keypress.deactivate();
    collapsible.cleanup();
  }
}
async function handleFinalization(state) {
  const { projectRoot, prdSlug, tracker } = state;
  const conflicts = tracker.getUnresolvedConflicts();
  if (conflicts.length > 0) {
    v2.warn(`There are ${conflicts.length} unresolved conflict(s) that must be resolved first.`);
    for (const conflict of conflicts) {
      console.log(`
  \u26A0\uFE0F  ${conflict.description}`);
      console.log(`     Earlier: "${conflict.earlierStatement}"`);
      console.log(`     Now: "${conflict.laterStatement}"`);
      const resolution = await ae({
        message: "How should this be resolved?",
        placeholder: "Describe the resolution..."
      });
      if (lD(resolution)) {
        v2.info("Finalization cancelled. Progress saved.");
        return;
      }
      tracker.resolveConflict(conflict.id, resolution);
    }
  }
  const progress = tracker.getProgress();
  console.log(`
`);
  v2.info("Final PRD status:");
  console.log(`  ${formatProgressBar(progress.overallPercent)}`);
  console.log(`  ${progress.completeSections}/${progress.totalSections} sections complete`);
  console.log(`
`);
  v2.step("Running PRD review...");
  const prdContent = await readPRDFile(projectRoot, prdSlug);
  const reviewSpinner = _2();
  reviewSpinner.start("Analyzing PRD...");
  const reviewResult = await reviewPRD(prdContent);
  reviewSpinner.stop("Review complete");
  console.log(`
`);
  console.log(formatReviewResult(reviewResult));
  console.log(`
`);
  if (isReadyForFinalization(reviewResult)) {
    v2.success("PRD finalized! Ready for execution.");
  } else {
    v2.warn("Some issues were found. Consider addressing them before execution.");
  }
}
function getSectionNumber(sectionId) {
  const map = {
    "executive-summary": 1,
    "problem-context": 2,
    "goals-metrics": 3,
    requirements: 4,
    "ux-notes": 5,
    "dependencies-risks": 6,
    rollout: 7,
    milestones: 8,
    "open-questions": 9,
    "checkpoint-learnings": 10,
    "agent-boundaries": 11
  };
  return map[sectionId] ?? null;
}
function getSectionTitle(sectionId) {
  const map = {
    "executive-summary": "Executive Summary",
    "problem-context": "Problem & Context",
    "goals-metrics": "Goals & Metrics",
    requirements: "Requirements",
    "ux-notes": "UX Notes",
    "dependencies-risks": "Dependencies & Risks",
    rollout: "Rollout",
    milestones: "Milestones",
    "open-questions": "Open Questions",
    "checkpoint-learnings": "Checkpoint Learnings",
    "agent-boundaries": "Agent Boundaries"
  };
  return map[sectionId] ?? sectionId;
}
var init_interview = __esm(() => {
  init_dist3();
  init_dist();
  init_state();
  init_ui();
  init_loader();
  init_conversational_agent();
  init_intake_agent();
  init_interview_agent();
  init_review_agent();
  init_errors10();
  init_prd_file();
  init_section_tracker();
  init_session();
  init_errors10();
  init_session();
  init_prd_file();
  init_conversation();
  init_section_mapper();
  init_interview_agent();
  init_investigation_agent();
  init_review_agent();
  init_conversational_agent();
  init_intake_agent();
  init_section_tracker();
  init_tools();
  init_subagents();
});

// src/cli/execute-flow.ts
var exports_execute_flow = {};
__export(exports_execute_flow, {
  showExecutionFlow: () => showExecutionFlow
});
async function showExecutionFlow(projectRoot) {
  const prdInfos = await getPRDFileInfos(projectRoot);
  const finalizedPRDs = prdInfos.filter((prd) => prd.finalized);
  if (finalizedPRDs.length === 0) {
    v2.warn("No finalized PRDs found. Create a PRD first.");
    return;
  }
  const state = await loadState(projectRoot);
  const completedPRDSlugs = new Set(state.completed_prds);
  const pendingPRDs = finalizedPRDs.filter((prd) => !completedPRDSlugs.has(prd.slug));
  if (pendingPRDs.length === 0) {
    v2.success("All PRDs complete! \uD83C\uDF89");
    return;
  }
  let selectedPRD;
  if (pendingPRDs.length === 1) {
    const firstPRD = pendingPRDs[0];
    if (!firstPRD) {
      v2.error("No PRD found");
      return;
    }
    selectedPRD = firstPRD;
    v2.info(`Executing PRD: ${selectedPRD.metadata?.feature_name ?? selectedPRD.slug}`);
  } else {
    const selection = await le({
      message: "Select PRD to execute",
      options: pendingPRDs.map((prd) => ({
        value: prd.slug,
        label: prd.metadata?.feature_name ?? prd.slug,
        hint: prd.metadata?.status ?? "active"
      }))
    });
    if (lD(selection)) {
      return;
    }
    const found = pendingPRDs.find((prd) => prd.slug === selection);
    if (!found) {
      v2.error("PRD not found");
      return;
    }
    selectedPRD = found;
  }
  const prdResult = await parsePRDFile(selectedPRD.path);
  if (!prdResult.tasks || prdResult.tasks.length === 0) {
    v2.error("No tasks found in PRD");
    return;
  }
  const graph = buildDependencyGraph(prdResult.tasks);
  const sortedTasks = topologicalSort(graph);
  const sortedTaskIds = sortedTasks.map((t) => t.id);
  displayTaskOverview(prdResult.tasks, sortedTaskIds);
  const action = await le({
    message: "What would you like to do?",
    options: [
      { value: "dry-run", label: "Dry run (preview execution plan)" },
      { value: "execute-one", label: "Execute a single task" },
      { value: "execute-ready", label: "Execute all ready tasks" },
      { value: "back", label: "Go back" }
    ]
  });
  if (lD(action) || action === "back") {
    return;
  }
  switch (action) {
    case "dry-run":
      await runDryRun(projectRoot, selectedPRD.slug, prdResult.tasks);
      break;
    case "execute-one":
      await executeOneTask(projectRoot, selectedPRD.slug, prdResult.tasks, graph);
      break;
    case "execute-ready":
      await executeReadyTasks(projectRoot, selectedPRD.slug, prdResult.tasks, graph);
      break;
  }
}
function displayTaskOverview(tasks, sortedTaskIds) {
  const lines = [];
  lines.push(`Tasks: ${tasks.length}`);
  lines.push("");
  const must = tasks.filter((t) => t.priority === "must");
  const should = tasks.filter((t) => t.priority === "should");
  const could = tasks.filter((t) => t.priority === "could");
  if (must.length > 0) {
    lines.push(`Must Have (${must.length}):`);
    for (const task of must) {
      const deps = task.depends_on.length > 0 ? ` \u2192 depends on: ${task.depends_on.join(", ")}` : "";
      lines.push(`  ${task.id}. ${task.title} [complexity: ${task.complexity}]${deps}`);
    }
    lines.push("");
  }
  if (should.length > 0) {
    lines.push(`Should Have (${should.length}):`);
    for (const task of should) {
      const deps = task.depends_on.length > 0 ? ` \u2192 depends on: ${task.depends_on.join(", ")}` : "";
      lines.push(`  ${task.id}. ${task.title} [complexity: ${task.complexity}]${deps}`);
    }
    lines.push("");
  }
  if (could.length > 0) {
    lines.push(`Could Have (${could.length}):`);
    for (const task of could) {
      const deps = task.depends_on.length > 0 ? ` \u2192 depends on: ${task.depends_on.join(", ")}` : "";
      lines.push(`  ${task.id}. ${task.title} [complexity: ${task.complexity}]${deps}`);
    }
    lines.push("");
  }
  lines.push("Execution Order:");
  lines.push(`  ${sortedTaskIds.join(" \u2192 ")}`);
  me(lines.join(`
`), "Task Overview");
}
async function runDryRun(_projectRoot, phaseId, tasks) {
  const taskId = await selectTask(tasks, "Select task for dry run");
  if (!taskId)
    return;
  const spinner = _2();
  spinner.start("Generating execution plan...");
  try {
    const plan = await createDryRunPlan({
      phaseId,
      taskId
    });
    spinner.stop("Plan generated");
    console.log(`
`);
    printDryRunPlan(plan);
  } catch (error2) {
    spinner.stop("Failed to generate plan");
    v2.error(error2.message);
  }
}
async function executeOneTask(_projectRoot, phaseId, tasks, graph) {
  const readyTaskObjects = getReadyTasks(graph, new Set);
  const readyTaskIds = new Set(readyTaskObjects.map((t) => t.id));
  const taskId = await selectTask(tasks, "Select task to execute", readyTaskIds);
  if (!taskId)
    return;
  const task = tasks.find((t) => t.id === taskId);
  if (!task) {
    v2.error("Task not found");
    return;
  }
  const confirm = await ce({
    message: `Execute "${task.title}" (complexity: ${task.complexity})?`,
    initialValue: true
  });
  if (lD(confirm) || !confirm) {
    return;
  }
  const spinner = _2();
  spinner.start("Executing task...");
  try {
    const result = await runTask({
      phaseId,
      taskId
    });
    spinner.stop("Task completed");
    if (result.success) {
      v2.success(`PR created: ${result.run.prUrl ?? "N/A"}`);
    } else {
      v2.error(`Task failed: ${result.run.errorMessage ?? "Unknown error"}`);
    }
  } catch (error2) {
    spinner.stop("Task failed");
    v2.error(error2.message);
  }
}
async function executeReadyTasks(_projectRoot, phaseId, _tasks, graph) {
  const readyTaskObjects = getReadyTasks(graph, new Set);
  if (readyTaskObjects.length === 0) {
    v2.warn("No tasks ready for execution");
    return;
  }
  const readyTaskDetails = readyTaskObjects.map((task) => {
    return `${task.id}: ${task.title} (complexity: ${task.complexity})`;
  });
  me(readyTaskDetails.join(`
`), "Ready Tasks");
  const confirm = await ce({
    message: `Execute ${readyTaskObjects.length} ready task(s)?`,
    initialValue: true
  });
  if (lD(confirm) || !confirm) {
    return;
  }
  for (const task of readyTaskObjects) {
    v2.step(`Executing: ${task.title}`);
    const spinner = _2();
    spinner.start("Running agent...");
    try {
      const result = await runTask({
        phaseId,
        taskId: task.id
      });
      spinner.stop("Complete");
      if (result.success) {
        v2.success(`PR created: ${result.run.prUrl ?? "N/A"}`);
      } else {
        v2.error(`Task failed: ${result.run.errorMessage ?? "Unknown error"}`);
        const continueExec = await ce({
          message: "Continue with remaining tasks?",
          initialValue: false
        });
        if (lD(continueExec) || !continueExec) {
          return;
        }
      }
    } catch (error2) {
      spinner.stop("Failed");
      v2.error(error2.message);
      const continueExec = await ce({
        message: "Continue with remaining tasks?",
        initialValue: false
      });
      if (lD(continueExec) || !continueExec) {
        return;
      }
    }
  }
  v2.success("All ready tasks executed");
}
async function selectTask(tasks, message, readyTasks) {
  const options = tasks.map((task) => {
    const isReady = !readyTasks || readyTasks.has(task.id);
    const hint = isReady ? `complexity: ${task.complexity}` : `blocked (depends on: ${task.depends_on.join(", ")})`;
    return {
      value: task.id,
      label: `${task.id}: ${task.title}`,
      hint
    };
  });
  const selection = await le({
    message,
    options
  });
  if (lD(selection)) {
    return null;
  }
  return selection;
}
var init_execute_flow = __esm(() => {
  init_dist3();
  init_orchestrator();
  init_prd();
  init_state();
});

// src/cli/commands/info.ts
var exports_info = {};
__export(exports_info, {
  showInfo: () => showInfo,
  handleInfo: () => handleInfo
});
function showInfo() {
  console.log(getCompactBannerString());
  console.log();
  console.log(`${GYD}${VERSION9}${RST}`);
  console.log(`${GY}${TAGLINE}${RST}`);
  console.log();
  console.log(`${GY}Learn more:${RST} ${OR}>>${RST} ${WH}${GITHUB_URL}${RST}`);
  console.log();
}
function handleInfo() {
  showInfo();
}
var TAGLINE = "Autonomous development framework \u2014 agent, tool, and repo agnostic";
var init_info = __esm(() => {
  init_colors();
  init_compact_banner();
  init_welcome_content();
});

// src/cli/index.ts
init_orchestrate_command();
init_doctor_command();
init_reset_command();
init_note_command();
init_first_run();
init_safety();
init_telemetry();

// src/cli/main.ts
init_dist3();
import { existsSync as existsSync19 } from "fs";
import { resolve as resolve3 } from "path";
function parseCommand(args) {
  const flags = new Map;
  const positional = [];
  for (let i = 0;i < args.length; i++) {
    const arg = args[i];
    if (arg === undefined)
      continue;
    if (arg.startsWith("--")) {
      const key = arg.slice(2);
      const nextArg = args[i + 1];
      if (nextArg !== undefined && !nextArg.startsWith("-")) {
        flags.set(key, nextArg);
        i++;
      } else {
        flags.set(key, true);
      }
    } else if (arg.startsWith("-")) {
      const key = arg.slice(1);
      flags.set(key, true);
    } else {
      positional.push(arg);
    }
  }
  const command = positional[0]?.toLowerCase();
  if (flags.has("help") || flags.has("h")) {
    return { type: "help", args: positional, flags };
  }
  if (flags.has("version") || flags.has("v")) {
    return { type: "version", args: positional, flags };
  }
  switch (command) {
    case "init":
      return { type: "init", args: positional.slice(1), flags };
    case "doctor":
      return { type: "doctor", args: positional.slice(1), flags };
    case "onboard":
      return { type: "onboard", args: positional.slice(1), flags };
    case "orchestrate":
    case "run":
      return { type: "orchestrate", args: positional.slice(1), flags };
    case "status":
      return { type: "status", args: positional.slice(1), flags };
    case "reset":
      return { type: "reset", args: positional.slice(1), flags };
    case "note":
      return { type: "note", args: positional.slice(1), flags };
    case "checkpoint":
      return { type: "checkpoint", args: positional.slice(1), flags };
    case "info":
    case "about":
      return { type: "info", args: positional.slice(1), flags };
    case "help":
      return { type: "help", args: positional.slice(1), flags };
    case "version":
      return { type: "version", args: positional.slice(1), flags };
    default:
      return { type: "guided", args: positional, flags };
  }
}
async function executeCommand(command, projectRoot, firstRunHandled = false) {
  switch (command.type) {
    case "init": {
      if (!firstRunHandled) {
        const { isOnboardedSync: isOnboardedSync2 } = await Promise.resolve().then(() => (init_state(), exports_state));
        if (!isOnboardedSync2(projectRoot)) {
          const { runFirstRunFlow: runFirstRunFlow2 } = await Promise.resolve().then(() => (init_first_run(), exports_first_run));
          const shouldContinue = await runFirstRunFlow2(projectRoot);
          if (!shouldContinue) {
            return;
          }
          const { markOnboarded: markOnboarded2 } = await Promise.resolve().then(() => (init_state(), exports_state));
          await markOnboarded2(projectRoot);
        }
      }
      const { configExists: configExists3, detectProjectPhase: detectProjectPhase2 } = await Promise.resolve().then(() => (init_state(), exports_state));
      if (configExists3(projectRoot)) {
        const phase = await detectProjectPhase2(projectRoot);
        const { showReturningWelcome: showReturningWelcome2 } = await Promise.resolve().then(() => (init_returning_welcome(), exports_returning_welcome));
        const action = await showReturningWelcome2(projectRoot, phase);
        if (!action || action === "exit") {
          return;
        }
        switch (action) {
          case "init":
          case "reconfigure": {
            const { runInit: runInit3 } = await Promise.resolve().then(() => (init_init(), exports_init));
            await runInit3(projectRoot);
            break;
          }
          case "resume-prd": {
            const { resumeInterview: resumeInterview3 } = await Promise.resolve().then(() => (init_interview(), exports_interview));
            await resumeInterview3(projectRoot);
            break;
          }
          case "start-prd": {
            const { startInterview: startInterview3 } = await Promise.resolve().then(() => (init_interview(), exports_interview));
            await startInterview3(projectRoot);
            break;
          }
          case "execute": {
            const { showExecutionFlow: showExecutionFlow2 } = await Promise.resolve().then(() => (init_execute_flow(), exports_execute_flow));
            await showExecutionFlow2(projectRoot);
            break;
          }
          case "help":
            printHelp();
            break;
        }
        return;
      }
      const { runInit: runInit2 } = await Promise.resolve().then(() => (init_init(), exports_init));
      const initResult = await runInit2(projectRoot);
      if (initResult.success) {
        console.log();
        const startPRD = await ce({
          message: "Ready to create your first PRD?",
          initialValue: true
        });
        if (!lD(startPRD) && startPRD) {
          const { startInterview: startInterview3 } = await Promise.resolve().then(() => (init_interview(), exports_interview));
          await startInterview3(projectRoot);
        } else {
          v2.info("Run `karimo` anytime to start your first PRD.");
        }
      }
      break;
    }
    case "doctor": {
      const { handleDoctor: handleDoctor2, parseDoctorArgs: parseDoctorArgs2 } = await Promise.resolve().then(() => (init_doctor_command(), exports_doctor_command));
      const { recordDoctorRun: recordDoctorRun2 } = await Promise.resolve().then(() => (init_state(), exports_state));
      const doctorOptions = {
        projectRoot,
        ...parseDoctorArgs2([...command.args, ...flagsToArgs(command.flags)])
      };
      const exitCode = await handleDoctor2(doctorOptions);
      await recordDoctorRun2(projectRoot);
      if (exitCode !== 0) {
        process.exit(exitCode);
      }
      break;
    }
    case "onboard": {
      await handleOnboard(projectRoot);
      break;
    }
    case "orchestrate": {
      const { handleOrchestrate: handleOrchestrate2, parseOrchestrateArgs: parseOrchestrateArgs2 } = await Promise.resolve().then(() => (init_orchestrate_command(), exports_orchestrate_command));
      const orchestrateOptions = parseOrchestrateArgs2([
        ...command.args,
        ...flagsToArgs(command.flags)
      ]);
      await handleOrchestrate2(orchestrateOptions);
      break;
    }
    case "status":
      v2.info("Status command not yet implemented");
      break;
    case "reset": {
      const { handleReset: handleReset2, parseResetArgs: parseResetArgs2 } = await Promise.resolve().then(() => (init_reset_command(), exports_reset_command));
      const resetOptions = {
        projectRoot,
        ...parseResetArgs2([...command.args, ...flagsToArgs(command.flags)])
      };
      await handleReset2(resetOptions);
      break;
    }
    case "note": {
      const { handleNote: handleNote2, parseNoteArgs: parseNoteArgs2, printNoteHelp: printNoteHelp2 } = await Promise.resolve().then(() => (init_note_command(), exports_note_command));
      const noteResult = parseNoteArgs2([...command.args, ...flagsToArgs(command.flags)]);
      if (!noteResult) {
        printNoteHelp2();
        break;
      }
      await handleNote2({
        projectRoot,
        tag: noteResult.tag,
        message: noteResult.message
      });
      break;
    }
    case "checkpoint": {
      v2.info("Checkpoint command coming in Level 2.");
      console.log();
      v2.info("For now, capture feedback with:");
      v2.info('  karimo note "your observation"');
      break;
    }
    case "info": {
      const { handleInfo: handleInfo2 } = await Promise.resolve().then(() => (init_info(), exports_info));
      handleInfo2();
      break;
    }
    case "help":
      printHelp();
      break;
    case "version":
      printVersion();
      break;
    default:
      v2.error(`Unknown command: ${command.type}`);
      printHelp();
      process.exit(1);
  }
}
function flagsToArgs(flags) {
  const args = [];
  for (const [key, value] of flags) {
    if (typeof value === "boolean" && value) {
      args.push(`--${key}`);
    } else if (typeof value === "string") {
      args.push(`--${key}`, value);
    }
  }
  return args;
}
async function runGuidedFlow(projectRoot, firstRunHandled = false) {
  const { detectProjectPhase: detectProjectPhase2, markOnboarded: markOnboarded2 } = await Promise.resolve().then(() => (init_state(), exports_state));
  const phase = await detectProjectPhase2(projectRoot);
  switch (phase) {
    case "welcome": {
      if (firstRunHandled) {
        const { runInit: runInit2 } = await Promise.resolve().then(() => (init_init(), exports_init));
        const initResult = await runInit2(projectRoot);
        if (initResult.success) {
          console.log();
          const startPRD = await ce({
            message: "Ready to create your first PRD?",
            initialValue: true
          });
          if (!lD(startPRD) && startPRD) {
            const { startInterview: startInterview3 } = await Promise.resolve().then(() => (init_interview(), exports_interview));
            await startInterview3(projectRoot);
          } else {
            v2.info("Run `karimo` anytime to start your first PRD.");
          }
        }
        break;
      }
      const { runFirstRunFlow: runFirstRunFlow2 } = await Promise.resolve().then(() => (init_first_run(), exports_first_run));
      const shouldContinue = await runFirstRunFlow2(projectRoot);
      if (!shouldContinue) {
        return;
      }
      await markOnboarded2(projectRoot);
      const { runInit: runInitAgain2 } = await Promise.resolve().then(() => (init_init(), exports_init));
      const initResult2 = await runInitAgain2(projectRoot);
      if (initResult2.success) {
        console.log();
        const startPRD = await ce({
          message: "Ready to create your first PRD?",
          initialValue: true
        });
        if (!lD(startPRD) && startPRD) {
          const { startInterview: startInterview3 } = await Promise.resolve().then(() => (init_interview(), exports_interview));
          await startInterview3(projectRoot);
        } else {
          v2.info("Run `karimo` anytime to start your first PRD.");
        }
      }
      break;
    }
    case "init": {
      const { showReturningWelcome: showReturningWelcome2 } = await Promise.resolve().then(() => (init_returning_welcome(), exports_returning_welcome));
      const action = await showReturningWelcome2(projectRoot, phase);
      if (!action || action === "exit") {
        return;
      }
      if (action === "init") {
        const { runInit: runInitAgain } = await Promise.resolve().then(() => (init_init(), exports_init));
        const initResult = await runInitAgain(projectRoot);
        if (initResult.success) {
          console.log();
          const startPRD = await ce({
            message: "Ready to create your first PRD?",
            initialValue: true
          });
          if (!lD(startPRD) && startPRD) {
            const { startInterview: startInterview3 } = await Promise.resolve().then(() => (init_interview(), exports_interview));
            await startInterview3(projectRoot);
          } else {
            v2.info("Run `karimo` anytime to start your first PRD.");
          }
        }
      } else if (action === "help") {
        printHelp();
      }
      break;
    }
    case "create-prd":
    case "resume-prd":
    case "execute":
    case "complete": {
      const { showReturningWelcome: showReturningWelcome2 } = await Promise.resolve().then(() => (init_returning_welcome(), exports_returning_welcome));
      const action = await showReturningWelcome2(projectRoot, phase);
      if (!action || action === "exit") {
        return;
      }
      switch (action) {
        case "resume-prd": {
          const { resumeInterview: resumeInterview3 } = await Promise.resolve().then(() => (init_interview(), exports_interview));
          await resumeInterview3(projectRoot);
          break;
        }
        case "start-prd": {
          const { startInterview: startInterview3 } = await Promise.resolve().then(() => (init_interview(), exports_interview));
          await startInterview3(projectRoot);
          break;
        }
        case "execute": {
          const { showExecutionFlow: showExecutionFlow2 } = await Promise.resolve().then(() => (init_execute_flow(), exports_execute_flow));
          await showExecutionFlow2(projectRoot);
          break;
        }
        case "init":
        case "reconfigure": {
          const { runInit: runInit2 } = await Promise.resolve().then(() => (init_init(), exports_init));
          await runInit2(projectRoot);
          break;
        }
        case "help":
          printHelp();
          break;
      }
      break;
    }
  }
}
async function handleOnboard(projectRoot) {
  const { karimoDirExists: karimoDirExists2, configExists: configExists3 } = await Promise.resolve().then(() => (init_state(), exports_state));
  const { runDoctorChecks: runDoctorChecks2, formatSetupChecklist: formatSetupChecklist2 } = await Promise.resolve().then(() => (init_doctor(), exports_doctor));
  const { showCompactHeader: showCompactHeader2 } = await Promise.resolve().then(() => (init_ui(), exports_ui));
  showCompactHeader2();
  if (!karimoDirExists2(projectRoot)) {
    v2.error("This project has not been configured with KARIMO.");
    v2.info("Run `karimo init` to set up this project.");
    return;
  }
  if (!configExists3(projectRoot)) {
    v2.error(".karimo/ exists but config.yaml is missing.");
    v2.info("Run `karimo init` to complete setup.");
    return;
  }
  v2.info("Verifying your environment...");
  console.log();
  const report = await runDoctorChecks2({ projectRoot });
  console.log(formatSetupChecklist2(report));
  console.log();
  if (report.overall === "pass") {
    v2.success("Your environment is ready to work on this project.");
    const { loadConfig: loadConfig2 } = await Promise.resolve().then(() => (init_config(), exports_config));
    try {
      const result = await loadConfig2(projectRoot);
      const cfg = result.config;
      console.log();
      const configSummary = cfg.commands.test ? `Project: ${cfg.project.name}
Build:   ${cfg.commands.build}
Lint:    ${cfg.commands.lint}
Test:    ${cfg.commands.test}` : `Project: ${cfg.project.name}
Build:   ${cfg.commands.build}
Lint:    ${cfg.commands.lint}`;
      me(configSummary, "Project Configuration");
    } catch {}
  } else {
    v2.error("Your environment has issues that need to be resolved.");
    v2.info("Run `karimo doctor` for detailed fix instructions.");
    process.exit(1);
  }
}
function printHelp() {
  console.log(`
KARIMO - Autonomous Development Framework

Usage:
  karimo                   Run guided workflow (recommended)
  karimo init              Initialize KARIMO in current project
  karimo doctor            Check environment prerequisites
  karimo onboard           Verify setup for team members
  karimo orchestrate       Execute tasks from PRD
  karimo status            Show current project status
  karimo note <message>    Capture dogfooding note
  karimo checkpoint        Capture learning checkpoint (Level 2)
  karimo reset             Reset KARIMO state
  karimo info              Show version and project info
  karimo help              Show this help message
  karimo version           Show version

Options:
  --root <PATH>            Run KARIMO in a different directory
  --help, -h               Show help
  --version, -v            Show version

Doctor Options:
  --check                  CI mode (exit codes only)
  --json                   Output JSON format

Note Options:
  --tag, -t <TAG>          Tag the note (NOTE, BUG, UX, FRICTION, IDEA)

Reset Options:
  --hard                   Delete entire .karimo directory
  --force, -f              Skip confirmation prompt

Guided Workflow:
  Running \`karimo\` without arguments will detect your project state
  and guide you through the appropriate next step:

  1. Welcome & Doctor - First-time setup with prerequisite checks
  2. Init             - Configure project settings
  3. PRD Interview    - Create a PRD through conversation
  4. Execute          - Run agents on finalized PRDs

Documentation:
  https://github.com/opensesh/KARIMO

Get Help:
  https://github.com/opensesh/KARIMO/issues
`);
}
function printVersion() {
  console.log("KARIMO v0.0.1");
}
async function main(projectRoot, args) {
  const command = parseCommand(args);
  let effectiveProjectRoot = projectRoot;
  const rootFlag = command.flags.get("root");
  if (typeof rootFlag === "string") {
    effectiveProjectRoot = resolve3(rootFlag);
    if (!existsSync19(effectiveProjectRoot)) {
      v2.error(`Directory not found: ${effectiveProjectRoot}`);
      process.exit(1);
    }
  }
  if (command.type !== "help" && command.type !== "version") {
    const { checkWorkingDirectory: checkWorkingDirectory2, formatSafetyError: formatSafetyError2 } = await Promise.resolve().then(() => (init_safety(), exports_safety));
    const safetyResult = checkWorkingDirectory2(effectiveProjectRoot);
    if (!safetyResult.safe) {
      v2.error("Cannot run KARIMO in this directory");
      console.log();
      console.log(formatSafetyError2(safetyResult));
      process.exit(1);
    }
  }
  let firstRunHandled = false;
  if (command.type === "init" || command.type === "guided") {
    const { isOnboardedSync: isOnboardedSync2 } = await Promise.resolve().then(() => (init_state(), exports_state));
    if (!isOnboardedSync2(effectiveProjectRoot)) {
      const { runFirstRunFlow: runFirstRunFlow2 } = await Promise.resolve().then(() => (init_first_run(), exports_first_run));
      const shouldContinue = await runFirstRunFlow2(effectiveProjectRoot);
      if (!shouldContinue) {
        return;
      }
      const { markOnboarded: markOnboarded2 } = await Promise.resolve().then(() => (init_state(), exports_state));
      await markOnboarded2(effectiveProjectRoot);
      firstRunHandled = true;
    }
  }
  const { withTelemetry: withTelemetry2 } = await Promise.resolve().then(() => (init_telemetry(), exports_telemetry));
  await withTelemetry2(effectiveProjectRoot, command.type, args, async () => {
    if (command.type !== "guided") {
      await executeCommand(command, effectiveProjectRoot, firstRunHandled);
      return;
    }
    await runGuidedFlow(effectiveProjectRoot, firstRunHandled);
  });
}
// src/cli/welcome.ts
init_dist3();
var LOGO = `
\u2588\u2588\u2557  \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557
\u2588\u2588\u2551 \u2588\u2588\u2554\u255D\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557
\u2588\u2588\u2588\u2588\u2588\u2554\u255D \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551
\u2588\u2588\u2554\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551\u255A\u2588\u2588\u2554\u255D\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551
\u2588\u2588\u2551  \u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551 \u255A\u2550\u255D \u2588\u2588\u2551\u255A\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D
\u255A\u2550\u255D  \u255A\u2550\u255D\u255A\u2550\u255D  \u255A\u2550\u255D\u255A\u2550\u255D  \u255A\u2550\u255D\u255A\u2550\u255D\u255A\u2550\u255D     \u255A\u2550\u255D \u255A\u2550\u2550\u2550\u2550\u2550\u255D
`;
var INTRO_TEXT = `Welcome to KARIMO \u2014 the autonomous development framework.

You are the architect. Agents are the builders.
KARIMO turns product requirements into shipped code using AI agents,
automated code review, and structured human oversight.`;
var LEVELS_TEXT = `KARIMO builds capabilities in levels:

  Level 0  Basic agent execution (current)
           Single task execution with pre-PR checks

  Level 1  GitHub Projects integration
           Automatic issue creation and tracking

  Level 2  Automated review (Greptile)
           AI-powered code review before human review

  Level 3  Full orchestration
           Multi-task execution with dependency resolution

  Level 4  Parallel execution + fallback engines
           Concurrent agents with engine failover

  Level 5  Dashboard
           Web UI for monitoring and control

You're starting at Level 0.`;
var WORKFLOW_TEXT = `How KARIMO works:

  1. Initialize   Set up your project with \`karimo init\`
                  Detects your stack, commands, and boundaries

  2. Plan         Create a PRD through guided conversation
                  Break features into agent-executable tasks

  3. Execute      Run agents on finalized PRDs
                  Each task gets its own branch and PR`;
async function showWelcome() {
  console.log(LOGO);
  pe("Autonomous Development Framework");
  me(INTRO_TEXT, "About KARIMO");
  me(LEVELS_TEXT, "Build Levels");
  me(WORKFLOW_TEXT, "Workflow");
  const proceed = await ce({
    message: "Ready to set up KARIMO for this project?",
    initialValue: true
  });
  if (lD(proceed)) {
    he("Setup cancelled.");
    process.exit(0);
  }
  if (!proceed) {
    ge("Run `karimo` again when you're ready.");
    return false;
  }
  return true;
}
async function showWelcomeBack() {
  pe("KARIMO");
  v2.info("Welcome back! Checking project status...");
}
function showCommandHelp() {
  console.log(`
Commands:
  karimo               Run guided workflow based on project state
  karimo init          Initialize KARIMO configuration
  karimo orchestrate   Execute tasks from a finalized PRD
  karimo status        Show current project and task status
  karimo help          Show this help message

Guided Workflow:
  When you run \`karimo\` without arguments, it detects your project
  state and guides you through the appropriate next step:

  \u2022 No .karimo/       \u2192 Welcome screen + initialization
  \u2022 Config exists     \u2192 Start PRD interview
  \u2022 PRD in progress   \u2192 Resume interview
  \u2022 PRD finalized     \u2192 Execute tasks

Documentation:
  https://github.com/opensesh/KARIMO
`);
}

// src/cli/index.ts
init_execute_flow();
init_ui();
init_ui();
init_state();
export {
  writeTelemetryEvent,
  withTelemetry,
  updateState,
  showWelcomeScreen,
  showWelcomeBack,
  showWelcome,
  showTransitionToInit,
  showExecutionFlow,
  showCompactHeader,
  showCommandHelp,
  setCurrentPRD,
  saveState,
  runFirstRunFlow,
  runDoctorSilent,
  recordDoctorRun,
  printResetHelp,
  printOrchestrateHelp,
  printNoteHelp,
  prdsDirExists,
  parseResetArgs,
  parseOrchestrateArgs,
  parseNoteArgs,
  parseDoctorArgs,
  parseCommand,
  markOnboarded,
  main,
  logRetry,
  logError,
  logCommandStart,
  logCommandEnd,
  loadState,
  karimoDirExists,
  isOnboarded,
  isFirstRun,
  handleReset,
  handleOrchestrate,
  handleNote,
  handleDoctor,
  getTelemetryPath,
  getPRDFileInfos,
  getNextPRDNumber,
  formatSafetyError,
  detectProjectPhase,
  configExists2 as configExists,
  colorize,
  clearCurrentPRD,
  checkWorkingDirectory,
  border,
  WH,
  RST,
  RD,
  PROJECT_SIGNALS,
  OR,
  MIN_SIGNAL_WEIGHT,
  GY,
  GN,
  BORDER_WIDTH,
  BOLD
};
